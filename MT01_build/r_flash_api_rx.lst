* RX FAMILY ASSEMBLER V2.03.00.01 [24 Oct 2014] *  SOURCE LIST  Tue Mar 14 17:29:00 2017

LOC.     OBJ.              0XMDA SOURCE STATEMENT

                                 ;RX Family C/C++ Compiler (V2.03.00.03 [04 Dec 2014])  14-Mar-2017 17:29:00
                                 
                                 ;*** CPU TYPE ***
                                 
                                 ;-ISA=RXV1
                                 
                                 ;*** COMMAND PARAMETER ***
                                 
                                 ;-output=src=r_flash_api_rx.src
                                 ;-lang=c99
                                 ;-include=C:\PROGRA~2\Renesas\RX\2_3_0/include,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx\src,C:/Workspace/e2studio/
                                 ;-debug
                                 ;-show=source,conditionals,definitions,expansions
                                 ;-listfile=r_flash_api_rx.lst
                                 ;-isa=rxv1
                                 ;-optimize=0
                                 ;-fpu
                                 ;-alias=noansi
                                 ;-nologo
                                 ;-nomessage
                                 ;-define=__RX,COMPACTAXP=0,EASYMAK=1,MOBILE=0,FREE_RTOS_PP
                                 ;r_flash_api_rx.c
                                 
                                 		.glb	_g_flash_BlockAddresses
                                 		.glb	_R_FlashCodeCopy
                                 		.glb	_R_FlashGetVersion
                                 		.glb	_R_FlashDataAreaBlankCheck
                                 		.glb	_R_FlashDataAreaAccess
                                 		.glb	_R_FlashGetStatus
                                 		.glb	_R_BSP_HardwareLock
                                 		.glb	_R_BSP_HardwareUnlock
                                 		.glb	_flash_ready_isr
                                 		.glb	_FlashError
                                 		.glb	_FlashEraseDone
                                 		.glb	_FlashBlankCheckDone
                                 		.glb	_FlashWriteDone
                                 		.glb	_R_FlashErase
                                 		.glb	_R_FlashEraseRange
                                 		.glb	_R_FlashWrite
                                 ;LineNo. C-SOURCE STATEMENT
                                 
                                 		.SECTION	P,CODE
00000000                         __$flash_init:
                                 		.STACK	__$flash_init=28
                                 ;       1 /*******************************************************************************
                                 ;       2 * DISCLAIMER
                                 ;       3 * This software is supplied by Renesas Electronics Corporation and is only 
                                 ;       4 * intended for use with Renesas products. No other uses are authorized. This 
                                 ;       5 * software is owned by Renesas Electronics Corporation and is protected under
                                 ;       6 * all applicable laws, including copyright laws.
                                 ;       7 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
                                 ;       8 * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
                                 ;       9 * LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE 
                                 ;      10 * AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
                                 ;      11 * TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS 
                                 ;      12 * ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE 
                                 ;      13 * FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
                                 ;      14 * ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
                                 ;      15 * BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
                                 ;      16 * Renesas reserves the right, without notice, to make changes to this software
                                 ;      17 * and to discontinue the availability of this software. By using this software,
                                 ;      18 * you agree to the additional terms and conditions found by accessing the 
                                 ;      19 * following link:
                                 ;      20 * http://www.renesas.com/disclaimer 
                                 ;      21 *
                                 ;      22 * Copyright (C) 2012 Renesas Electronics Corporation. All rights reserved.    
                                 ;      23 *******************************************************************************/
                                 ;      24 /******************************************************************************
                                 ;      25 * File Name    : r_flash_api_rx.c
                                 ;      26 * Device       : RX600 Series, RX200 Series
                                 ;      27 * Tool-Chain   : RX Family C Compiler
                                 ;      28 * H/W Platform : RSKRX62N, RSKRX610, YRDKRX62N, RSKRX630, RSKRX63N, RSKRX62T,
                                 ;      29 *                YRDKRX63N, RSKRX63T, RSKRX62G, RSKRX210
                                 ;      30 * Description  : Simple Flash API for RX
                                 ;      31 *******************************************************************************
                                 ;      32 * History : DD.MM.YYYY Version Description
                                 ;      33 *         : 21.12.2009 1.00    First Release
                                 ;      34 *         : 13.01.2010 1.10    Made function names and variables RAPI compliant
                                 ;      35 *         : 11.02.2010 1.20    Fixed other RAPI issues and fixed I flag issue
                                 ;      36 *         : 29.04.2010 1.30    Added support for RX621/N Group. Moved most
                                 ;      37 *                              device specific data to header file.
                                 ;      38 *         : 26.05.2010 1.40    Added support for RX62T Group
                                 ;      39 *         : 28.07.2010 1.41    Fixed bug when performing a blank check on an
                                 ;      40 *                              entire data flash block.  Also declared 
                                 ;      41 *                              functions not in the API as 'static'.
                                 ;      42 *         : 23.08.2010 1.42    Updated source to raise the coding standard, to
                                 ;      43 *                              meet GSCE & RSK standards.
                                 ;      44 *         : 15.02.2011 1.43    Fixed bug in blank check routine when handling
                                 ;      45 *                              input arguments and moved flash_init() to
                                 ;      46 *                              enter_pe_mode() function.
                                 ;      47 *         : 21.04.2011 2.00    Added BGO capabilities for data flash. Made 
                                 ;      48 *                              some more changes to fit coding standard. Added
                                 ;      49 *                              ability to do ROM to ROM or DF to DF transfers.
                                 ;      50 *                              Added the ability to use the lock bit feature
                                 ;      51 *                              on ROM blocks.  Added BGO capabilities for
                                 ;      52 *                              ROM operations.
                                 ;      53 *         : 06.07.2011 2.10    Added support for RX630, RX631, and RX63N.
                                 ;      54 *                              Also added R_FlashEraseRange() for devices like
                                 ;      55 *                              RX63x that have finer granularity data flash.
                                 ;      56 *                              Various bug fixes as well. Example bug fix was
                                 ;      57 *                              removing DATA_FLASH_OPERATION_PIPL and 
                                 ;      58 *                              ROM_OPERATION_PIPL #defines since the IPL was
                                 ;      59 *                              not restored when leaving flash ready interrupt.
                                 ;      60 *         : 29.11.2011 2.20    Renamed private functions according to new 
                                 ;      61 *                              Coding Standard. Removed unused 'bytes' argument 
                                 ;      62 *                              from enter_pe_mode() function. Removed 'far' 
                                 ;      63 *                              keyword since it is not needed. Fixed where some 
                                 ;      64 *                              functions were being placed in RAM when this was
                                 ;      65 *                              not needed. Uses platform.h now instead of 
                                 ;      66 *                              having multiple iodefine_rxXXX.h's. Added 
                                 ;      67 *                              __evenaccess directive to FCU accesses. This 
                                 ;      68 *                              ensures proper bus width accesses. Added
                                 ;      69 *                              R_FlashCodeCopy() function. When clearing the
                                 ;      70 *                              FENTRYR register, the register is read back to
                                 ;      71 *                              ensure its value is 0x0000. Added call to 
                                 ;      72 *                              exit_pe_mode() when enter_pe_mode() function 
                                 ;      73 *                              fails to protect against reading ROM in P/E
                                 ;      74 *                              mode. Added option to use r_bsp package.
                                 ;      75 *         : 11.09.2012 2.30    Updated to meet FIT v0.7 spec. Now uses r_bsp
                                 ;      76 *                              locking. Removed FLASH_API_USE_R_BSP macro. Code 
                                 ;      77 *                              now automatically detects r_bsp. Moved MCU 
                                 ;      78 *                              specific information into 'ports' folder instead 
                                 ;      79 *                              of keep on expanding r_flash_api_rx_if.h.
                                 ;      80 *                              Added R_FlashGetVersion() function. Added 
                                 ;      81 *                              timeout for while() loop reading back FENTRYR 
                                 ;      82 *                              value.
                                 ;      83 *         : 29.11.2012 2.40    Updated to meet FIT v1.0 spec. Added support
                                 ;      84 *                              for RX62G and RX63T MCU groups. Cleaned up 
                                 ;      85 *                              code some by removing almost all preprocessor
                                 ;      86 *                              statements that tested against MCU groups. Now
                                 ;      87 *                              have 'targets' directory for easier addition
                                 ;      88 *                              of new MCUs. Updated to use r_bsp v2.00.
                                 ;      89 ******************************************************************************/
                                 ;      90 
                                 ;      91 /******************************************************************************
                                 ;      92 Includes   <System Includes> , "Project Includes"
                                 ;      93 ******************************************************************************/
                                 ;      94 /* Intrinsic functions of MCU */
                                 ;      95 #include <machine.h>
                                 ;      96 
                                 ;      97 /* Allocate flash block array here. This is required before including
                                 ;      98    r_flash_api_rx.h */
                                 ;      99 #define FLASH_BLOCKS_DECLARE
                                 ;     100 
                                 ;     101 /* Configuration options for the Flash API. This is also included in 
                                 ;     102    r_flash_api_rx.h and would normally not need to be included separately.
                                 ;     103    It is included separately here so that the decision can be made to use
                                 ;     104    the r_bsp package or not. */
                                 ;     105 #include "r_flash_api_rx_config.h"
                                 ;     106 /* Get board and MCU definitions. */
                                 ;     107 #include "platform.h"
                                 ;     108 
                                 ;     109 #if !defined(R_BSP_VERSION_MAJOR)
                                 ;     110 #include "iodefine.h"
                                 ;     111 #include "mcu_info.h"
                                 ;     112 #endif
                                 ;     113 
                                 ;     114 /* Function prototypes and device specific info needed for Flash API */
                                 ;     115 #include "r_flash_api_rx_if.h"
                                 ;     116 /* Information needed for Flash API. */
                                 ;     117 #include "r_flash_api_rx_private.h"
                                 ;     118 
                                 ;     119 /******************************************************************************
                                 ;     120 Macro definitions
                                 ;     121 ******************************************************************************/
                                 ;     122 /* Define read mode macro */
                                 ;     123 #define READ_MODE               0
                                 ;     124 /* Define ROM PE mode macro */
                                 ;     125 #define ROM_PE_MODE             1
                                 ;     126 /* Define data flash PE mode macro */
                                 ;     127 #define FLD_PE_MODE             2
                                 ;     128 /* The number of ICLK ticks needed for 35us delay are calculated below */
                                 ;     129 #define WAIT_TRESW              (35*(BSP_ICLK_HZ/1000000))                  
                                 ;     130 /* The number of ICLK ticks needed for 10us delay are calculated below */
                                 ;     131 #define WAIT_T10USEC            (10*(BSP_ICLK_HZ/1000000))      
                                 ;     132 /* The number of loops to wait for FENTRYR timeout. */
                                 ;     133 #define FLASH_FENTRYR_TIMEOUT   (4)
                                 ;     134 
                                 ;     135 /******************************************************************************
                                 ;     136 Typedef definitions
                                 ;     137 ******************************************************************************/
                                 ;     138 /* These typedefs are used for guaranteeing correct accesses to memory. When 
                                 ;     139    working with the FCU sometimes byte or word accesses are required. */
                                 ;     140 typedef __evenaccess volatile uint8_t  * FCU_BYTE_PTR;
                                 ;     141 typedef __evenaccess volatile uint16_t * FCU_WORD_PTR;
                                 ;     142 typedef __evenaccess volatile uint32_t * FCU_LONG_PTR;
                                 ;     143 
                                 ;     144 /* These flash states are used internal for locking purposes. */
                                 ;     145 typedef enum
                                 ;     146 { 
                                 ;     147     FLASH_READY, 
                                 ;     148     FLASH_ERASING, 
                                 ;     149     FLASH_WRITING, 
                                 ;     150     FLASH_BLANKCHECK, 
                                 ;     151     FLASH_LOCK_BIT  
                                 ;     152 } flash_states_t;
                                 ;     153 
                                 ;     154 /******************************************************************************
                                 ;     155 Exported global variables 
                                 ;     156 ******************************************************************************/
                                 ;     157 
                                 ;     158 /******************************************************************************
                                 ;     159 Private global variables and functions
                                 ;     160 ******************************************************************************/
                                 ;     161 /* Signals whether FCU firmware has been transferred to the FCU RAM 
                                 ;     162    0 : No, 1 : Yes */
                                 ;     163 static uint8_t        g_fcu_transfer_complete = 0;
                                 ;     164 /* Valid values are 'READ_MODE','ROM_PE_MODE' or 'FLD_PE_MODE' */
                                 ;     165 static uint8_t        g_current_mode;        
                                 ;     166 /* Stores whether the peripheral clock notification command has 
                                 ;     167    been executed */
                                 ;     168 static uint8_t        g_fcu_pclk_command = 0;   
                                 ;     169 /* States for flash operations */
                                 ;     170 static flash_states_t g_flash_state;
                                 ;     171 
                                 ;     172 #ifndef FLASH_API_RX_CFG_IGNORE_LOCK_BITS                          
                                 ;     173 /* Determines whether lock bit protection is used when programming/erasing */
                                 ;     174 static uint8_t g_lock_bit_protection = true;                          
                                 ;     175 #endif
                                 ;     176 
                                 ;     177 /* Only allocate these arrays if needed. */
                                 ;     178 #ifdef FLASH_API_RX_CFG_FLASH_TO_FLASH   
                                 ;     179 /* Used for holding data when DF to DF write is peformed */
                                 ;     180     #if defined(ROM_PROGRAM_SIZE_LARGE)
                                 ;     181 static uint8_t g_temp_array[ROM_PROGRAM_SIZE_LARGE];
                                 ;     182     #else
                                 ;     183 static uint8_t g_temp_array[ROM_PROGRAM_SIZE];
                                 ;     184     #endif
                                 ;     185 /* Used for telling whether a DF to DF or ROM to ROM operation is on-going */
                                 ;     186 static uint8_t g_flash_to_flash_op;
                                 ;     187 #endif
                                 ;     188 
                                 ;     189 #if defined(FLASH_API_RX_CFG_DATA_FLASH_BGO) || defined(FLASH_API_RX_CFG_ROM_BGO)
                                 ;     190 /* How many bytes are left to program */
                                 ;     191 static uint32_t  g_bgo_bytes;
                                 ;     192 /* Where we are programming or erasing */
                                 ;     193 static uint32_t  g_bgo_flash_addr;
                                 ;     194 /* Where the data is that we are programming */
                                 ;     195 static uint32_t  g_bgo_buffer_addr;
                                 ;     196 #endif
                                 ;     197 
                                 ;     198 /* Flash intialisation function prototype */
                                 ;     199 static uint8_t  flash_init(void);
                                 ;     200 /* Enter PE mode function prototype */
                                 ;     201 static uint8_t  enter_pe_mode(uint32_t flash_addr);
                                 ;     202 /* Exit PE mode function prototype */
                                 ;     203 static void     exit_pe_mode(uint32_t flash_addr);
                                 ;     204 /* ROM write function prototype */
                                 ;     205 static uint8_t  rom_write(uint32_t address, uint32_t data, uint32_t size);
                                 ;     206 /* Data flash write function prototype */
                                 ;     207 static uint8_t  data_flash_write(uint32_t address, uint32_t data, uint32_t size);
                                 ;     208 /* Data flash status clear function prototype */
                                 ;     209 static void     data_flash_status_clear(void);
                                 ;     210 /* Notify peripheral clock function prototype */
                                 ;     211 static uint8_t  notify_peripheral_clock(FCU_BYTE_PTR flash_addr);
                                 ;     212 /* FCU reset function prototype */
                                 ;     213 static void     flash_reset(void);
                                 ;     214 /* Used to grab flash state */
                                 ;     215 static uint8_t  flash_grab_state(flash_states_t new_state);
                                 ;     216 /* Used to release flash state */
                                 ;     217 static void     flash_release_state(void);
                                 ;     218 /* Used to issue an erase command to the FCU */
                                 ;     219 static uint8_t  flash_erase_command(FCU_BYTE_PTR const erase_addr);
                                 ;     220 /* Used to get largest programming size that can be used. */
                                 ;     221 static uint32_t flash_get_program_size(uint32_t bytes, uint32_t flash_addr);
                                 ;     222 
                                 ;     223 /******************************************************************************
                                 ;     224 * Function Name: flash_init
                                 ;     225 * Description  : Initializes the FCU peripheral block.
                                 ;     226 *                NOTE: This function does not have to execute from in RAM.
                                 ;     227 * Arguments    : none
                                 ;     228 * Return Value : FLASH_SUCCESS -
                                 ;     229 *                    Operation Successful
                                 ;     230 *                FLASH_FAILURE -
                                 ;     231 *                    Operation Failed
                                 ;     232 ******************************************************************************/
                                 ;     233 static uint8_t flash_init (void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",233
00000000 7100E8                  		ADD #0FFFFFFE8H, R0
00000003 FBEE11C47F              		MOV.L #007FC411H, R14
                                 ;     234 {
                                 ;     235 #if defined(FCU_RAM_INIT_REQUIRED)    
                                 ;     236     /* Declare source and destination pointers */
                                 ;     237     uint32_t * src, * dst;  
                                 ;     238     /* Declare iteration counter variable */
                                 ;     239     uint16_t i;
                                 ;     240 #endif    
                                 ;     241     /* Timeout counter. */
                                 ;     242     volatile int32_t  wait_cnt;
                                 ;     243         
                                 ;     244     /* Disable FCU interrupts in FCU block */
                                 ;     245     FLASH.FAEINT.BIT.ROMAEIE = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",245
00000008 F0EF                    		BCLR #07H, [R14].B
0000000A                         L11:	; entry.split
0000000A FBEE11C47F              		MOV.L #007FC411H, R14
                                 ;     246     FLASH.FAEINT.BIT.CMDLKIE = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",246
0000000F F0EC                    		BCLR #04H, [R14].B
00000011                         L12:	; entry.split1
00000011 FBEE11C47F              		MOV.L #007FC411H, R14
                                 ;     247     FLASH.FAEINT.BIT.DFLAEIE = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",247
00000016 F0EB                    		BCLR #03H, [R14].B
00000018                         L13:	; entry.split2
00000018 FBEE11C47F              		MOV.L #007FC411H, R14
                                 ;     248     FLASH.FAEINT.BIT.DFLRPEIE = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",248
0000001D F0E9                    		BCLR #01H, [R14].B
0000001F                         L14:	; entry.split3
0000001F FBEE11C47F              		MOV.L #007FC411H, R14
                                 ;     249     FLASH.FAEINT.BIT.DFLWPEIE = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",249
00000024 F0E8                    		BCLR #00H, [R14].B
00000026                         L15:	; entry.split4
                                 ;     250     
                                 ;     251     /* Disable FCU interrupts in ICU */
                                 ;     252     
                                 ;     253     /* Disable flash interface error (FIFERR) */
                                 ;     254     IPR(FCU, FIFERR) = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",254
00000026 FBEE027208              		MOV.L #00087202H, R14
0000002B 754FF0                  		MOV.L #000000F0H, R15
0000002E 51EFFF                  		AND 0FFH[R14].UB, R15
00000031 C7EFFF                  		MOV.B R15, 0FFH[R14]
00000034                         L16:	; entry.split5
                                 ;     255     IEN(FCU, FIFERR) = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",255
00000034 FBEE027208              		MOV.L #00087202H, R14
00000039 F0ED                    		BCLR #05H, [R14].B
0000003B                         L17:	; entry.split6
                                 ;     256         
                                 ;     257 #if defined(FLASH_API_RX_CFG_DATA_FLASH_BGO) || defined(FLASH_API_RX_CFG_ROM_BGO)
                                 ;     258     /* Enable flash ready interrupt (FRDYI) */    
                                 ;     259     /* Make sure IPL is high enough that interrupt will trigger */
                                 ;     260     IPR(FCU, FRDYI) = FLASH_API_RX_CFG_FLASH_READY_IPL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",260
0000003B FBEE027208              		MOV.L #00087202H, R14
00000040 5AEF0001                		MOVU.B 0100H[R14], R15
00000044 655F                    		OR #05H, R15
00000046 762FF500                		AND #0F5H, R15
0000004A CBEF0001                		MOV.B R15, 0100H[R14]
0000004E                         L18:	; entry.split7
                                 ;     261     IEN(FCU, FRDYI) = 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",261
0000004E FBEE027208              		MOV.L #00087202H, R14
00000053 F0E7                    		BSET #07H, [R14].B
00000055                         L19:	; entry.split8
00000055 FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;     262 #else        
                                 ;     263     /* Disable flash ready interrupt (FRDYI) */
                                 ;     264     IPR(FCU, FRDYI) = 0;
                                 ;     265     IEN(FCU, FRDYI) = 0;
                                 ;     266 #endif    
                                 ;     267 
                                 ;     268     /* Transfer Firmware to the FCU RAM. To use FCU commands, the FCU firmware
                                 ;     269         must be stored in the FCU RAM. */
                                 ;     270     
                                 ;     271     /* Before writing data to the FCU RAM, clear FENTRYR to stop the FCU. */
                                 ;     272     if(FLASH.FENTRYR.WORD != 0x0000)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",272
0000005A 5CEE                    		MOVU.W [R14], R14
0000005C 610E                    		CMP #00H, R14
0000005E 20rr                    		BEQ L25
00000060                         L20:	; bb32
00000060 FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;     273     {
                                 ;     274         /* Disable the FCU from accepting commands - Clear both the
                                 ;     275            FENTRY0(ROM) and FENTRYD(Data Flash) bits to 0 */
                                 ;     276         FLASH.FENTRYR.WORD = 0xAA00;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",276
00000065 F8E900AA                		MOV.W #0AA00H, [R14]
00000069                         L21:	; bb32.split
                                 ;     277 
                                 ;     278         /* Initialize timeout for FENTRYR being written. */
                                 ;     279         wait_cnt = FLASH_FENTRYR_TIMEOUT;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",279
00000069 3E0404                  		MOV.L #00000004H, 10H[R0]
0000006C 2Err                 B  		BRA L24
0000006E                         L22:	; bb34
                                 ;     280 
                                 ;     281         /* Read FENTRYR to ensure it has been set to 0. Note that the top byte
                                 ;     282            of the FENTRYR register is not retained and is read as 0x00. */
                                 ;     283         while(0x0000 != FLASH.FENTRYR.WORD)
                                 ;     284         {
                                 ;     285             /* Wait until FENTRYR is 0 unless timeout occurs. */
                                 ;     286             if (wait_cnt-- <= 0)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",286
0000006E A901                    		MOV.L 10H[R0], R1
00000070 A902                    		MOV.L 10H[R0], R2
00000072 6012                    		SUB #01H, R2
00000074 A102                    		MOV.L R2, 10H[R0]
00000076 6101                    		CMP #00H, R1
00000078 2Arr                    		BGT L24
0000007A                         L23:	; bb35
                                 ;     287             {
                                 ;     288                 /* This should not happen. FENTRYR getting written to 0 should
                                 ;     289                    only take 2-4 PCLK cycles. */
                                 ;     290                 return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",290
0000007A 3C0306                  		MOV.B #06H, 03H[R0]
0000007D 2Err                 B  		BRA L35
0000007F                         L24:	; bb43
0000007F FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",283
00000084 5CEE                    		MOVU.W [R14], R14
00000086 610E                    		CMP #00H, R14
00000088 21rr                    		BNE L22
0000008A                         L25:	; bb55
0000008A FBEE54C47F              		MOV.L #007FC454H, R14
                                 ;     291             }
                                 ;     292         }
                                 ;     293     }
                                 ;     294 
                                 ;     295 #if defined(FCU_RAM_INIT_REQUIRED)
                                 ;     296     /* Enable the FCU RAM */
                                 ;     297     FLASH.FCURAME.WORD = 0xC401;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",297
0000008F F8E901C4                		MOV.W #0C401H, [R14]
00000093                         L26:	; bb55.split
                                 ;     298     
                                 ;     299     /* Copies the FCU firmware to the FCU RAM.
                                 ;     300        Source: H'FEFFE000 to H'FF00000 (FCU firmware area)
                                 ;     301        Destination: H'007F8000 to H'007FA000 (FCU RAM area) */
                                 ;     302     /* Set source pointer */
                                 ;     303     src = (uint32_t *)FCU_PRG_TOP;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",303
00000093 F9020100E0FFFE          		MOV.L #0FEFFE000H, 04H[R0]
0000009A                         L27:	; bb55.split9
                                 ;     304     
                                 ;     305     /* Set destination pointer */
                                 ;     306     dst = (uint32_t *)FCU_RAM_TOP;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",306
0000009A F90E0200807F            		MOV.L #007F8000H, 08H[R0]
000000A0                         L28:	; bb55.split10
                                 ;     307     
                                 ;     308     /* Iterate for loop to copy the FCU firmware */
                                 ;     309     for( i=0; i<(FCU_RAM_SIZE/4); i++)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",309
000000A0 3D0700                  		MOV.W #0000H, 0EH[R0]
000000A3 2Err                 B  		BRA L32
000000A5                         L29:	; bb56
                                 ;     310     {
                                 ;     311         /* Copy data from the source to the destination pointer */
                                 ;     312         *dst = *src;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",312
000000A5 A809                    		MOV.L 04H[R0], R1
000000A7 A882                    		MOV.L 08H[R0], R2
000000A9 E012                    		MOV.L [R1], [R2]
000000AB                         L30:	; bb56.split
                                 ;     313         
                                 ;     314         /* Increment the source and destination pointers */
                                 ;     315         src++;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",315
000000AB A809                    		MOV.L 04H[R0], R1
000000AD 6241                    		ADD #04H, R1
000000AF A009                    		MOV.L R1, 04H[R0]
000000B1                         L31:	; bb56.split11
                                 ;     316         dst++;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",316
000000B1 A881                    		MOV.L 08H[R0], R1
000000B3 6241                    		ADD #04H, R1
000000B5 A081                    		MOV.L R1, 08H[R0]
000000B7 9989                    		MOV.W 0EH[R0], R1
000000B9 6211                    		ADD #01H, R1
000000BB 9189                    		MOV.W R1, 0EH[R0]
000000BD                         L32:	; bb66
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",309
000000BD B989                    		MOVU.W 0EH[R0], R1
000000BF 76010008                		CMP #0800H, R1
000000C3 29rr                    		BLT L29
000000C5                         L33:	; bb72
                                 ;     317     }
                                 ;     318 #endif
                                 ;     319 
                                 ;     320     /* FCU firmware transfer complete, set the flag to 1 */
                                 ;     321     g_fcu_transfer_complete = 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",321
000000C5 FBE2rrrrrrrr            		MOV.L #__$g_fcu_transfer_complete, R14
000000CB F8E401                  		MOV.B #01H, [R14]
000000CE                         L34:	; bb72.split
                                 ;     322 
                                 ;     323     /* Return no errors */
                                 ;     324     return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",324
000000CE 3C0300                  		MOV.B #00H, 03H[R0]
000000D1                         L35:	; bb74
000000D1 C5000317                		MOV.B 03H[R0], 17H[R0]
                                 ;     325 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",325
000000D5 B589                    		MOVU.B 17H[R0], R1
000000D7 6706                    		RTSD #18H
000000D9                         _R_FlashCodeCopy:
                                 		.STACK	_R_FlashCodeCopy=4
                                 ;     326 /******************************************************************************
                                 ;     327 End of function  flash_init
                                 ;     328 ******************************************************************************/
                                 ;     329 
                                 ;     330 #ifdef FLASH_API_RX_CFG_COPY_CODE_BY_API
                                 ;     331 /******************************************************************************
                                 ;     332 * Function Name: R_FlashCodeCopy
                                 ;     333 * Description  : Copies Flash API code from ROM to RAM. This function needs to
                                 ;     334 *                be called before any program/erase functions. This function
                                 ;     335 *                does not need to be used when 
                                 ;     336 *                NOTE: This function does not have to execute from in RAM.
                                 ;     337 * Arguments    : none
                                 ;     338 * Return Value : none
                                 ;     339 ******************************************************************************/
                                 ;     340 void R_FlashCodeCopy (void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",340
000000D9 02                      		RTS
000000DA                         _R_FlashGetVersion:
                                 		.STACK	_R_FlashGetVersion=8
                                 ;     341 {
                                 ;     342 #ifdef FLASH_API_RX_CFG_ENABLE_ROM_PROGRAMMING
                                 ;     343     /* Pointer to beginning of RAM section where API code will be copied to. */
                                 ;     344     uint8_t * p_ram_section;
                                 ;     345     /* Pointer to beginning of ROM section with API code. */
                                 ;     346     uint8_t * p_rom_section;
                                 ;     347     /* Number of bytes copied. */
                                 ;     348     uint32_t  bytes_copied;
                                 ;     349 
                                 ;     350     /* Initialize RAM section pointer. */
                                 ;     351     p_ram_section = (uint8_t *)__sectop("RPFRAM");
                                 ;     352 
                                 ;     353     /* Initialize ROM section pointer. */
                                 ;     354     p_rom_section = (uint8_t *)__sectop("PFRAM");
                                 ;     355 
                                 ;     356     /* Copy over code from ROM to RAM. */
                                 ;     357     for (bytes_copied = 0; bytes_copied < __secsize("PFRAM"); bytes_copied++)
                                 ;     358     {
                                 ;     359         /* Copy over data 1 byte at a time. */
                                 ;     360         p_ram_section[bytes_copied] = p_rom_section[bytes_copied];
                                 ;     361     }
                                 ;     362 #endif
                                 ;     363 }
                                 ;     364 /******************************************************************************
                                 ;     365 End of function  R_FlashCodeCopy
                                 ;     366 ******************************************************************************/
                                 ;     367 #endif
                                 ;     368 
                                 ;     369 /******************************************************************************
                                 ;     370 * Function Name: R_FlashGetVersion
                                 ;     371 * Description  : Returns the current version of this module. The version number
                                 ;     372 *                is encoded where the top 2 bytes are the major version number 
                                 ;     373 *                and the bottom 2 bytes are the minor version number. For 
                                 ;     374 *                example, Version 4.25 would be returned as 0x00040019.
                                 ;     375 * Arguments    : none
                                 ;     376 * Return Value : Version of this module.
                                 ;     377 ******************************************************************************/
                                 ;     378 #pragma inline(R_FlashGetVersion)
                                 ;     379 uint32_t R_FlashGetVersion (void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",379
000000DA 6040                    		SUB #04H, R0
                                 ;     380 {
                                 ;     381     return ((((uint32_t)RX_FLASH_API_VERSION_MAJOR) << 16) | ((uint32_t)RX_FLASH_API_VERSION_MINOR));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",381
000000DC F80E280002              		MOV.L #00020028H, [R0]
000000E1 FB1E280002              		MOV.L #00020028H, R1
000000E6                         L38:	; entry.split
                                 ;     382 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",382
000000E6 6701                    		RTSD #04H
000000E8                         __$data_flash_status_clear:
                                 		.STACK	__$data_flash_status_clear=8
                                 ;     383 /******************************************************************************
                                 ;     384 End of function  R_FlashGetVersion
                                 ;     385 ******************************************************************************/
                                 ;     386 
                                 ;     387 /******************************************************************************
                                 ;     388 * Function Name: data_flash_status_clear
                                 ;     389 * Description  : Clear the status of the Data Flash operation.
                                 ;     390 *                NOTE: This function does not have to execute from in RAM.
                                 ;     391 * Arguments    : none
                                 ;     392 * Return Value : none
                                 ;     393 ******************************************************************************/
                                 ;     394 static void data_flash_status_clear (void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",394
000000E8 6040                    		SUB #04H, R0
                                 ;     395 {
                                 ;     396     /* Declare temporaty pointer */
                                 ;     397     FCU_BYTE_PTR ptrb;
                                 ;     398 
                                 ;     399     /* Set pointer to Data Flash to issue a FCU command if needed */
                                 ;     400     ptrb = (FCU_BYTE_PTR)(DF_ADDRESS);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",400
000000EA F80E000010              		MOV.L #00100000H, [R0]
000000EF                         L40:	; entry.split
                                 ;     401 
                                 ;     402     /* Check to see if an error has occurred with the FCU.  If set, then
                                 ;     403        issue a status clear command to bring the FCU out of the 
                                 ;     404        command-locked state */
                                 ;     405     if(FLASH.FSTATR0.BIT.ILGLERR == 1)  
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",405
000000EF FBEE10C47F              		MOV.L #007FC410H, R14
000000F4 5AEEA03B                		MOVU.B 3BA0H[R14], R14
000000F8 686E                    		SHLR #06H, R14
000000FA 641E                    		AND #01H, R14
000000FC 611E                    		CMP #01H, R14
000000FE 21rr                    		BNE L43
00000100                         L41:	; bb3
                                 ;     406     {
                                 ;     407         /* FASTAT must be set to 0x10 before the status clear command
                                 ;     408            can be successfully issued  */
                                 ;     409         if(FLASH.FASTAT.BYTE != 0x10)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",409
00000100 FBEE10C47F              		MOV.L #007FC410H, R14
00000105 58EE                    		MOVU.B [R14], R14
00000107 755E10                  		CMP #10H, R14
0000010A 10                   S  		BEQ L43
0000010B                         L42:	; bb4
                                 ;     410         {
                                 ;     411             /* Set the FASTAT register to 0x10 so that a status clear
                                 ;     412                command can be issued */
                                 ;     413             FLASH.FASTAT.BYTE = 0x10;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",413
0000010B FBEE10C47F              		MOV.L #007FC410H, R14
00000110 F8E410                  		MOV.B #10H, [R14]
00000113                         L43:	; bb16
                                 ;     414         }
                                 ;     415     }
                                 ;     416 
                                 ;     417     /* Issue a status clear command to the FCU */
                                 ;     418     *ptrb = 0x50;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",418
00000113 EC01                    		MOV.L [R0], R1
00000115 F81450                  		MOV.B #50H, [R1]
00000118 6701                    		RTSD #04H
0000011A                         __$data_flash_write:
                                 		.STACK	__$data_flash_write=28
                                 ;     419 }
                                 ;     420 /******************************************************************************
                                 ;     421 End of function  data_flash_status_clear
                                 ;     422 ******************************************************************************/
                                 ;     423 
                                 ;     424 /******************************************************************************
                                 ;     425 * Function Name: data_flash_write
                                 ;     426 * Description  : Write either bytes to Data Flash area.
                                 ;     427 *                NOTE: This function does not have to execute from in RAM.
                                 ;     428 * Arguments    : address - 
                                 ;     429 *                    The address (in the Data Flash programming area) 
                                 ;     430 *                    to write the data to   
                                 ;     431 *                data - 
                                 ;     432 *                    The address of the data to write
                                 ;     433 *                size - 
                                 ;     434 *                    The size of the data to write. Must be set to 
                                 ;     435 *                    either DF_PROGRAM_SIZE_LARGE or DF_PROGRAM_SIZE_SMALL.
                                 ;     436 * Return Value : FLASH_SUCCESS -
                                 ;     437 *                    Operation Successful
                                 ;     438 *                FLASH_FAILURE -
                                 ;     439 *                    Operation Failed
                                 ;     440 ******************************************************************************/
                                 ;     441 static uint8_t data_flash_write (uint32_t address, uint32_t data, uint32_t size)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",441
0000011A 7100E8                  		ADD #0FFFFFFE8H, R0
0000011D A109                    		MOV.L R1, 14H[R0]
0000011F A102                    		MOV.L R2, 10H[R0]
00000121 A08B                    		MOV.L R3, 0CH[R0]
                                 ;     442 {
                                 ;     443     /* Declare wait counter variable */
                                 ;     444     volatile int32_t wait_cnt;
                                 ;     445     
                                 ;     446     /* Define loop iteration count variable */
                                 ;     447     volatile uint32_t n = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",447
00000123 3E0100                  		MOV.L #00000000H, 04H[R0]
00000126                         L45:	; entry.split
                                 ;     448     
                                 ;     449     /* Check data size is valid */   
                                 ;     450 #if defined(DF_PROGRAM_SIZE_LARGE)
                                 ;     451     if((DF_PROGRAM_SIZE_LARGE == size) || (DF_PROGRAM_SIZE_SMALL == size))   
                                 ;     452 #else 
                                 ;     453     if(DF_PROGRAM_SIZE_SMALL == size)    
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",453
00000126 A889                    		MOV.L 0CH[R0], R1
00000128 6121                    		CMP #02H, R1
0000012A 21rr                    		BNE L54
0000012C                         L46:	; bb6
                                 ;     454 #endif
                                 ;     455     {
                                 ;     456         /* Perform bit shift since 2 bytes are written at a time */
                                 ;     457         size = (uint8_t)(size >> 1);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",457
0000012C A889                    		MOV.L 0CH[R0], R1
0000012E 6811                    		SHLR #01H, R1
00000130 5B11                    		MOVU.B R1, R1
00000132 A089                    		MOV.L R1, 0CH[R0]
00000134                         L47:	; bb6.split
00000134 FBEE000010              		MOV.L #00100000H, R14
                                 ;     458         
                                 ;     459         /* Send command to data flash area */
                                 ;     460         *(FCU_BYTE_PTR)DF_ADDRESS = 0xE8;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",460
00000139 F8E4E8                  		MOV.B #0E8H, [R14]
0000013C                         L48:	; bb6.split1
                                 ;     461 
                                 ;     462         /* Specify data transfer size to data flash area */
                                 ;     463         *(FCU_BYTE_PTR)DF_ADDRESS = size;    
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",463
0000013C A889                    		MOV.L 0CH[R0], R1
0000013E FBEE000010              		MOV.L #00100000H, R14
00000143 C3E1                    		MOV.B R1, [R14]
00000145 2Err                 B  		BRA L51
00000147                         L49:	; bb13
                                 ;     464         
                                 ;     465         /* Iterate through the number of data bytes */
                                 ;     466         while(n++ < size)
                                 ;     467         {
                                 ;     468             /* Copy data from source address to destination area */
                                 ;     469             *(FCU_WORD_PTR)address = *(uint16_t *)data;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",469
00000147 A901                    		MOV.L 10H[R0], R1
00000149 A90A                    		MOV.L 14H[R0], R2
0000014B D012                    		MOV.W [R1], [R2]
0000014D                         L50:	; bb13.split
                                 ;     470         
                                 ;     471             /* Increment data address by two bytes */
                                 ;     472             data += 2;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",472
0000014D A901                    		MOV.L 10H[R0], R1
0000014F 6221                    		ADD #02H, R1
00000151 A101                    		MOV.L R1, 10H[R0]
00000153                         L51:	; bb21
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",466
00000153 A809                    		MOV.L 04H[R0], R1
00000155 A88A                    		MOV.L 0CH[R0], R2
00000157 A80B                    		MOV.L 04H[R0], R3
00000159 6213                    		ADD #01H, R3
0000015B A00B                    		MOV.L R3, 04H[R0]
0000015D 4721                    		CMP R2, R1
0000015F 23rr                    		BLTU L49
00000161                         L52:	; bb28
00000161 FBEE000010              		MOV.L #00100000H, R14
                                 ;     473         }
                                 ;     474 
                                 ;     475         /* Write the final FCU command for programming */
                                 ;     476         *(FCU_BYTE_PTR)(DF_ADDRESS) = 0xD0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",476
00000166 F8E4D0                  		MOV.B #0D0H, [R14]
00000169                         L53:	; bb28.split
                                 ;     477         
                                 ;     478 #ifdef FLASH_API_RX_CFG_DATA_FLASH_BGO
                                 ;     479         /* Program is ongoing, return */
                                 ;     480         return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",480
00000169 3C0300                  		MOV.B #00H, 03H[R0]
0000016C 08                   S  		BRA L55
0000016D                         L54:	; bb73
                                 ;     481 #endif
                                 ;     482 
                                 ;     483         /* Set the wait counter with timeout value */
                                 ;     484         wait_cnt = WAIT_MAX_DF_WRITE;
                                 ;     485 
                                 ;     486         /* Check if FCU has completed its last operation */
                                 ;     487         while(FLASH.FSTATR0.BIT.FRDY == 0)
                                 ;     488         {   
                                 ;     489             /* Decrement the wait counter */
                                 ;     490             wait_cnt--;
                                 ;     491         
                                 ;     492             /* Check if the wait counter has reached zero */
                                 ;     493             if(wait_cnt == 0)
                                 ;     494             {            
                                 ;     495                 /* Maximum time for writing a block has passed, 
                                 ;     496                    operation failed, reset FCU */
                                 ;     497                 flash_reset();
                                 ;     498                 
                                 ;     499                 /* Return FLASH_FAILURE, operation failure */
                                 ;     500                 return FLASH_FAILURE;
                                 ;     501             }
                                 ;     502         }
                                 ;     503 
                                 ;     504         /* Check for illegal command or programming errors */
                                 ;     505         if((FLASH.FSTATR0.BIT.ILGLERR == 1) || (FLASH.FSTATR0.BIT.PRGERR == 1))
                                 ;     506         {        
                                 ;     507             /* Return FLASH_FAILURE, operation failure */
                                 ;     508             return FLASH_FAILURE;
                                 ;     509         }                
                                 ;     510     }
                                 ;     511     /* Data size is invalid */
                                 ;     512     else
                                 ;     513     {
                                 ;     514         /*Return FLASH_FAILURE, operation failure */
                                 ;     515         return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",515
0000016D 3C0306                  		MOV.B #06H, 03H[R0]
00000170                         L55:	; bb81
00000170 C500030B                		MOV.B 03H[R0], 0BH[R0]
                                 ;     516     }
                                 ;     517  
                                 ;     518     /* Return FLASH_SUCCESS, operation success */
                                 ;     519     return FLASH_SUCCESS;
                                 ;     520 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",520
00000174 B289                    		MOVU.B 0BH[R0], R1
00000176 6706                    		RTSD #18H
00000178                         _R_FlashDataAreaBlankCheck:
                                 		.STACK	_R_FlashDataAreaBlankCheck=32
                                 ;     521 /******************************************************************************
                                 ;     522 End of function  data_flash_write
                                 ;     523 ******************************************************************************/
                                 ;     524 
                                 ;     525 /* If FLASH_API_RX_CFG_ROM_BGO is enabled then the following functions (before
                                 ;     526    the next #pragma section) also need to be in RAM in the case that the user 
                                 ;     527    calls them during a ROM operation. */
                                 ;     528 #ifdef FLASH_API_RX_CFG_ROM_BGO
                                 ;     529 #pragma section FRAM
                                 ;     530 #endif
                                 ;     531 
                                 ;     532 /******************************************************************************
                                 ;     533 * Function Name: R_FlashDataAreaBlankCheck
                                 ;     534 * Description  : Performs a blank check on a specified data flash block
                                 ;     535 *                NOTE1: This function does not have to execute from in RAM. It
                                 ;     536 *                       must be in RAM though if FLASH_API_RX_CFG_ROM_BGO is 
                                 ;     537 *                       enabled and this function is called during a ROM P/E 
                                 ;     538 *                       operation.
                                 ;     539 *                NOTE2: RX610 & RX62x support block and 8 byte checks
                                 ;     540 *                       RX630/631/63N support block and 2 byte checks
                                 ;     541 * Arguments    : address - 
                                 ;     542 *                    The address to check if is blank.
                                 ;     543 *                    If the parameter 'size'=='BLANK_CHECK_8_BYTE', 
                                 ;     544 *                    this should be set to an 8-byte address boundary.
                                 ;     545 *                    If the parameter 'size'=='BLANK_CHECK_ENTIRE_BLOCK', 
                                 ;     546 *                    this should be set to a defined Data Block Number 
                                 ;     547 *                    ('BLOCK_DB0', 'BLOCK_DB1', etc...) or an address 
                                 ;     548 *                    in the data flash block.  Either option will work.
                                 ;     549 *                    If the parameter 'size'=='BLANK_CHECK_2_BYTE',
                                 ;     550 *                    this should be set to a 2 byte address boundary.
                                 ;     551 *                size - 
                                 ;     552 *                    This specifies if you are checking an 8-byte location,
                                 ;     553 *                    2-byte location, or an entire block. You must set this 
                                 ;     554 *                    to either 'BLANK_CHECK_8_BYTE', 'BLANK_CHECK_2_BYTE', 
                                 ;     555 *                    or 'BLANK_CHECK_ENTIRE_BLOCK'.
                                 ;     556 * Return Value : FLASH_BLANK -
                                 ;     557 *                    (2 or 8 Byte check or non-BGO) Blank
                                 ;     558 *                    (Entire Block & BGO) Blank check operation started
                                 ;     559 *                FLASH_NOT_BLANK -
                                 ;     560 *                    Not Blank
                                 ;     561 *                FLASH_FAILURE -
                                 ;     562 *                    Operation Failed
                                 ;     563 *                FLASH_BUSY - 
                                 ;     564 *                    Another flash operation is in progress
                                 ;     565 *                FLASH_ERROR_ADDRESS -
                                 ;     566 *                    Invalid address
                                 ;     567 *                FLASH_ERROR_BYTES - 
                                 ;     568 *                    Incorrect 'size' was submitted
                                 ;     569 ******************************************************************************/
                                 ;     570 uint8_t R_FlashDataAreaBlankCheck (uint32_t address, uint8_t size)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",570
00000178 7100E4                  		ADD #0FFFFFFE4H, R0
0000017B A181                    		MOV.L R1, 18H[R0]
0000017D 858A                    		MOV.B R2, 17H[R0]
                                 ;     571 {
                                 ;     572     /* Declare data flash pointer */
                                 ;     573     FCU_BYTE_PTR ptrb;
                                 ;     574     
                                 ;     575     /* Declare result container variable */
                                 ;     576     uint8_t result;
                                 ;     577     
                                 ;     578     /* Declare wait counter variable */
                                 ;     579     volatile int32_t wait_cnt;
                                 ;     580 
                                 ;     581     /* Check to make sure address is valid. */
                                 ;     582     if( ((address > (DF_NUM_BLOCKS+BLOCK_DB0)) && (address < DF_ADDRESS))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",582
0000017F A981                    		MOV.L 18H[R0], R1
00000181 755156                  		CMP #56H, R1
00000184 24rr                    		BGTU L58
00000186 2Err                 B  		BRA L60
00000188                         L57:	; bb6
                                 ;     583         || (address > DF_ADDRESS + BSP_DATA_FLASH_SIZE_BYTES) )
                                 ;     584     {
                                 ;     585         /* Address is not a valid DF address or block number */
                                 ;     586         return FLASH_ERROR_ADDRESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",586
00000188 3C0703                  		MOV.B #03H, 07H[R0]
0000018B 38rrrr               W  		BRA L110
0000018E                         L58:	; bb11
0000018E A981                    		MOV.L 18H[R0], R1
00000190 7701FFFF0F              		CMP #000FFFFFH, R1
00000195 24rr                    		BGTU L60
00000197                         L59:	; bb15
00000197 F80601                  		MOV.L #00000001H, [R0]
0000019A 08                   S  		BRA L61
0000019B                         L60:	; bb16
0000019B F80600                  		MOV.L #00000000H, [R0]
0000019E                         L61:	; bb17
0000019E EC01                    		MOV.L [R0], R1
000001A0 6101                    		CMP #00H, R1
000001A2 18                   S  		BNE L63
000001A3                         L62:	; bb20
000001A3 A981                    		MOV.L 18H[R0], R1
000001A5 7701018010              		CMP #00108001H, R1
000001AA 23rr                    		BLTU L64
000001AC                         L63:	; bb24
000001AC F80601                  		MOV.L #00000001H, [R0]
000001AF 08                   S  		BRA L65
000001B0                         L64:	; bb25
000001B0 F80600                  		MOV.L #00000000H, [R0]
000001B3                         L65:	; bb26
000001B3 EC01                    		MOV.L [R0], R1
000001B5 6101                    		CMP #00H, R1
000001B7 21rr                    		BNE L57
000001B9                         L66:	; bb32
                                 ;     587     }
                                 ;     588 
                                 ;     589     /* Check to make sure 'size' parameter is valid */
                                 ;     590     if( (size != BLANK_CHECK_ENTIRE_BLOCK) 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",590
000001B9 B589                    		MOVU.B 17H[R0], R1
000001BB 6111                    		CMP #01H, R1
000001BD 18                   S  		BNE L68
000001BE 2Err                 B  		BRA L70
000001C0                         L67:	; bb33
                                 ;     591 #if defined(BLANK_CHECK_8_BYTE)
                                 ;     592         && (size != BLANK_CHECK_8_BYTE) 
                                 ;     593 #elif defined(BLANK_CHECK_2_BYTE)
                                 ;     594         && (size != BLANK_CHECK_2_BYTE) 
                                 ;     595 #endif
                                 ;     596       )
                                 ;     597     {
                                 ;     598         /* 'size' parameter is not valid. */
                                 ;     599         return FLASH_ERROR_BYTES;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",599
000001C0 3C0702                  		MOV.B #02H, 07H[R0]
000001C3 38rrrr               W  		BRA L110
000001C6                         L68:	; bb39
000001C6 B589                    		MOVU.B 17H[R0], R1
000001C8 6101                    		CMP #00H, R1
000001CA 10                   S  		BEQ L70
000001CB                         L69:	; bb44
000001CB F80601                  		MOV.L #00000001H, [R0]
000001CE 08                   S  		BRA L71
000001CF                         L70:	; bb45
000001CF F80600                  		MOV.L #00000000H, [R0]
000001D2                         L71:	; bb46
000001D2 EC01                    		MOV.L [R0], R1
000001D4 6101                    		CMP #00H, R1
000001D6 21rr                    		BNE L67
000001D8                         L72:	; bb52
000001D8 6631                    		MOV.L #00000003H, R1
                                 ;     600     }
                                 ;     601         
                                 ;     602     /* Attempt to grab state */
                                 ;     603     if( flash_grab_state(FLASH_BLANKCHECK) != FLASH_SUCCESS )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",603
000001DA 39rrrr               W  		BSR __$flash_grab_state
000001DD 6101                    		CMP #00H, R1
000001DF 10                   S  		BEQ L74
000001E0                         L73:	; bb53
                                 ;     604     {
                                 ;     605         /* Another operation is already in progress */
                                 ;     606         return FLASH_BUSY;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",606
000001E0 3C0705                  		MOV.B #05H, 07H[R0]
000001E3 38rrrr               W  		BRA L110
000001E6                         L74:	; bb60
                                 ;     607     }
                                 ;     608     
                                 ;     609     /* Set current FCU mode to Data Flash PE Mode */
                                 ;     610     g_current_mode = FLD_PE_MODE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",610
000001E6 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
000001EC F8E402                  		MOV.B #02H, [R14]
000001EF                         L75:	; bb60.split
                                 ;     611 
                                 ;     612     /* Enter Data Flash PE mode in the FCU */
                                 ;     613     if( enter_pe_mode(address) != FLASH_SUCCESS)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",613
000001EF A981                    		MOV.L 18H[R0], R1
000001F1 39rrrr               W  		BSR __$enter_pe_mode
000001F4 6101                    		CMP #00H, R1
000001F6 20rr                    		BEQ L79
000001F8                         L76:	; bb62
                                 ;     614     {
                                 ;     615         /* Make sure part is in ROM read mode. */
                                 ;     616         exit_pe_mode(address);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",616
000001F8 A981                    		MOV.L 18H[R0], R1
000001FA 39rrrr               W  		BSR __$exit_pe_mode
000001FD                         L77:	; bb62.split
                                 ;     617 
                                 ;     618         /* Release state */
                                 ;     619         flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",619
000001FD 39rrrr               W  		BSR __$flash_release_state
00000200                         L78:	; bb62.split1
                                 ;     620         
                                 ;     621         /* Return FLASH_FAILURE, operation failure */
                                 ;     622         return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",622
00000200 3C0706                  		MOV.B #06H, 07H[R0]
00000203 38rrrr               W  		BRA L110
00000206                         L79:	; bb71
                                 ;     623     }
                                 ;     624 
                                 ;     625     /* Set  bit FRDMD (bit 4) in FMODR to 1 */
                                 ;     626     FLASH.FMODR.BIT.FRDMD = 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",626
00000206 FBEE02C47F              		MOV.L #007FC402H, R14
0000020B F0E4                    		BSET #04H, [R14].B
0000020D                         L80:	; bb71.split
                                 ;     627 
                                 ;     628 #if   defined(BLANK_CHECK_8_BYTE)
                                 ;     629     /* Check if 8 byte size has been passed */
                                 ;     630     if(size == BLANK_CHECK_8_BYTE)
                                 ;     631     {
                                 ;     632         #ifdef FLASH_API_RX_CFG_DATA_FLASH_BGO
                                 ;     633         /* Disable FCU ready interrupt for 8 byte checks */
                                 ;     634         FLASH.FRDYIE.BIT.FRDYIE = 0;
                                 ;     635         #endif        
                                 ;     636         
                                 ;     637         /* Set data flash pointer to beginning of the memory block */
                                 ;     638         ptrb = (FCU_BYTE_PTR)(address & DF_MASK);   
                                 ;     639         
                                 ;     640         /* Check if the next 8 bytes are blank
                                 ;     641            Bits BCADR to the address of the 8-byte location to check.         
                                 ;     642            Set bit BCSIZE in EEPBCCNT to 0. */
                                 ;     643         FLASH.DFLBCCNT.WORD = (uint16_t)(address & (DF_ERASE_BLOCK_SIZE-8));
                                 ;     644     }
                                 ;     645 #elif defined(BLANK_CHECK_2_BYTE)
                                 ;     646     /* Check if 2 byte size has been passed */
                                 ;     647     if(size == BLANK_CHECK_2_BYTE)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",647
0000020D B589                    		MOVU.B 17H[R0], R1
0000020F 6101                    		CMP #00H, R1
00000211 21rr                    		BNE L84
00000213                         L81:	; bb76
                                 ;     648     {
                                 ;     649         #ifdef FLASH_API_RX_CFG_DATA_FLASH_BGO
                                 ;     650         /* Disable FCU ready interrupt for 2 byte checks */
                                 ;     651         FLASH.FRDYIE.BIT.FRDYIE = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",651
00000213 FBEE02C47F              		MOV.L #007FC402H, R14
00000218 F1E810                  		BCLR #00H, 10H[R14].B
0000021B                         L82:	; bb76.split
                                 ;     652         #endif        
                                 ;     653         
                                 ;     654         /* Set data flash pointer to beginning of the memory block */
                                 ;     655         ptrb = (FCU_BYTE_PTR)(address & DF_MASK);   
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",655
0000021B A981                    		MOV.L 18H[R0], R1
0000021D 762100F8                		AND #0FFFFF800H, R1
00000221 A081                    		MOV.L R1, 08H[R0]
00000223                         L83:	; bb76.split2
                                 ;     656         
                                 ;     657         /* Check if the next 2 bytes are blank
                                 ;     658            Bits BCADR to the address of the 2-byte location to check. 
                                 ;     659            Set bit BCSIZE in EEPBCCNT to 0. */
                                 ;     660         FLASH.DFLBCCNT.WORD = (uint16_t)(address & (DF_BLOCK_SIZE_LARGE-2));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",660
00000223 A981                    		MOV.L 18H[R0], R1
00000225 7621FE07                		AND #07FEH, R1
00000229 FBEE02C47F              		MOV.L #007FC402H, R14
0000022E DBE1E41D                		MOV.W R1, 3BC8H[R14]
00000232 2Err                 B  		BRA L88
00000234                         L84:	; bb87
                                 ;     661     }
                                 ;     662 #endif 
                                 ;     663     /* Check entire data block */
                                 ;     664     else
                                 ;     665     {
                                 ;     666         /* Check to see if user sent in a data block number or the 
                                 ;     667            address.  The function description tells the user to send
                                 ;     668            in the block number but in some early examples the address
                                 ;     669            was used. To make this work with both versions we detect which
                                 ;     670            is sent in below and make it work either way. */
                                 ;     671         if( address < (DF_NUM_BLOCKS+BLOCK_DB0) )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",671
00000234 A981                    		MOV.L 18H[R0], R1
00000236 755155                  		CMP #55H, R1
00000239 24rr                    		BGTU L86
0000023B                         L85:	; bb88
                                 ;     672         {
                                 ;     673             /* A data block number was sent in */
                                 ;     674             ptrb = (FCU_BYTE_PTR)g_flash_BlockAddresses[address];
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",674
0000023B 6C21                    		SHLL #02H, R1
0000023D FBE2rrrrrrrr            		MOV.L #_g_flash_BlockAddresses, R14
00000243 4B1E                    		ADD R1, R14
00000245 E4E002                  		MOV.L [R14], 08H[R0]
00000248 08                   S  		BRA L87
00000249                         L86:	; bb93
                                 ;     675         }           
                                 ;     676         else
                                 ;     677         {
                                 ;     678             /* Any address in the erasure block */
                                 ;     679             ptrb = (FCU_BYTE_PTR)address;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",679
00000249 A081                    		MOV.L R1, 08H[R0]
0000024B                         L87:	; bb100
                                 ;     680         }
                                 ;     681         
                                 ;     682         /* Check if the entire block is blank
                                 ;     683            Set bit BCSIZE in EEPBCCNT to 1. */
                                 ;     684         FLASH.DFLBCCNT.BIT.BCSIZE = 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",684
0000024B FBEE02C47F              		MOV.L #007FC402H, R14
00000250 DEEFE41D                		MOV.W 3BC8H[R14], R15
00000254 78FF                    		BSET #0FH, R15
00000256 DBEFE41D                		MOV.W R15, 3BC8H[R14]
0000025A                         L88:	; bb109
                                 ;     685     }
                                 ;     686 
                                 ;     687     /* Send commands to FCU */
                                 ;     688     *ptrb = 0x71;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",688
0000025A A881                    		MOV.L 08H[R0], R1
0000025C F81471                  		MOV.B #71H, [R1]
0000025F                         L89:	; bb109.split
                                 ;     689     *ptrb = 0xD0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",689
0000025F A881                    		MOV.L 08H[R0], R1
00000261 F814D0                  		MOV.B #0D0H, [R1]
00000264                         L90:	; bb109.split3
                                 ;     690     
                                 ;     691 #ifdef FLASH_API_RX_CFG_DATA_FLASH_BGO
                                 ;     692     /* Only using BGO on block blank checks */
                                 ;     693     if( size == BLANK_CHECK_ENTIRE_BLOCK )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",693
00000264 B589                    		MOVU.B 17H[R0], R1
00000266 6111                    		CMP #01H, R1
00000268 21rr                    		BNE L93
0000026A                         L91:	; bb113
                                 ;     694     {
                                 ;     695         /* Set global address in case we have error and need to reset FCU. */
                                 ;     696         g_bgo_flash_addr = address;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",696
0000026A FBE2rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R14
00000270 E10E06                  		MOV.L 18H[R0], [R14]
00000273                         L92:	; bb113.split
                                 ;     697 
                                 ;     698         /* Return, check result later in ISR */
                                 ;     699         return FLASH_BLANK;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",699
00000273 3C0700                  		MOV.B #00H, 07H[R0]
00000276 2Err                 B  		BRA L110
00000278                         L93:	; bb121
                                 ;     700     }
                                 ;     701 #endif    
                                 ;     702 
                                 ;     703     /* Set timeout wait counter value */
                                 ;     704     wait_cnt = WAIT_MAX_BLANK_CHECK;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",704
00000278 F90E04601101            		MOV.L #00011160H, 10H[R0]
0000027E 2Err                 B  		BRA L98
00000280                         L94:	; bb122
                                 ;     705 
                                 ;     706     /* Wait until FCU operation finishes, or a timeout occurs */
                                 ;     707     while(FLASH.FSTATR0.BIT.FRDY == 0)
                                 ;     708     {
                                 ;     709         /* Decrement the wait counter */
                                 ;     710         wait_cnt--;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",710
00000280 A901                    		MOV.L 10H[R0], R1
00000282 6011                    		SUB #01H, R1
00000284 A101                    		MOV.L R1, 10H[R0]
00000286                         L95:	; bb122.split
                                 ;     711 
                                 ;     712         /* Check if the wait counter has reached zero */
                                 ;     713         if(wait_cnt == 0)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",713
00000286 A901                    		MOV.L 10H[R0], R1
00000288 6101                    		CMP #00H, R1
0000028A 18                   S  		BNE L98
0000028B                         L96:	; bb126
                                 ;     714         {    
                                 ;     715             /* Maximum timeout duration for writing to ROM has elapsed - 
                                 ;     716                assume operation failure and reset the FCU */
                                 ;     717             flash_reset();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",717
0000028B 39rrrr               W  		BSR __$flash_reset
0000028E                         L97:	; bb126.split
                                 ;     718 
                                 ;     719             /* Return FLASH_FAILURE, operation failure */
                                 ;     720             return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",720
0000028E 3C0706                  		MOV.B #06H, 07H[R0]
00000291 2Err                 B  		BRA L110
00000293                         L98:	; bb133
00000293 754E80                  		MOV.L #00000080H, R14
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",707
00000296 FBFE02C47F              		MOV.L #007FC402H, R15
0000029B 52FEAE3B                		AND 3BAEH[R15].UB, R14
0000029F 687E                    		SHLR #07H, R14
000002A1 610E                    		CMP #00H, R14
000002A3 20rr                    		BEQ L94
000002A5                         L99:	; bb140
                                 ;     721         }
                                 ;     722     }
                                 ;     723 
                                 ;     724     /* Reset the FRDMD bit back to 0 */
                                 ;     725     FLASH.FMODR.BIT.FRDMD = 0x00;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",725
000002A5 FBEE02C47F              		MOV.L #007FC402H, R14
000002AA F0EC                    		BCLR #04H, [R14].B
000002AC                         L100:	; bb140.split
                                 ;     726 
                                 ;     727     /* Check if the 'ILGERR' was set during the command */
                                 ;     728     if(FLASH.FSTATR0.BIT.ILGLERR == 1)  /* Check 'ILGERR' bit */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",728
000002AC FBEE02C47F              		MOV.L #007FC402H, R14
000002B1 5AEEAE3B                		MOVU.B 3BAEH[R14], R14
000002B5 686E                    		SHLR #06H, R14
000002B7 641E                    		AND #01H, R14
000002B9 611E                    		CMP #01H, R14
000002BB 21rr                    		BNE L104
000002BD                         L101:	; bb145
                                 ;     729     {
                                 ;     730         /* Take the FCU out of PE mode */
                                 ;     731         exit_pe_mode(address);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",731
000002BD A981                    		MOV.L 18H[R0], R1
000002BF 39rrrr               W  		BSR __$exit_pe_mode
000002C2                         L102:	; bb145.split
                                 ;     732         
                                 ;     733         /* Release state */
                                 ;     734         flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",734
000002C2 39rrrr               W  		BSR __$flash_release_state
000002C5                         L103:	; bb145.split4
                                 ;     735         
                                 ;     736         /* Return FLASH_FAILURE, operation failure */
                                 ;     737         return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",737
000002C5 3C0706                  		MOV.B #06H, 07H[R0]
000002C8 2Err                 B  		BRA L110
000002CA                         L104:	; bb155
                                 ;     738     }
                                 ;     739 
                                 ;     740     /* (Read the 'BCST' bit (bit 0) in the 'DFLBCSTAT' register
                                 ;     741        0=blank, 1=not blank */
                                 ;     742     result = (uint8_t)FLASH.DFLBCSTAT.BIT.BCST; 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",742
000002CA FBEE02C47F              		MOV.L #007FC402H, R14
000002CF 5EE1E61D                		MOVU.W 3BCCH[R14], R1
000002D3 6411                    		AND #01H, R1
000002D5 8389                    		MOV.B R1, 0FH[R0]
000002D7                         L105:	; bb155.split
                                 ;     743 
                                 ;     744     /* Take the FCU out of PE mode */
                                 ;     745     exit_pe_mode(address);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",745
000002D7 A981                    		MOV.L 18H[R0], R1
000002D9 39rrrr               W  		BSR __$exit_pe_mode
000002DC                         L106:	; bb155.split5
                                 ;     746     
                                 ;     747     /* Release state */
                                 ;     748     flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",748
000002DC 39rrrr               W  		BSR __$flash_release_state
000002DF                         L107:	; bb155.split6
                                 ;     749     
                                 ;     750     /* Return (Not Blank/Blank), operation successful */
                                 ;     751     if( result == 0 ) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",751
000002DF B389                    		MOVU.B 0FH[R0], R1
000002E1 6101                    		CMP #00H, R1
000002E3 18                   S  		BNE L109
000002E4                         L108:	; bb162
                                 ;     752         /* Block was blank */
                                 ;     753         return FLASH_BLANK;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",753
000002E4 3C0700                  		MOV.B #00H, 07H[R0]
000002E7 08                   S  		BRA L110
000002E8                         L109:	; bb164
                                 ;     754     }
                                 ;     755     else
                                 ;     756     {
                                 ;     757         /* Block was not blank */
                                 ;     758         return FLASH_NOT_BLANK;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",758
000002E8 3C0701                  		MOV.B #01H, 07H[R0]
000002EB                         L110:	; bb172
000002EB C5000716                		MOV.B 07H[R0], 16H[R0]
                                 ;     759     }    
                                 ;     760 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",760
000002EF B581                    		MOVU.B 16H[R0], R1
000002F1 6707                    		RTSD #1CH
000002F3                         _R_FlashDataAreaAccess:
                                 		.STACK	_R_FlashDataAreaAccess=12
                                 ;     761 /******************************************************************************
                                 ;     762 End of function  R_FlashDataAreaBlankCheck
                                 ;     763 ******************************************************************************/
                                 ;     764 
                                 ;     765 /******************************************************************************
                                 ;     766 * Function Name: R_FlashDataAreaAccess
                                 ;     767 * Description  : This function is used to allow read and program permissions 
                                 ;     768 *                to the Data Flash areas. 
                                 ;     769 *                NOTE1: This function does not have to execute from in RAM. It
                                 ;     770 *                       must be in RAM though if FLASH_API_RX_CFG_ROM_BGO is 
                                 ;     771 *                       enabled and this function is called during a ROM P/E 
                                 ;     772 *                       operation.
                                 ;     773 * Arguments    : read_en_mask - 
                                 ;     774 *                    Bitmasked value. Bits 0-3 represents each Data 
                                 ;     775 *                    Blocks 0-3 (respectively).
                                 ;     776 *                    '0'=no Read access. 
                                 ;     777 *                    '1'=Allows Read by CPU
                                 ;     778 *                write_en_mask - 
                                 ;     779 *                    Bitmasked value. Bits 0-3 represents each Data 
                                 ;     780 *                    Blocks 0-3 (respectively).
                                 ;     781 *                    '0'=no Erase/Write access. 
                                 ;     782 *                    '1'=Allows Erase/Write by FCU
                                 ;     783 * Return Value : none
                                 ;     784 ******************************************************************************/
                                 ;     785 void R_FlashDataAreaAccess (uint16_t read_en_mask, uint16_t write_en_mask)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",785
000002F3 6080                    		SUB #08H, R0
000002F5 9089                    		MOV.W R1, 06H[R0]
000002F7 9082                    		MOV.W R2, 04H[R0]
                                 ;     786 {
                                 ;     787     /* Used for making sure select bits are not set. */
                                 ;     788     uint16_t temp_mask = 0x00FF;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",788
000002F9 3D01FF                  		MOV.W #00FFH, 02H[R0]
000002FC                         L112:	; entry.split
                                 ;     789 
                                 ;     790 #if   defined(BSP_MCU_RX610)
                                 ;     791     
                                 ;     792     /* Set Read access for the Data Flash blocks */
                                 ;     793     FLASH.DFLRE.WORD = (uint16_t)(0x2D00 | (read_en_mask & 0x00FF));
                                 ;     794 
                                 ;     795     /* Set Erase/Program access for the Data Flash blocks */
                                 ;     796     FLASH.DFLWE.WORD = (uint16_t)(0x1E00 | (write_en_mask & 0x00FF));
                                 ;     797         
                                 ;     798 #else
                                 ;     799 
                                 ;     800     #if BSP_DATA_FLASH_SIZE_BYTES == 8192
                                 ;     801     /* Mask off bits 4-7 to make sure they are 0. */
                                 ;     802     temp_mask = 0x000F;
                                 ;     803     #endif
                                 ;     804 
                                 ;     805     /* Set Read access for the Data Flash blocks DB0-DB7 */
                                 ;     806     FLASH.DFLRE0.WORD = (uint16_t)(0x2D00 | (read_en_mask & temp_mask));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",806
000002FC B889                    		MOVU.W 06H[R0], R1
000002FE 06510101                		AND 02H[R0].W, R1
00000302 7631002D                		OR #2D00H, R1
00000306 FBEE40C47F              		MOV.L #007FC440H, R14
0000030B D3E1                    		MOV.W R1, [R14]
0000030D                         L113:	; entry.split1
                                 ;     807 
                                 ;     808     /* Set Erase/Program access for the Data Flash blocks DB0-DB7 */
                                 ;     809     FLASH.DFLWE0.WORD = (uint16_t)(0x1E00 |  (write_en_mask & temp_mask));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",809
0000030D B881                    		MOVU.W 04H[R0], R1
0000030F 06510101                		AND 02H[R0].W, R1
00000313 7631001E                		OR #1E00H, R1
00000317 FB2E40C47F              		MOV.L #007FC440H, R2
0000031C 9221                    		MOV.W R1, 10H[R2]
0000031E                         L114:	; entry.split2
                                 ;     810 
                                 ;     811     #if BSP_DATA_FLASH_SIZE_BYTES > 16384
                                 ;     812     /* Set Read access for the Data Flash blocks DB8-DB15 */
                                 ;     813     FLASH.DFLRE1.WORD = (uint16_t)(0xD200 | ((read_en_mask >> 8) & 0x00FF));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",813
0000031E B889                    		MOVU.W 06H[R0], R1
00000320 6881                    		SHLR #08H, R1
00000322 773100D200              		OR #0D200H, R1
00000327 FB2E40C47F              		MOV.L #007FC440H, R2
0000032C 9029                    		MOV.W R1, 02H[R2]
0000032E                         L115:	; entry.split3
                                 ;     814 
                                 ;     815     /* Set Erase/Program access for the Data Flash blocks DB8-DB15 */
                                 ;     816     FLASH.DFLWE1.WORD = (uint16_t)(0xE100 |  ((write_en_mask >> 8) & 0x00FF));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",816
0000032E B881                    		MOVU.W 04H[R0], R1
00000330 6881                    		SHLR #08H, R1
00000332 773100E100              		OR #0E100H, R1
00000337 FB2E40C47F              		MOV.L #007FC440H, R2
0000033C 9229                    		MOV.W R1, 12H[R2]
0000033E 6702                    		RTSD #08H
00000340                         _R_FlashGetStatus:
                                 		.STACK	_R_FlashGetStatus=8
                                 ;     817     #endif
                                 ;     818     
                                 ;     819 #endif
                                 ;     820 }
                                 ;     821 /******************************************************************************
                                 ;     822 End of function  R_FlashDataAreaAccess
                                 ;     823 ******************************************************************************/
                                 ;     824 
                                 ;     825 
                                 ;     826 /******************************************************************************
                                 ;     827 * Function Name: R_FlashGetStatus
                                 ;     828 * Description  : Returns the current state of the flash
                                 ;     829 *                NOTE1: This function does not have to execute from in RAM. It
                                 ;     830 *                       must be in RAM though if FLASH_API_RX_CFG_ROM_BGO is 
                                 ;     831 *                       enabled and this function is called during a ROM P/E
                                 ;     832 *                       operation.
                                 ;     833 * Arguments    : none
                                 ;     834 * Return Value : FLASH_SUCCESS -
                                 ;     835 *                    Flash is ready to use
                                 ;     836 *                FLASH_BUSY - 
                                 ;     837 *                    Flash is busy with another operation
                                 ;     838 ******************************************************************************/
                                 ;     839 uint8_t R_FlashGetStatus (void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",839
00000340 6040                    		SUB #04H, R0
                                 ;     840 {
                                 ;     841     /* Return flash status */
                                 ;     842     if( g_flash_state == FLASH_READY )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",842
00000342 FBE2rrrrrrrr            		MOV.L #__$g_flash_state, R14
00000348 ECEE                    		MOV.L [R14], R14
0000034A 610E                    		CMP #00H, R14
0000034C 18                   S  		BNE L118
0000034D                         L117:	; bb1
                                 ;     843     {
                                 ;     844         return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",844
0000034D 3C0200                  		MOV.B #00H, 02H[R0]
00000350 08                   S  		BRA L119
00000351                         L118:	; bb3
                                 ;     845     }
                                 ;     846     else
                                 ;     847     {
                                 ;     848         return FLASH_BUSY;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",848
00000351 3C0205                  		MOV.B #05H, 02H[R0]
00000354                         L119:	; bb9
00000354 C5000203                		MOV.B 02H[R0], 03H[R0]
                                 ;     849     }
                                 ;     850 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",850
00000358 B089                    		MOVU.B 03H[R0], R1
0000035A 6701                    		RTSD #04H
0000035C                         __$flash_grab_state:
                                 		.STACK	__$flash_grab_state=12
                                 ;     851 /******************************************************************************
                                 ;     852 End of function  R_FlashGetStatus
                                 ;     853 ******************************************************************************/
                                 ;     854 
                                 ;     855 
                                 ;     856 /******************************************************************************
                                 ;     857 * Function Name: flash_grab_state
                                 ;     858 * Description  : Attempt to grab the flash state to perform an operation
                                 ;     859 *                NOTE1: This function does not have to execute from in RAM. It
                                 ;     860 *                       must be in RAM though if FLASH_API_RX_CFG_ROM_BGO is 
                                 ;     861 *                       enabled and this function is called during a ROM P/E 
                                 ;     862 *                       operation.
                                 ;     863 * Arguments    : new_state -
                                 ;     864 *                    Which state to attempt to transition to
                                 ;     865 * Return Value : FLASH_SUCCESS - 
                                 ;     866 *                    State was grabbed
                                 ;     867 *                FLASH_BUSY - 
                                 ;     868 *                    Flash is busy with another operation
                                 ;     869 ******************************************************************************/
                                 ;     870 static uint8_t flash_grab_state (flash_states_t new_state)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",870
0000035C 6080                    		SUB #08H, R0
0000035E A009                    		MOV.L R1, 04H[R0]
00000360 754117                  		MOV.L #00000017H, R1
                                 ;     871 {   
                                 ;     872     /* Check to see if lock was successfully taken */
                                 ;     873     if (R_BSP_HardwareLock(BSP_LOCK_FLASH) == true)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",873
00000363 05rrrrrr             A  		BSR _R_BSP_HardwareLock
00000367 6111                    		CMP #01H, R1
00000369 21rr                    		BNE L123
0000036B                         L121:	; bb2
                                 ;     874     {
                                 ;     875         /* Lock taken, we can change state */
                                 ;     876         g_flash_state = new_state;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",876
0000036B FBE2rrrrrrrr            		MOV.L #__$g_flash_state, R14
00000371 E10E01                  		MOV.L 04H[R0], [R14]
00000374                         L122:	; bb2.split
                                 ;     877         
                                 ;     878         /* Return success */
                                 ;     879         return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",879
00000374 3C0200                  		MOV.B #00H, 02H[R0]
00000377 08                   S  		BRA L124
00000378                         L123:	; bb5
                                 ;     880     }
                                 ;     881     else
                                 ;     882     {
                                 ;     883         /* Another operation is on-going */
                                 ;     884         return FLASH_BUSY;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",884
00000378 3C0205                  		MOV.B #05H, 02H[R0]
0000037B                         L124:	; bb12
0000037B C5000203                		MOV.B 02H[R0], 03H[R0]
                                 ;     885     }
                                 ;     886 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",886
0000037F B089                    		MOVU.B 03H[R0], R1
00000381 6702                    		RTSD #08H
00000383                         __$flash_release_state:
                                 		.STACK	__$flash_release_state=4
                                 ;     887 /******************************************************************************
                                 ;     888 End of function  flash_grab_state
                                 ;     889 ******************************************************************************/
                                 ;     890 
                                 ;     891 /******************************************************************************
                                 ;     892 * Function Name: flash_release_state
                                 ;     893 * Description  : Release state so another flash operation can take place
                                 ;     894 *                NOTE1: This function does not have to execute from in RAM. It
                                 ;     895 *                       must be in RAM though if FLASH_API_RX_CFG_ROM_BGO is 
                                 ;     896 *                       enabled and this function is called during a ROM P/E 
                                 ;     897 *                       operation.
                                 ;     898 * Arguments    : none
                                 ;     899 * Return Value : none
                                 ;     900 ******************************************************************************/
                                 ;     901 static void flash_release_state (void)
                                 ;     902 {
                                 ;     903     /* Set current FCU mode to READ */
                                 ;     904     g_current_mode = READ_MODE;            
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",904
00000383 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000389 F8E400                  		MOV.B #00H, [R14]
0000038C                         L126:	; entry.split
                                 ;     905     
                                 ;     906     /* Done with programming */
                                 ;     907     g_flash_state = FLASH_READY; 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",907
0000038C FBE2rrrrrrrr            		MOV.L #__$g_flash_state, R14
00000392 F8E600                  		MOV.L #00000000H, [R14]
00000395                         L127:	; entry.split1
00000395 754117                  		MOV.L #00000017H, R1
                                 ;     908 
                                 ;     909     /* Release hold on lock */
                                 ;     910     R_BSP_HardwareUnlock(BSP_LOCK_FLASH);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",910
00000398 05rrrrrr             A  		BSR _R_BSP_HardwareUnlock
0000039C 02                      		RTS
0000039D                         _flash_ready_isr:
                                 		.STACK	_flash_ready_isr=52
                                 		.RVECTOR	23,_flash_ready_isr
                                 ;     911 }
                                 ;     912 /******************************************************************************
                                 ;     913 End of function  flash_release_state
                                 ;     914 ******************************************************************************/
                                 ;     915 
                                 ;     916 #ifndef  FLASH_API_RX_CFG_IGNORE_LOCK_BITS
                                 ;     917 /******************************************************************************
                                 ;     918 * Function Name: R_FlashSetLockBitProtection
                                 ;     919 * Description  : Enables or disables lock bit protection.
                                 ;     920 *                NOTE1: This function does not have to execute from in RAM. It
                                 ;     921 *                       must be in RAM though if FLASH_API_RX_CFG_ROM_BGO is 
                                 ;     922 *                       enabled and this function is called during a ROM P/E 
                                 ;     923 *                       operation.
                                 ;     924 * Arguments    : lock_bit - 
                                 ;     925 *                    Boolean, whether to enable or disable lock bit 
                                 ;     926 *                    protection (true = enabled, false = disabled)
                                 ;     927 * Return Value : FLASH_SUCCESS - 
                                 ;     928 *                    Operation Successful
                                 ;     929 *                FLASH_BUSY - 
                                 ;     930 *                    Another flash operation is in progress
                                 ;     931 ******************************************************************************/
                                 ;     932 uint8_t R_FlashSetLockBitProtection (uint32_t lock_bit)
                                 ;     933 {        
                                 ;     934     /* Attempt to grab state */;
                                 ;     935     if( flash_grab_state(FLASH_LOCK_BIT) != FLASH_SUCCESS )
                                 ;     936     {
                                 ;     937         /* Another operation is already in progress */
                                 ;     938         return FLASH_BUSY;
                                 ;     939     }    
                                 ;     940     
                                 ;     941     /* Enable or disable? */
                                 ;     942     g_lock_bit_protection = lock_bit;
                                 ;     943         
                                 ;     944     /* Release state */
                                 ;     945     flash_release_state();
                                 ;     946 
                                 ;     947     /* Return success */
                                 ;     948     return FLASH_SUCCESS;
                                 ;     949 }
                                 ;     950 /******************************************************************************
                                 ;     951 End of function  R_FlashSetLockBitProtection
                                 ;     952 ******************************************************************************/
                                 ;     953 #endif
                                 ;     954 
                                 ;     955 #if defined(FLASH_API_RX_CFG_DATA_FLASH_BGO) || defined(FLASH_API_RX_CFG_ROM_BGO)
                                 ;     956 /******************************************************************************
                                 ;     957 * Function Name: flash_ready_isr
                                 ;     958 * Description  : ISR that is called when FCU is done with flash operation
                                 ;     959 *                NOTE: This function MUST execute from RAM only when 
                                 ;     960 *                      FLASH_API_RX_CFG_ROM_BGO is enabled.
                                 ;     961 * Arguments    : none
                                 ;     962 * Return Value : none
                                 ;     963 ******************************************************************************/
                                 ;     964 #pragma interrupt flash_ready_isr(vect=VECT(FCU, FRDYI))
                                 ;     965 void flash_ready_isr (void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",965
0000039D 6EEF                    		PUSHM R14-R15
0000039F 6E15                    		PUSHM R1-R5
000003A1 7100F0                  		ADD #0FFFFFFF0H, R0
                                 ;     966 {
                                 ;     967     /* Local variables */    
                                 ;     968     uint32_t num_byte_to_write;
                                 ;     969     uint8_t  ret;
                                 ;     970 #ifdef FLASH_API_RX_CFG_FLASH_TO_FLASH
                                 ;     971     uint32_t i;
                                 ;     972 #endif       
                                 ;     973     
                                 ;     974     /* Check for any errors */
                                 ;     975     if( (FLASH.FSTATR0.BIT.ILGLERR == 1) || 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",975
000003A4 FB1E02C47F              		MOV.L #007FC402H, R1
000003A9 5A11AE3B                		MOVU.B 3BAEH[R1], R1
000003AD 6861                    		SHLR #06H, R1
000003AF 6411                    		AND #01H, R1
000003B1 6111                    		CMP #01H, R1
000003B3 20rr                    		BEQ L134
000003B5 2Err                 B  		BRA L133
000003B7                         L129:	; bb4
                                 ;     976         (FLASH.FSTATR0.BIT.ERSERR  == 1) ||
                                 ;     977         (FLASH.FSTATR0.BIT.PRGERR == 1) )
                                 ;     978     {
                                 ;     979         /* Leave Program/Erase Mode and clear any error flags */
                                 ;     980         exit_pe_mode(g_bgo_flash_addr);         
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",980
000003B7 FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
000003BD EC11                    		MOV.L [R1], R1
000003BF 39rrrr               W  		BSR __$exit_pe_mode
000003C2                         L130:	; bb4.split
                                 ;     981         
                                 ;     982         /* Release flash state */
                                 ;     983         flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",983
000003C2 39rrrr               W  		BSR __$flash_release_state
000003C5                         L131:	; bb4.split1
                                 ;     984     
                                 ;     985         /* Operation failure, use callback function to alert user */
                                 ;     986         FlashError();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",986
000003C5 05rrrrrr             A  		BSR _FlashError
000003C9                         L132:	; bb4.split2
                                 ;     987         
                                 ;     988         /* Exit ISR */
                                 ;     989         return;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",989
000003C9 710010                  		ADD #10H, R0
000003CC 6F15                    		POPM R1-R5
000003CE 6FEF                    		POPM R14-R15
000003D0 7F95                    		RTE
000003D2                         L133:	; bb12
000003D2 FB1E02C47F              		MOV.L #007FC402H, R1
000003D7 5A11AE3B                		MOVU.B 3BAEH[R1], R1
000003DB 6851                    		SHLR #05H, R1
000003DD 6411                    		AND #01H, R1
000003DF 6111                    		CMP #01H, R1
000003E1 18                   S  		BNE L135
000003E2                         L134:	; bb19
000003E2 F80601                  		MOV.L #00000001H, [R0]
000003E5 08                   S  		BRA L136
000003E6                         L135:	; bb20
000003E6 F80600                  		MOV.L #00000000H, [R0]
000003E9                         L136:	; bb21
000003E9 EC01                    		MOV.L [R0], R1
000003EB 6101                    		CMP #00H, R1
000003ED 21rr                    		BNE L138
000003EF                         L137:	; bb24
000003EF FB1E02C47F              		MOV.L #007FC402H, R1
000003F4 5A11AE3B                		MOVU.B 3BAEH[R1], R1
000003F8 6841                    		SHLR #04H, R1
000003FA 6411                    		AND #01H, R1
000003FC 6111                    		CMP #01H, R1
000003FE 18                   S  		BNE L139
000003FF                         L138:	; bb31
000003FF F80601                  		MOV.L #00000001H, [R0]
00000402 08                   S  		BRA L140
00000403                         L139:	; bb32
00000403 F80600                  		MOV.L #00000000H, [R0]
00000406                         L140:	; bb33
00000406 EC01                    		MOV.L [R0], R1
00000408 6101                    		CMP #00H, R1
0000040A 21rr                    		BNE L129
0000040C                         L141:	; bb39
                                 ;     990     }
                                 ;     991     
                                 ;     992     /* Check state and see if anything else needs to be done */
                                 ;     993     if( g_flash_state == FLASH_ERASING )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",993
0000040C FB12rrrrrrrr            		MOV.L #__$g_flash_state, R1
00000412 EC11                    		MOV.L [R1], R1
00000414 6111                    		CMP #01H, R1
00000416 21rr                    		BNE L151
00000418                         L142:	; bb41
                                 ;     994     {
                                 ;     995         /* Erase is done */ 
                                 ;     996 #if defined(DF_GROUPED_BLOCKS)
                                 ;     997         /* If we are erasing data flash then we need to see if all requested
                                 ;     998            blocks are erased. */
                                 ;     999         if( FLD_PE_MODE == g_current_mode )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",999
00000418 FB12rrrrrrrr            		MOV.L #__$g_current_mode, R1
0000041E 5811                    		MOVU.B [R1], R1
00000420 6121                    		CMP #02H, R1
00000422 21rr                    		BNE L148
00000424                         L143:	; bb43
                                 ;    1000         {
                                 ;    1001             /* Check to see if there are more bytes to erase. */
                                 ;    1002             if( 0 < g_bgo_bytes ) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1002
00000424 FB12rrrrrrrr            		MOV.L #__$g_bgo_bytes, R1
0000042A EC11                    		MOV.L [R1], R1
0000042C 6101                    		CMP #00H, R1
0000042E 20rr                    		BEQ L148
00000430                         L144:	; bb44
                                 ;    1003                 
                                 ;    1004                 /* Send FCU command to erase block */
                                 ;    1005                 ret = flash_erase_command((FCU_BYTE_PTR)g_bgo_flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1005
00000430 FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
00000436 EC11                    		MOV.L [R1], R1
00000438 39rrrr               W  		BSR __$flash_erase_command
0000043B 8289                    		MOV.B R1, 0BH[R0]
0000043D                         L145:	; bb44.split
                                 ;    1006 
                                 ;    1007                 /* Advance pointer to next block */
                                 ;    1008                 g_bgo_flash_addr += DF_ERASE_BLOCK_SIZE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1008
0000043D FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
00000443 EC12                    		MOV.L [R1], R2
00000445 712220                  		ADD #20H, R2
00000448 E312                    		MOV.L R2, [R1]
0000044A                         L146:	; bb44.split3
                                 ;    1009 
                                 ;    1010                 /* Subtract off bytes erased */
                                 ;    1011                 g_bgo_bytes -= DF_ERASE_BLOCK_SIZE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1011
0000044A FB12rrrrrrrr            		MOV.L #__$g_bgo_bytes, R1
00000450 EC12                    		MOV.L [R1], R2
00000452 7122E0                  		ADD #0FFFFFFE0H, R2
00000455 E312                    		MOV.L R2, [R1]
00000457                         L147:	; bb44.split4
                                 ;    1012 
                                 ;    1013                 /* Only continue if last command was successful */                
                                 ;    1014                 if( ret == FLASH_SUCCESS )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1014
00000457 B289                    		MOVU.B 0BH[R0], R1
00000459 6101                    		CMP #00H, R1
0000045B 3Arrrr               W  		BEQ L191
0000045E                         L148:	; bb71
                                 ;    1015                 {
                                 ;    1016                     /* Exit ISR */
                                 ;    1017                     return;
                                 ;    1018                 }
                                 ;    1019             }
                                 ;    1020         }
                                 ;    1021 #endif
                                 ;    1022 
                                 ;    1023         /* Leave Program/Erase Mode */
                                 ;    1024         exit_pe_mode(g_bgo_flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1024
0000045E FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
00000464 EC11                    		MOV.L [R1], R1
00000466 39rrrr               W  		BSR __$exit_pe_mode
00000469                         L149:	; bb71.split
                                 ;    1025 
                                 ;    1026         /* Release flash state */
                                 ;    1027         flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1027
00000469 39rrrr               W  		BSR __$flash_release_state
0000046C                         L150:	; bb71.split5
                                 ;    1028         
                                 ;    1029         /* Flash operation finished callback function */
                                 ;    1030         FlashEraseDone(); 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1030
0000046C 05rrrrrr             A  		BSR _FlashEraseDone
00000470 710010                  		ADD #10H, R0
00000473 6F15                    		POPM R1-R5
00000475 6FEF                    		POPM R14-R15
00000477 7F95                    		RTE
00000479                         L151:	; bb74
                                 ;    1031     }
                                 ;    1032 #ifdef FLASH_API_RX_CFG_DATA_FLASH_BGO
                                 ;    1033     else if( g_flash_state == FLASH_BLANKCHECK )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1033
00000479 FB12rrrrrrrr            		MOV.L #__$g_flash_state, R1
0000047F EC11                    		MOV.L [R1], R1
00000481 6131                    		CMP #03H, R1
00000483 21rr                    		BNE L159
00000485                         L152:	; bb75
                                 ;    1034     {
                                 ;    1035         /* Blank check finished, check result */
                                 ;    1036         
                                 ;    1037         /* Reset the FRDMD bit back to 0 */
                                 ;    1038         FLASH.FMODR.BIT.FRDMD = 0x00;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1038
00000485 FB1E02C47F              		MOV.L #007FC402H, R1
0000048A F01C                    		BCLR #04H, [R1].B
0000048C                         L153:	; bb75.split
                                 ;    1039 
                                 ;    1040         /* (Read the 'BCST' bit (bit 0) in the 'DFLBCSTAT' register
                                 ;    1041            0=blank, 1=not blank */
                                 ;    1042         ret = FLASH.DFLBCSTAT.BIT.BCST; 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1042
0000048C FB1E02C47F              		MOV.L #007FC402H, R1
00000491 5E11E61D                		MOVU.W 3BCCH[R1], R1
00000495 6411                    		AND #01H, R1
00000497 8289                    		MOV.B R1, 0BH[R0]
00000499                         L154:	; bb75.split6
                                 ;    1043 
                                 ;    1044         /* Take the FCU out of PE mode */
                                 ;    1045         exit_pe_mode(g_bgo_flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1045
00000499 FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
0000049F EC11                    		MOV.L [R1], R1
000004A1 39rrrr               W  		BSR __$exit_pe_mode
000004A4                         L155:	; bb75.split7
                                 ;    1046     
                                 ;    1047         /* Release flash state */
                                 ;    1048         flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1048
000004A4 39rrrr               W  		BSR __$flash_release_state
000004A7                         L156:	; bb75.split8
                                 ;    1049         
                                 ;    1050         /* Return result, 0 means blank, 1 means not blank */
                                 ;    1051         if(ret == 0) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1051
000004A7 B289                    		MOVU.B 0BH[R0], R1
000004A9 6101                    		CMP #00H, R1
000004AB 21rr                    		BNE L158
000004AD                         L157:	; bb85
000004AD 6601                    		MOV.L #00000000H, R1
                                 ;    1052             FlashBlankCheckDone(FLASH_BLANK);        
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1052
000004AF 05rrrrrr             A  		BSR _FlashBlankCheckDone
000004B3 710010                  		ADD #10H, R0
000004B6 6F15                    		POPM R1-R5
000004B8 6FEF                    		POPM R14-R15
000004BA 7F95                    		RTE
000004BC                         L158:	; bb86
000004BC 6611                    		MOV.L #00000001H, R1
                                 ;    1053         }
                                 ;    1054         else
                                 ;    1055         {
                                 ;    1056             FlashBlankCheckDone(FLASH_NOT_BLANK);        
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1056
000004BE 05rrrrrr             A  		BSR _FlashBlankCheckDone
000004C2 710010                  		ADD #10H, R0
000004C5 6F15                    		POPM R1-R5
000004C7 6FEF                    		POPM R14-R15
000004C9 7F95                    		RTE
000004CB                         L159:	; bb95
                                 ;    1057         }
                                 ;    1058     }
                                 ;    1059 #endif
                                 ;    1060     else if( g_flash_state == FLASH_WRITING )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1060
000004CB FB12rrrrrrrr            		MOV.L #__$g_flash_state, R1
000004D1 EC11                    		MOV.L [R1], R1
000004D3 6121                    		CMP #02H, R1
000004D5 3Brrrr               W  		BNE L190
000004D8                         L160:	; bb97
                                 ;    1061     {        
                                 ;    1062         /* Iterate while there are still bytes remaining to write */
                                 ;    1063         if( g_bgo_bytes > 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1063
000004D8 FB12rrrrrrrr            		MOV.L #__$g_bgo_bytes, R1
000004DE EC11                    		MOV.L [R1], R1
000004E0 6101                    		CMP #00H, R1
000004E2 3Arrrr               W  		BEQ L187
000004E5                         L161:	; bb98
                                 ;    1064         {
                                 ;    1065             /* Get maximum programming size that can currently be used. */
                                 ;    1066             num_byte_to_write = flash_get_program_size(g_bgo_bytes, g_bgo_flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1066
000004E5 FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
000004EB EC12                    		MOV.L [R1], R2
000004ED FB12rrrrrrrr            		MOV.L #__$g_bgo_bytes, R1
000004F3 EC11                    		MOV.L [R1], R1
000004F5 39rrrr               W  		BSR __$flash_get_program_size
000004F8 A009                    		MOV.L R1, 04H[R0]
000004FA                         L162:	; bb98.split
                                 ;    1067 
                                 ;    1068 #ifdef FLASH_API_RX_CFG_FLASH_TO_FLASH
                                 ;    1069             /* Check to see if we need to buffer more data */
                                 ;    1070             if( g_flash_to_flash_op == 1 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1070
000004FA FB12rrrrrrrr            		MOV.L #__$g_flash_to_flash_op, R1
00000500 5811                    		MOVU.B [R1], R1
00000502 6111                    		CMP #01H, R1
00000504 21rr                    		BNE L172
00000506                         L163:	; bb103
                                 ;    1071             {
                                 ;    1072                 /* We must leave PE mode to transfer next buffer to RAM */
                                 ;    1073                 exit_pe_mode(g_bgo_flash_addr);                
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1073
00000506 FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
0000050C EC11                    		MOV.L [R1], R1
0000050E 39rrrr               W  		BSR __$exit_pe_mode
00000511                         L164:	; bb103.split
                                 ;    1074                 
                                 ;    1075                 /* Copy over next bytes to write */
                                 ;    1076                 for(i = 0; i < num_byte_to_write; i++)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1076
00000511 3E0300                  		MOV.L #00000000H, 0CH[R0]
00000514 2Err                 B  		BRA L166
00000516                         L165:	; bb105
                                 ;    1077                 {
                                 ;    1078                     /* Copy over each byte */
                                 ;    1079                     g_temp_array[i] = *((uint8_t *)(g_bgo_buffer_addr+i));             
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1079
00000516 FB12rrrrrrrr            		MOV.L #__$g_bgo_buffer_addr, R1
0000051C EC11                    		MOV.L [R1], R1
0000051E A88A                    		MOV.L 0CH[R0], R2
00000520 FEC121                  		MOVU.B [R1,R2], R1
00000523 FB32rrrrrrrr            		MOV.L #__$g_temp_array, R3
00000529 FE0321                  		MOV.B R1, [R3,R2]
0000052C A889                    		MOV.L 0CH[R0], R1
0000052E 6211                    		ADD #01H, R1
00000530 A089                    		MOV.L R1, 0CH[R0]
00000532                         L166:	; bb115
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1076
00000532 A889                    		MOV.L 0CH[R0], R1
00000534 06850101                		CMP 04H[R0].L, R1
00000538 23rr                    		BLTU L165
0000053A                         L167:	; bb122
                                 ;    1080                 }
                                 ;    1081 
                                 ;    1082                 /* Re-enter PE mode, check if operation is successful */
                                 ;    1083                 if( enter_pe_mode(g_bgo_flash_addr) != FLASH_SUCCESS)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1083
0000053A FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
00000540 EC11                    		MOV.L [R1], R1
00000542 39rrrr               W  		BSR __$enter_pe_mode
00000545 6101                    		CMP #00H, R1
00000547 20rr                    		BEQ L172
00000549                         L168:	; bb123
                                 ;    1084                 {
                                 ;    1085                     /* Leave Program/Erase Mode and clear any error flags */
                                 ;    1086                     exit_pe_mode(g_bgo_flash_addr);         
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1086
00000549 FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
0000054F EC11                    		MOV.L [R1], R1
00000551 39rrrr               W  		BSR __$exit_pe_mode
00000554                         L169:	; bb123.split
                                 ;    1087         
                                 ;    1088                     /* Release flash state */
                                 ;    1089                     flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1089
00000554 39rrrr               W  		BSR __$flash_release_state
00000557                         L170:	; bb123.split9
                                 ;    1090     
                                 ;    1091                     /* Operation failure, use callback function to alert user */
                                 ;    1092                     FlashError();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1092
00000557 05rrrrrr             A  		BSR _FlashError
0000055B                         L171:	; bb123.split10
                                 ;    1093         
                                 ;    1094                     /* Exit ISR */
                                 ;    1095                     return;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1095
0000055B 710010                  		ADD #10H, R0
0000055E 6F15                    		POPM R1-R5
00000560 6FEF                    		POPM R14-R15
00000562 7F95                    		RTE
00000564                         L172:	; bb139
                                 ;    1096                 }                
                                 ;    1097             }
                                 ;    1098 #endif                          
                                 ;    1099 
                                 ;    1100             /* Are we writing DF or ROM? */
                                 ;    1101             if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1101
00000564 FB12rrrrrrrr            		MOV.L #__$g_flash_to_flash_op, R1
0000056A 5811                    		MOVU.B [R1], R1
0000056C 6111                    		CMP #01H, R1
0000056E FCDB20                  		SCEQ.L R2
00000571 FB12rrrrrrrr            		MOV.L #__$g_current_mode, R1
00000577 5811                    		MOVU.B [R1], R1
00000579 6121                    		CMP #02H, R1
0000057B FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
00000581 EC11                    		MOV.L [R1], R1
00000583 21rr                    		BNE L176
00000585                         L173:	; bb141
                                 ;    1102             {
                                 ;    1103                 /* Writing DF */
                                 ;    1104                 /* Call the Programming function again for next bytes */
                                 ;    1105 #ifdef FLASH_API_RX_CFG_FLASH_TO_FLASH           
                                 ;    1106                 if( g_flash_to_flash_op == 1 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1106
00000585 5B22                    		MOVU.B R2, R2
00000587 6102                    		CMP #00H, R2
00000589 20rr                    		BEQ L175
0000058B                         L174:	; bb142
                                 ;    1107                 {
                                 ;    1108                     ret = data_flash_write( g_bgo_flash_addr,
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1108
0000058B A80B                    		MOV.L 04H[R0], R3
0000058D FB22rrrrrrrr            		MOV.L #__$g_temp_array, R2
00000593 39rrrr               W  		BSR __$data_flash_write
00000596 8289                    		MOV.B R1, 0BH[R0]
00000598 2Err                 B  		BRA L179
0000059A                         L175:	; bb146
                                 ;    1109                                             (uint32_t)&g_temp_array[0],
                                 ;    1110                                             num_byte_to_write);                
                                 ;    1111                 }
                                 ;    1112                 else
                                 ;    1113                 {
                                 ;    1114                     ret = data_flash_write( g_bgo_flash_addr, 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1114
0000059A FB22rrrrrrrr            		MOV.L #__$g_bgo_buffer_addr, R2
000005A0 EC22                    		MOV.L [R2], R2
000005A2 A80B                    		MOV.L 04H[R0], R3
000005A4 39rrrr               W  		BSR __$data_flash_write
000005A7 8289                    		MOV.B R1, 0BH[R0]
000005A9 2Err                 B  		BRA L179
000005AB                         L176:	; bb158
                                 ;    1115                                             g_bgo_buffer_addr,
                                 ;    1116                                             num_byte_to_write);                
                                 ;    1117                 }
                                 ;    1118 #else                           
                                 ;    1119                 ret = data_flash_write( g_bgo_flash_addr, 
                                 ;    1120                                         g_bgo_buffer_addr,
                                 ;    1121                                         num_byte_to_write);
                                 ;    1122 #endif     
                                 ;    1123             }                 
                                 ;    1124             else
                                 ;    1125             {
                                 ;    1126                 /* Writing ROM */
                                 ;    1127                 /* Call the Programming function */
                                 ;    1128 #ifdef FLASH_API_RX_CFG_FLASH_TO_FLASH           
                                 ;    1129                 if( g_flash_to_flash_op == 1 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1129
000005AB 5B22                    		MOVU.B R2, R2
000005AD 6102                    		CMP #00H, R2
000005AF 20rr                    		BEQ L178
000005B1                         L177:	; bb159
                                 ;    1130                 {
                                 ;    1131                     /* Use RAM array */
                                 ;    1132                     ret = rom_write(g_bgo_flash_addr, 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1132
000005B1 A80B                    		MOV.L 04H[R0], R3
000005B3 FB22rrrrrrrr            		MOV.L #__$g_temp_array, R2
000005B9 39rrrr               W  		BSR __$rom_write
000005BC 8289                    		MOV.B R1, 0BH[R0]
000005BE 2Err                 B  		BRA L179
000005C0                         L178:	; bb163
                                 ;    1133                                     (uint32_t)&g_temp_array[0],
                                 ;    1134                                     num_byte_to_write);
                                 ;    1135                 }
                                 ;    1136                 else
                                 ;    1137                 {          
                                 ;    1138                     /* Go as usual */
                                 ;    1139                     ret = rom_write(g_bgo_flash_addr, 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1139
000005C0 FB22rrrrrrrr            		MOV.L #__$g_bgo_buffer_addr, R2
000005C6 EC22                    		MOV.L [R2], R2
000005C8 A80B                    		MOV.L 04H[R0], R3
000005CA 39rrrr               W  		BSR __$rom_write
000005CD 8289                    		MOV.B R1, 0BH[R0]
000005CF                         L179:	; bb180
                                 ;    1140                                     g_bgo_buffer_addr,
                                 ;    1141                                     num_byte_to_write);
                                 ;    1142                 }
                                 ;    1143 #else            
                                 ;    1144                 ret = rom_write(g_bgo_flash_addr, 
                                 ;    1145                                 g_bgo_buffer_addr,
                                 ;    1146                                 num_byte_to_write);
                                 ;    1147 #endif                
                                 ;    1148             }                 
                                 ;    1149 
                                 ;    1150             /* Check the result for errors */
                                 ;    1151             if( ret != FLASH_SUCCESS )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1151
000005CF B289                    		MOVU.B 0BH[R0], R1
000005D1 6101                    		CMP #00H, R1
000005D3 20rr                    		BEQ L184
000005D5                         L180:	; bb181
                                 ;    1152             {
                                 ;    1153                 /* Error detected during programming, stop and return */
                                 ;    1154                 /* Leave Program/Erase Mode and clear any error flags */
                                 ;    1155                 exit_pe_mode(g_bgo_flash_addr);         
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1155
000005D5 FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
000005DB EC11                    		MOV.L [R1], R1
000005DD 39rrrr               W  		BSR __$exit_pe_mode
000005E0                         L181:	; bb181.split
                                 ;    1156         
                                 ;    1157                 /* Release flash state */
                                 ;    1158                 flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1158
000005E0 39rrrr               W  		BSR __$flash_release_state
000005E3                         L182:	; bb181.split11
                                 ;    1159     
                                 ;    1160                 /* Operation failure, use callback function to alert user */
                                 ;    1161                 FlashError();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1161
000005E3 05rrrrrr             A  		BSR _FlashError
000005E7                         L183:	; bb181.split12
                                 ;    1162         
                                 ;    1163                 /* Exit ISR */
                                 ;    1164                 return;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1164
000005E7 710010                  		ADD #10H, R0
000005EA 6F15                    		POPM R1-R5
000005EC 6FEF                    		POPM R14-R15
000005EE 7F95                    		RTE
000005F0                         L184:	; bb189
                                 ;    1165             }
                                 ;    1166 
                                 ;    1167             /* Increment the flash address and the buffer address by the size
                                 ;    1168                of the transfer thats just completed */
                                 ;    1169             g_bgo_flash_addr += num_byte_to_write;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1169
000005F0 FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
000005F6 EC12                    		MOV.L [R1], R2
000005F8 06890201                		ADD 04H[R0].L, R2
000005FC E312                    		MOV.L R2, [R1]
000005FE                         L185:	; bb189.split
                                 ;    1170             g_bgo_buffer_addr += num_byte_to_write;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1170
000005FE FB12rrrrrrrr            		MOV.L #__$g_bgo_buffer_addr, R1
00000604 EC12                    		MOV.L [R1], R2
00000606 06890201                		ADD 04H[R0].L, R2
0000060A E312                    		MOV.L R2, [R1]
0000060C                         L186:	; bb189.split13
                                 ;    1171             
                                 ;    1172             /* Decrement the number of bytes remaining by the size of the last
                                 ;    1173                flash write */
                                 ;    1174             g_bgo_bytes -= num_byte_to_write;  
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1174
0000060C FB12rrrrrrrr            		MOV.L #__$g_bgo_bytes, R1
00000612 EC12                    		MOV.L [R1], R2
00000614 06810201                		SUB 04H[R0].L, R2
00000618 E312                    		MOV.L R2, [R1]
0000061A 710010                  		ADD #10H, R0
0000061D 6F15                    		POPM R1-R5
0000061F 6FEF                    		POPM R14-R15
00000621 7F95                    		RTE
00000623                         L187:	; bb199
                                 ;    1175                                   
                                 ;    1176         }
                                 ;    1177         else
                                 ;    1178         {
                                 ;    1179             /* Leave Program/Erase Mode */
                                 ;    1180             exit_pe_mode(g_bgo_flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1180
00000623 FB12rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R1
00000629 EC11                    		MOV.L [R1], R1
0000062B 39rrrr               W  		BSR __$exit_pe_mode
0000062E                         L188:	; bb199.split
                                 ;    1181 
                                 ;    1182             /* Release flash state */
                                 ;    1183             flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1183
0000062E 39rrrr               W  		BSR __$flash_release_state
00000631                         L189:	; bb199.split14
                                 ;    1184             
                                 ;    1185             /* Flash operation finished callback function */
                                 ;    1186             FlashWriteDone(); 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1186
00000631 05rrrrrr             A  		BSR _FlashWriteDone
00000635 710010                  		ADD #10H, R0
00000638 6F15                    		POPM R1-R5
0000063A 6FEF                    		POPM R14-R15
0000063C 7F95                    		RTE
0000063E                         L190:	; bb208
                                 ;    1187         }
                                 ;    1188         
                                 ;    1189     }
                                 ;    1190     else
                                 ;    1191     {
                                 ;    1192         /* Error, should never get here */
                                 ;    1193         while(1);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1193
0000063E 2Err                 B  		BRA L190
00000640                         L191:	; return
                                 ;    1194     }
                                 ;    1195 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1195
00000640 710010                  		ADD #10H, R0
00000643 6F15                    		POPM R1-R5
00000645 6FEF                    		POPM R14-R15
00000647 7F95                    		RTE
00000649                         __$rom_write:
                                 		.STACK	__$rom_write=20
                                 ;    1196 /******************************************************************************
                                 ;    1197 End of function  flash_ready_isr
                                 ;    1198 ******************************************************************************/
                                 ;    1199 
                                 ;    1200 #endif
                                 ;    1201 
                                 ;    1202 #ifdef FLASH_API_RX_CFG_ENABLE_ROM_PROGRAMMING
                                 ;    1203 #pragma section FRAM
                                 ;    1204 #endif
                                 ;    1205 
                                 ;    1206 /******************************************************************************
                                 ;    1207 * Function Name: rom_write
                                 ;    1208 * Description  : Write bytes to ROM Area Flash.
                                 ;    1209 *                NOTE: This function MUST execute from in RAM.
                                 ;    1210 * Arguments    : address - 
                                 ;    1211 *                    ROM address of where to write to
                                 ;    1212 *                data - 
                                 ;    1213 *                    Pointer to the data to write
                                 ;    1214 *                size - 
                                 ;    1215 *                    The size of the data to write. Must be set to 
                                 ;    1216 *                    either a supported write size of the MCU.
                                 ;    1217 * Return Value : FLASH_SUCCESS - 
                                 ;    1218 *                    Operation Successful
                                 ;    1219 *                FLASH_FAILURE - 
                                 ;    1220 *                    Operation Failed
                                 ;    1221 ******************************************************************************/
                                 ;    1222 static uint8_t rom_write (uint32_t address, uint32_t data, uint32_t size)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1222
00000649 7100F0                  		ADD #0FFFFFFF0H, R0
0000064C A089                    		MOV.L R1, 0CH[R0]
0000064E A082                    		MOV.L R2, 08H[R0]
00000650 A00B                    		MOV.L R3, 04H[R0]
                                 ;    1223 {
                                 ;    1224 /* If ROM programming is not enabled then do not compile this code as it is
                                 ;    1225    not needed. */
                                 ;    1226 #ifdef FLASH_API_RX_CFG_ENABLE_ROM_PROGRAMMING
                                 ;    1227 
                                 ;    1228     /* Declare iteration loop count variable */
                                 ;    1229     volatile uint32_t i;  
                                 ;    1230     /* Declare wait counter variable */
                                 ;    1231     volatile int32_t  wait_cnt;
                                 ;    1232 
                                 ;    1233     /* Writes are done 16-bit at a time, scale 'size' argument */
                                 ;    1234     size = size >> 1;
                                 ;    1235 
                                 ;    1236     /* Write the FCU Program command */
                                 ;    1237     *(FCU_BYTE_PTR)address = 0xE8;  
                                 ;    1238     *(FCU_BYTE_PTR)address = size;    
                                 ;    1239 
                                 ;    1240     /* Write 'size' bytes into flash, 16-bits at a time */
                                 ;    1241     for(i = 0; i < size; i++)
                                 ;    1242     {
                                 ;    1243         /* Copy data from source address to destination ROM */
                                 ;    1244         *(FCU_WORD_PTR)address = *(uint16_t *)data;
                                 ;    1245         
                                 ;    1246         /* Increment destination address by 2 bytes */
                                 ;    1247         data += 2;
                                 ;    1248     }
                                 ;    1249 
                                 ;    1250     /* Write the final FCU command for programming */
                                 ;    1251     *(FCU_BYTE_PTR)address = 0xD0;
                                 ;    1252 
                                 ;    1253     #ifdef FLASH_API_RX_CFG_ROM_BGO            
                                 ;    1254     /* Return, rest of programming will be done in interrupt */
                                 ;    1255     return FLASH_SUCCESS;
                                 ;    1256     #endif
                                 ;    1257 
                                 ;    1258     /* Set timeout wait counter value */
                                 ;    1259     wait_cnt = WAIT_MAX_ROM_WRITE;
                                 ;    1260 
                                 ;    1261     /* Wait until FCU operation finishes, or a timeout occurs */
                                 ;    1262     while(FLASH.FSTATR0.BIT.FRDY == 0)
                                 ;    1263     {
                                 ;    1264         /* Decrement the wait counter */
                                 ;    1265         wait_cnt--;
                                 ;    1266 
                                 ;    1267         /* Check if the wait counter has reached zero */
                                 ;    1268         if(wait_cnt == 0)
                                 ;    1269         {    
                                 ;    1270             /* Maximum timeout duration for writing to ROM has elapsed - 
                                 ;    1271                assume operation failure and reset the FCU */
                                 ;    1272             flash_reset();
                                 ;    1273 
                                 ;    1274             /* Return FLASH_FAILURE, operation failure */
                                 ;    1275             return FLASH_FAILURE;
                                 ;    1276         }
                                 ;    1277     }
                                 ;    1278 
                                 ;    1279     /* Check for illegal command or programming errors */
                                 ;    1280     if((FLASH.FSTATR0.BIT.ILGLERR == 1) || (FLASH.FSTATR0.BIT.PRGERR  == 1)) 
                                 ;    1281     {        
                                 ;    1282         /* Return FLASH_FAILURE, operation failure */
                                 ;    1283         return FLASH_FAILURE;
                                 ;    1284     }                
                                 ;    1285 
                                 ;    1286 #endif /* FLASH_API_RX_CFG_ENABLE_ROM_PROGRAMMING */
                                 ;    1287 
                                 ;    1288     /* If ROM programming is not enabled then this function will always just
                                 ;    1289        return FLASH_SUCCESS. This is okay because this function will never
                                 ;    1290        actually be called. The API write function will return an error when
                                 ;    1291        a ROM address is entered for programming. */
                                 ;    1292     
                                 ;    1293     /* Return FLASH_SUCCESS, operation successful */
                                 ;    1294     return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1294
00000652 3C0300                  		MOV.B #00H, 03H[R0]
00000655 B089                    		MOVU.B 03H[R0], R1
00000657                         L193:	; entry.split
                                 ;    1295 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1295
00000657 5B11                    		MOVU.B R1, R1
00000659 6704                    		RTSD #10H
0000065B                         __$enter_pe_mode:
                                 		.STACK	__$enter_pe_mode=24
                                 ;    1296 /******************************************************************************
                                 ;    1297 End of function  rom_write
                                 ;    1298 ******************************************************************************/
                                 ;    1299 
                                 ;    1300 /******************************************************************************
                                 ;    1301 * Function Name: enter_pe_mode
                                 ;    1302 * Description  : Puts the FCU into program/erase mode.
                                 ;    1303 *                NOTE: This function MUST execute from in RAM for 'ROM Area' 
                                 ;    1304 *                programming, but if you are ONLY doing Data Flash programming,
                                 ;    1305 *                this function can reside and execute in Flash.
                                 ;    1306 * Arguments    : flash_addr - 
                                 ;    1307 *                    The programming/erasure address
                                 ;    1308 *                bytes - 
                                 ;    1309 *                    The number of bytes you are writing (if you are writing).  
                                 ;    1310 * Return Value : FLASH_SUCCESS - 
                                 ;    1311 *                    Operation Successful
                                 ;    1312 *                FLASH_FAILURE - 
                                 ;    1313 *                    Operation Failed
                                 ;    1314 ******************************************************************************/
                                 ;    1315 static uint8_t enter_pe_mode (uint32_t flash_addr)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1315
0000065B 7100EC                  		ADD #0FFFFFFECH, R0
0000065E A101                    		MOV.L R1, 10H[R0]
                                 ;    1316 {
                                 ;    1317     /* Used for timeout on FENTRYR write/read. */
                                 ;    1318     volatile int32_t wait_cnt;
                                 ;    1319 
                                 ;    1320     /* If FCU firmware has already been transferred to FCU RAM,
                                 ;    1321        no need to do it again */
                                 ;    1322     if( !g_fcu_transfer_complete )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1322
00000660 FBE2rrrrrrrr            		MOV.L #__$g_fcu_transfer_complete, R14
00000666 58EE                    		MOVU.B [R14], R14
00000668 610E                    		CMP #00H, R14
0000066A 21rr                    		BNE L197
0000066C 2Err                 B  		BRA L198
0000066E                         L195:	; bb4
                                 ;    1323     {
                                 ;    1324         /* Initialise the FCU, and store operation resilt in result variable */             
                                 ;    1325         /* Check if FCU initialisation was successful */
                                 ;    1326         if( flash_init() != FLASH_SUCCESS )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1326
0000066E 39rrrr               W  		BSR __$flash_init
00000671 6101                    		CMP #00H, R1
00000673 20rr                    		BEQ L200
00000675                         L196:	; bb5
                                 ;    1327         {
                                 ;    1328             /* FCU initialisiation failed - return operation failure */
                                 ;    1329             return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1329
00000675 3C0706                  		MOV.B #06H, 07H[R0]
00000678 38rrrr               W  		BRA L250
0000067B                         L197:	; bb16
0000067B F80600                  		MOV.L #00000000H, [R0]
0000067E 08                   S  		BRA L199
0000067F                         L198:	; bb17
0000067F F80601                  		MOV.L #00000001H, [R0]
00000682                         L199:	; bb18
00000682 EC01                    		MOV.L [R0], R1
00000684 6101                    		CMP #00H, R1
00000686 21rr                    		BNE L195
00000688                         L200:	; bb22
00000688 FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;    1330         }
                                 ;    1331     }
                                 ;    1332     
                                 ;    1333     /* FENTRYR must be 0x0000 before bit FENTRY0 or FENTRYD can be set to 1 */
                                 ;    1334     FLASH.FENTRYR.WORD = 0xAA00;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1334
0000068D F8E900AA                		MOV.W #0AA00H, [R14]
00000691                         L201:	; bb22.split
                                 ;    1335 
                                 ;    1336     /* Initialize timeout for FENTRYR being written. */
                                 ;    1337     wait_cnt = FLASH_FENTRYR_TIMEOUT;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1337
00000691 3E0204                  		MOV.L #00000004H, 08H[R0]
00000694 2Err                 B  		BRA L204
00000696                         L202:	; bb24
                                 ;    1338 
                                 ;    1339     /* Read FENTRYR to ensure it has been set to 0. Note that the top byte
                                 ;    1340        of the FENTRYR register is not retained and is read as 0x00. */
                                 ;    1341     while(0x0000 != FLASH.FENTRYR.WORD)
                                 ;    1342     {
                                 ;    1343         /* Wait until FENTRYR is 0 unless timeout occurs. */
                                 ;    1344         if (wait_cnt-- <= 0)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1344
00000696 A881                    		MOV.L 08H[R0], R1
00000698 A882                    		MOV.L 08H[R0], R2
0000069A 6012                    		SUB #01H, R2
0000069C A082                    		MOV.L R2, 08H[R0]
0000069E 6101                    		CMP #00H, R1
000006A0 2Arr                    		BGT L204
000006A2                         L203:	; bb25
                                 ;    1345         {
                                 ;    1346             /* This should not happen. FENTRYR getting written to 0 should
                                 ;    1347                only take 2-4 PCLK cycles. */
                                 ;    1348             return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1348
000006A2 3C0706                  		MOV.B #06H, 07H[R0]
000006A5 38rrrr               W  		BRA L250
000006A8                         L204:	; bb34
000006A8 FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1341
000006AD 5CEE                    		MOVU.W [R14], R14
000006AF 610E                    		CMP #00H, R14
000006B1 21rr                    		BNE L202
000006B3                         L205:	; bb41
                                 ;    1349         }
                                 ;    1350     }
                                 ;    1351 
                                 ;    1352     /* Check if FCU mode is set to ROM PE */
                                 ;    1353     if( g_current_mode == ROM_PE_MODE) 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1353
000006B3 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
000006B9 58EE                    		MOVU.B [R14], R14
000006BB 611E                    		CMP #01H, R14
000006BD 3Brrrr               W  		BNE L222
000006C0                         L206:	; bb42
000006C0 FBEE12C47F              		MOV.L #007FC412H, R14
                                 ;    1354     {
                                 ;    1355 #if defined(FLASH_API_RX_CFG_ROM_BGO)
                                 ;    1356         /* Don't enable flash interrupts if programming lock bits */
                                 ;    1357         if( g_flash_state != FLASH_LOCK_BIT )
                                 ;    1358         {       
                                 ;    1359             /* Re-enable the FRDYI interrupt */
                                 ;    1360             FLASH.FRDYIE.BIT.FRDYIE = 1;     
                                 ;    1361         }
                                 ;    1362 #else
                                 ;    1363         /* Disable the FRDYI interrupt */
                                 ;    1364         FLASH.FRDYIE.BIT.FRDYIE = 0;            
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1364
000006C5 F0E8                    		BCLR #00H, [R14].B
000006C7                         L207:	; bb42.split
                                 ;    1365 #endif                       
                                 ;    1366                                      
                                 ;    1367         /* Check which area of flash this address is in */
                                 ;    1368         if(flash_addr >= ROM_AREA_0)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1368
000006C7 A901                    		MOV.L 10H[R0], R1
000006C9 74010000F800            		CMP #00F80000H, R1
000006CF 23rr                    		BLTU L209
000006D1                         L208:	; bb47
000006D1 FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;    1369         {
                                 ;    1370             /* Area 0 */
                                 ;    1371             /* Enter ROM PE mode for ROM Area 0 */
                                 ;    1372             FLASH.FENTRYR.WORD = 0xAA01;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1372
000006D6 F8E901AA                		MOV.W #0AA01H, [R14]
000006DA 38rrrr               W  		BRA L227
000006DD                         L209:	; bb49
                                 ;    1373         } 
                                 ;    1374 #if defined(ROM_AREA_1)
                                 ;    1375         else if((flash_addr < ROM_AREA_0) && (flash_addr >= ROM_AREA_1)) 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1375
000006DD A901                    		MOV.L 10H[R0], R1
000006DF 74010000F800            		CMP #00F80000H, R1
000006E5 23rr                    		BLTU L218
000006E7 2Err                 B  		BRA L220
000006E9                         L210:	; bb50
000006E9 FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;    1376         {            
                                 ;    1377             /* Area 1 */
                                 ;    1378             /* Enter ROM PE mode for ROM Area 1 */
                                 ;    1379             FLASH.FENTRYR.WORD = 0xAA02;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1379
000006EE F8E902AA                		MOV.W #0AA02H, [R14]
000006F2 2Err                 B  		BRA L227
000006F4                         L211:	; bb52
                                 ;    1380         }
                                 ;    1381 #endif
                                 ;    1382 #if defined(ROM_AREA_2)
                                 ;    1383         else if((flash_addr < ROM_AREA_1) && (flash_addr >= ROM_AREA_2)) 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1383
000006F4 A901                    		MOV.L 10H[R0], R1
000006F6 74010000F000            		CMP #00F00000H, R1
000006FC 23rr                    		BLTU L214
000006FE 2Err                 B  		BRA L216
00000700                         L212:	; bb53
00000700 FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;    1384         {            
                                 ;    1385             /* Area 2 */
                                 ;    1386             /* Enter ROM PE mode for ROM Area 2 */
                                 ;    1387             FLASH.FENTRYR.WORD = 0xAA04;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1387
00000705 F8E904AA                		MOV.W #0AA04H, [R14]
00000709 2Err                 B  		BRA L227
0000070B                         L213:	; bb54
0000070B FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;    1388         }
                                 ;    1389 #endif
                                 ;    1390 #if defined(ROM_AREA_3)
                                 ;    1391         else
                                 ;    1392         {
                                 ;    1393             /* Area 3 */
                                 ;    1394             /* Enter ROM PE mode for ROM Area 3 */
                                 ;    1395             FLASH.FENTRYR.WORD = 0xAA08;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1395
00000710 F8E908AA                		MOV.W #0AA08H, [R14]
00000714 2Err                 B  		BRA L227
00000716                         L214:	; bb58
00000716 A901                    		MOV.L 10H[R0], R1
00000718 74010000E800            		CMP #00E80000H, R1
0000071E 23rr                    		BLTU L216
00000720                         L215:	; bb62
00000720 F80601                  		MOV.L #00000001H, [R0]
00000723 08                   S  		BRA L217
00000724                         L216:	; bb63
00000724 F80600                  		MOV.L #00000000H, [R0]
00000727                         L217:	; bb64
00000727 EC01                    		MOV.L [R0], R1
00000729 6101                    		CMP #00H, R1
0000072B 21rr                    		BNE L212
0000072D 2Err                 B  		BRA L213
0000072F                         L218:	; bb73
0000072F A901                    		MOV.L 10H[R0], R1
00000731 74010000F000            		CMP #00F00000H, R1
00000737 23rr                    		BLTU L220
00000739                         L219:	; bb77
00000739 F80601                  		MOV.L #00000001H, [R0]
0000073C 08                   S  		BRA L221
0000073D                         L220:	; bb78
0000073D F80600                  		MOV.L #00000000H, [R0]
00000740                         L221:	; bb79
00000740 EC01                    		MOV.L [R0], R1
00000742 6101                    		CMP #00H, R1
00000744 21rr                    		BNE L210
00000746 2Err                 B  		BRA L211
00000748                         L222:	; bb91
                                 ;    1396         }
                                 ;    1397 #endif
                                 ;    1398                 
                                 ;    1399     }
                                 ;    1400     /* Check if FCU mode is set to data flash PE */
                                 ;    1401     else if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1401
00000748 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
0000074E 58EE                    		MOVU.B [R14], R14
00000750 612E                    		CMP #02H, R14
00000752 21rr                    		BNE L226
00000754                         L223:	; bb92
00000754 FBEE12C47F              		MOV.L #007FC412H, R14
                                 ;    1402     {        
                                 ;    1403 #if defined(FLASH_API_RX_CFG_DATA_FLASH_BGO)
                                 ;    1404         /* Re-enable the FRDYI interrupt */
                                 ;    1405         FLASH.FRDYIE.BIT.FRDYIE = 1; 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1405
00000759 F0E0                    		BSET #00H, [R14].B
0000075B                         L224:	; bb92.split
0000075B FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;    1406 #else
                                 ;    1407         /* Disable the FRDYI interrupt */
                                 ;    1408         FLASH.FRDYIE.BIT.FRDYIE = 0; 
                                 ;    1409 #endif                               
                                 ;    1410                         
                                 ;    1411         /* Set FENTRYD bit(Bit 7) and FKEY (B8-15 = 0xAA) */
                                 ;    1412         FLASH.FENTRYR.WORD = 0xAA80;    
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1412
00000760 F8E980AA                		MOV.W #0AA80H, [R14]
00000764                         L225:	; bb92.split1
                                 ;    1413 
                                 ;    1414         /*  First clear the FCU's status before doing Data Flash programming.
                                 ;    1415             This is to clear out any previous errors that may have occured.
                                 ;    1416             For example, if you attempt to read the Data Flash area 
                                 ;    1417             before you make it readable using R_FlashDataAreaAccess(). */
                                 ;    1418         data_flash_status_clear();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1418
00000764 39rrrr               W  		BSR __$data_flash_status_clear
00000767 08                   S  		BRA L227
00000768                         L226:	; bb96
                                 ;    1419         
                                 ;    1420     }
                                 ;    1421     /* Catch-all for invalid FCU mode */
                                 ;    1422     else
                                 ;    1423     {
                                 ;    1424         /* Invalid value of 'g_current_mode' */
                                 ;    1425         return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1425
00000768 3C0706                  		MOV.B #06H, 07H[R0]
0000076B 38rrrr               W  		BRA L250
0000076E                         L227:	; bb109
0000076E FBEE96C208              		MOV.L #0008C296H, R14
                                 ;    1426     }
                                 ;    1427     
                                 ;    1428     /* Enable Write/Erase of ROM/Data Flash */
                                 ;    1429     FLASH.FWEPROR.BYTE = 0x01;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1429
00000773 F8E401                  		MOV.B #01H, [R14]
00000776                         L228:	; bb109.split
00000776 FBEEB0FF7F              		MOV.L #007FFFB0H, R14
                                 ;    1430 
                                 ;    1431     /* Check for FCU error */
                                 ;    1432     if(     (FLASH.FSTATR0.BIT.ILGLERR == 1)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1432
0000077B 58EE                    		MOVU.B [R14], R14
0000077D 686E                    		SHLR #06H, R14
0000077F 641E                    		AND #01H, R14
00000781 611E                    		CMP #01H, R14
00000783 20rr                    		BEQ L231
00000785 08                   S  		BRA L230
00000786                         L229:	; bb111
                                 ;    1433         ||  (FLASH.FSTATR0.BIT.ERSERR  == 1)
                                 ;    1434         ||  (FLASH.FSTATR0.BIT.PRGERR  == 1)
                                 ;    1435         ||  (FLASH.FSTATR1.BIT.FCUERR  == 1)) 
                                 ;    1436     {
                                 ;    1437         /* Return FLASH_FAILURE, operation failure */
                                 ;    1438         return FLASH_FAILURE;    
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1438
00000786 3C0706                  		MOV.B #06H, 07H[R0]
00000789 38rrrr               W  		BRA L250
0000078C                         L230:	; bb119
0000078C FBEEB0FF7F              		MOV.L #007FFFB0H, R14
00000791 58EE                    		MOVU.B [R14], R14
00000793 685E                    		SHLR #05H, R14
00000795 641E                    		AND #01H, R14
00000797 611E                    		CMP #01H, R14
00000799 18                   S  		BNE L232
0000079A                         L231:	; bb126
0000079A F80601                  		MOV.L #00000001H, [R0]
0000079D 08                   S  		BRA L233
0000079E                         L232:	; bb127
0000079E F80600                  		MOV.L #00000000H, [R0]
000007A1                         L233:	; bb128
000007A1 EC01                    		MOV.L [R0], R1
000007A3 6101                    		CMP #00H, R1
000007A5 21rr                    		BNE L235
000007A7                         L234:	; bb132
000007A7 FBEEB0FF7F              		MOV.L #007FFFB0H, R14
000007AC 58EE                    		MOVU.B [R14], R14
000007AE 684E                    		SHLR #04H, R14
000007B0 641E                    		AND #01H, R14
000007B2 611E                    		CMP #01H, R14
000007B4 18                   S  		BNE L236
000007B5                         L235:	; bb139
000007B5 F80601                  		MOV.L #00000001H, [R0]
000007B8 08                   S  		BRA L237
000007B9                         L236:	; bb140
000007B9 F80600                  		MOV.L #00000000H, [R0]
000007BC                         L237:	; bb141
000007BC EC01                    		MOV.L [R0], R1
000007BE 6101                    		CMP #00H, R1
000007C0 21rr                    		BNE L239
000007C2                         L238:	; bb145
000007C2 754E80                  		MOV.L #00000080H, R14
000007C5 FBFEB1FF7F              		MOV.L #007FFFB1H, R15
000007CA 50FE                    		AND [R15].UB, R14
000007CC 687E                    		SHLR #07H, R14
000007CE 611E                    		CMP #01H, R14
000007D0 18                   S  		BNE L240
000007D1                         L239:	; bb151
000007D1 F80601                  		MOV.L #00000001H, [R0]
000007D4 08                   S  		BRA L241
000007D5                         L240:	; bb152
000007D5 F80600                  		MOV.L #00000000H, [R0]
000007D8                         L241:	; bb153
000007D8 EC01                    		MOV.L [R0], R1
000007DA 6101                    		CMP #00H, R1
000007DC 21rr                    		BNE L229
000007DE                         L242:	; bb159
                                 ;    1439     }
                                 ;    1440     
                                 ;    1441     /* Check to see if peripheral clock notification command is needed */
                                 ;    1442     if( g_fcu_pclk_command == 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1442
000007DE FBE2rrrrrrrr            		MOV.L #__$g_fcu_pclk_command, R14
000007E4 58EE                    		MOVU.B [R14], R14
000007E6 610E                    		CMP #00H, R14
000007E8 21rr                    		BNE L249
000007EA                         L243:	; bb160
000007EA FBEE12C47F              		MOV.L #007FC412H, R14
                                 ;    1443     {
                                 ;    1444         /* Disable FCU interrupts, so interrupt will not trigger after
                                 ;    1445            peripheral clock notification command */
                                 ;    1446         FLASH.FRDYIE.BIT.FRDYIE = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1446
000007EF F0E8                    		BCLR #00H, [R14].B
000007F1                         L244:	; bb160.split
                                 ;    1447         
                                 ;    1448         /* Inform FCU of flash clock speed, check if operation is succesful */
                                 ;    1449         if(notify_peripheral_clock((FCU_BYTE_PTR)flash_addr)!=0)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1449
000007F1 A901                    		MOV.L 10H[R0], R1
000007F3 39rrrr               W  		BSR __$notify_peripheral_clock
000007F6 6101                    		CMP #00H, R1
000007F8 10                   S  		BEQ L246
000007F9                         L245:	; bb165
                                 ;    1450         {                   
                                 ;    1451             /* Return FLASH_FAILURE, operation failure */
                                 ;    1452             return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1452
000007F9 3C0706                  		MOV.B #06H, 07H[R0]
000007FC 2Err                 B  		BRA L250
000007FE                         L246:	; bb175
                                 ;    1453         }
                                 ;    1454         
                                 ;    1455         /* Only re-enable flash ready interrupt if using BGO */
                                 ;    1456 #ifdef FLASH_API_RX_CFG_DATA_FLASH_BGO
                                 ;    1457         if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1457
000007FE FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000804 58EE                    		MOVU.B [R14], R14
00000806 612E                    		CMP #02H, R14
00000808 18                   S  		BNE L248
00000809                         L247:	; bb176
00000809 FBEE12C47F              		MOV.L #007FC412H, R14
                                 ;    1458         {
                                 ;    1459             /* Re-enable the FRDYI interrupt */
                                 ;    1460             FLASH.FRDYIE.BIT.FRDYIE = 1;        
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1460
0000080E F0E0                    		BSET #00H, [R14].B
00000810                         L248:	; bb185
                                 ;    1461         }       
                                 ;    1462 #endif
                                 ;    1463 #ifdef FLASH_API_RX_CFG_ROM_BGO
                                 ;    1464         if( g_current_mode == ROM_PE_MODE )
                                 ;    1465         {
                                 ;    1466             /* Don't enable flash interrupts if programming lock bits */
                                 ;    1467             if( g_flash_state != FLASH_LOCK_BIT )
                                 ;    1468             {       
                                 ;    1469                 /* Re-enable the FRDYI interrupt */
                                 ;    1470                 FLASH.FRDYIE.BIT.FRDYIE = 1;     
                                 ;    1471             }                        
                                 ;    1472         }
                                 ;    1473 #endif
                                 ;    1474         
                                 ;    1475         /* No need to notify FCU of clock supplied to flash again */
                                 ;    1476         g_fcu_pclk_command = 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1476
00000810 FBE2rrrrrrrr            		MOV.L #__$g_fcu_pclk_command, R14
00000816 F8E401                  		MOV.B #01H, [R14]
00000819                         L249:	; bb191
                                 ;    1477     }    
                                 ;    1478 
                                 ;    1479     /* Return FLASH_SUCCESS, operation successful */
                                 ;    1480     return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1480
00000819 3C0700                  		MOV.B #00H, 07H[R0]
0000081C                         L250:	; bb193
0000081C C500070F                		MOV.B 07H[R0], 0FH[R0]
                                 ;    1481 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1481
00000820 B389                    		MOVU.B 0FH[R0], R1
00000822 6705                    		RTSD #14H
00000824                         __$exit_pe_mode:
                                 		.STACK	__$exit_pe_mode=20
                                 ;    1482 /******************************************************************************
                                 ;    1483 End of function enter_pe_mode
                                 ;    1484 ******************************************************************************/
                                 ;    1485 
                                 ;    1486 /******************************************************************************
                                 ;    1487 * Function Name: exit_pe_mode
                                 ;    1488 * Description  : Takes the FCU out of program/erase mode.
                                 ;    1489 *                NOTE: This function MUST execute from in RAM for 'ROM Area' 
                                 ;    1490 *                programming, but if you are ONLY doing Data Flash 
                                 ;    1491 *                programming, this function can reside and execute in Flash.
                                 ;    1492 * Arguments    : flash_addr - 
                                 ;    1493 *                    The programming/erasure address
                                 ;    1494 * Return Value : none
                                 ;    1495 ******************************************************************************/
                                 ;    1496 static void exit_pe_mode (uint32_t flash_addr)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1496
00000824 7100F0                  		ADD #0FFFFFFF0H, R0
00000827 A089                    		MOV.L R1, 0CH[R0]
                                 ;    1497 {
                                 ;    1498     /* Declare wait timer count variable */
                                 ;    1499     volatile int32_t wait_cnt;
                                 ;    1500     
                                 ;    1501     /* Declare address pointer */
                                 ;    1502     FCU_BYTE_PTR p_addr;
                                 ;    1503 
                                 ;    1504     /* Cast flash address so that it can be used as pointer and will be
                                 ;    1505        accessed correctly. */
                                 ;    1506     p_addr = (FCU_BYTE_PTR)flash_addr;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1506
00000829 A081                    		MOV.L R1, 08H[R0]
0000082B                         L252:	; entry.split
                                 ;    1507 
                                 ;    1508     /* Set wait timer count duration */  
                                 ;    1509     wait_cnt = WAIT_MAX_ERASE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1509
0000082B F9020100D0DD06          		MOV.L #06DDD000H, 04H[R0]
00000832 2Err                 B  		BRA L256
00000834                         L253:	; bb
                                 ;    1510 
                                 ;    1511     /* Iterate while loop whilst FCU operation is in progress */
                                 ;    1512     while(FLASH.FSTATR0.BIT.FRDY == 0)
                                 ;    1513     {
                                 ;    1514         /* Decrement wait timer count variable */
                                 ;    1515         wait_cnt--;                         
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1515
00000834 A809                    		MOV.L 04H[R0], R1
00000836 6011                    		SUB #01H, R1
00000838 A009                    		MOV.L R1, 04H[R0]
0000083A                         L254:	; bb.split
                                 ;    1516 
                                 ;    1517         /* Check if wait timer count value has reached zero */
                                 ;    1518         if(wait_cnt == 0)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1518
0000083A A809                    		MOV.L 04H[R0], R1
0000083C 6101                    		CMP #00H, R1
0000083E 18                   S  		BNE L256
0000083F                         L255:	; bb8
                                 ;    1519         {
                                 ;    1520             /* Timeout duration has elapsed, assuming operation failure and
                                 ;    1521                resetting the FCU */
                                 ;    1522             flash_reset();          
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1522
0000083F 39rrrr               W  		BSR __$flash_reset
00000842 2Err                 B  		BRA L257
00000844                         L256:	; bb14
00000844 754E80                  		MOV.L #00000080H, R14
00000847 FBFEB0FF7F              		MOV.L #007FFFB0H, R15
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1512
0000084C 50FE                    		AND [R15].UB, R14
0000084E 687E                    		SHLR #07H, R14
00000850 610E                    		CMP #00H, R14
00000852 20rr                    		BEQ L253
00000854                         L257:	; bb23
00000854 FBEEB0FF7F              		MOV.L #007FFFB0H, R14
                                 ;    1523             
                                 ;    1524             /* Break from the while loop prematurely */
                                 ;    1525             break;
                                 ;    1526         }
                                 ;    1527     }
                                 ;    1528 
                                 ;    1529     /* Check FSTATR0 and execute a status register clear command if needed */
                                 ;    1530     if(     (FLASH.FSTATR0.BIT.ILGLERR == 1) 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1530
00000859 58EE                    		MOVU.B [R14], R14
0000085B 686E                    		SHLR #06H, R14
0000085D 641E                    		AND #01H, R14
0000085F 611E                    		CMP #01H, R14
00000861 20rr                    		BEQ L263
00000863 2Err                 B  		BRA L262
00000865                         L258:	; bb25
00000865 FBEEB0FF7F              		MOV.L #007FFFB0H, R14
                                 ;    1531         ||  (FLASH.FSTATR0.BIT.ERSERR  == 1) 
                                 ;    1532         ||  (FLASH.FSTATR0.BIT.PRGERR  == 1)) 
                                 ;    1533     {
                                 ;    1534 
                                 ;    1535         /* Clear ILGLERR */
                                 ;    1536         if(FLASH.FSTATR0.BIT.ILGLERR == 1)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1536
0000086A 58EE                    		MOVU.B [R14], R14
0000086C 686E                    		SHLR #06H, R14
0000086E 641E                    		AND #01H, R14
00000870 611E                    		CMP #01H, R14
00000872 21rr                    		BNE L261
00000874                         L259:	; bb27
00000874 FBEE10C47F              		MOV.L #007FC410H, R14
                                 ;    1537         {
                                 ;    1538             /* FASTAT must be set to 0x10 before the status clear command
                                 ;    1539                can be successfully issued  */
                                 ;    1540             if(FLASH.FASTAT.BYTE != 0x10)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1540
00000879 58EE                    		MOVU.B [R14], R14
0000087B 755E10                  		CMP #10H, R14
0000087E 10                   S  		BEQ L261
0000087F                         L260:	; bb28
0000087F FBEE10C47F              		MOV.L #007FC410H, R14
                                 ;    1541             {
                                 ;    1542                 /* Set the FASTAT register to 0x10 so that a status clear
                                 ;    1543                     command can be issued */
                                 ;    1544                 FLASH.FASTAT.BYTE = 0x10;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1544
00000884 F8E410                  		MOV.B #10H, [R14]
00000887                         L261:	; bb42
                                 ;    1545             }
                                 ;    1546         }
                                 ;    1547         
                                 ;    1548         /* Send status clear command to FCU */
                                 ;    1549         *p_addr = 0x50;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1549
00000887 A881                    		MOV.L 08H[R0], R1
00000889 F81450                  		MOV.B #50H, [R1]
0000088C 2Err                 B  		BRA L270
0000088E                         L262:	; bb50
0000088E FBEEB0FF7F              		MOV.L #007FFFB0H, R14
00000893 58EE                    		MOVU.B [R14], R14
00000895 685E                    		SHLR #05H, R14
00000897 641E                    		AND #01H, R14
00000899 611E                    		CMP #01H, R14
0000089B 18                   S  		BNE L264
0000089C                         L263:	; bb57
0000089C F80601                  		MOV.L #00000001H, [R0]
0000089F 08                   S  		BRA L265
000008A0                         L264:	; bb58
000008A0 F80600                  		MOV.L #00000000H, [R0]
000008A3                         L265:	; bb59
000008A3 EC01                    		MOV.L [R0], R1
000008A5 6101                    		CMP #00H, R1
000008A7 21rr                    		BNE L267
000008A9                         L266:	; bb63
000008A9 FBEEB0FF7F              		MOV.L #007FFFB0H, R14
000008AE 58EE                    		MOVU.B [R14], R14
000008B0 684E                    		SHLR #04H, R14
000008B2 641E                    		AND #01H, R14
000008B4 611E                    		CMP #01H, R14
000008B6 18                   S  		BNE L268
000008B7                         L267:	; bb70
000008B7 F80601                  		MOV.L #00000001H, [R0]
000008BA 08                   S  		BRA L269
000008BB                         L268:	; bb71
000008BB F80600                  		MOV.L #00000000H, [R0]
000008BE                         L269:	; bb72
000008BE EC01                    		MOV.L [R0], R1
000008C0 6101                    		CMP #00H, R1
000008C2 21rr                    		BNE L258
000008C4                         L270:	; bb77
000008C4 FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;    1550     }
                                 ;    1551 
                                 ;    1552     /* Enter ROM Read mode */
                                 ;    1553     FLASH.FENTRYR.WORD = 0xAA00;        
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1553
000008C9 F8E900AA                		MOV.W #0AA00H, [R14]
000008CD                         L271:	; bb77.split
                                 ;    1554 
                                 ;    1555     /* Initialize timeout for FENTRYR being written. */
                                 ;    1556     wait_cnt = FLASH_FENTRYR_TIMEOUT;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1556
000008CD 3E0104                  		MOV.L #00000004H, 04H[R0]
000008D0 2Err                 B  		BRA L273
000008D2                         L272:	; bb79
                                 ;    1557 
                                 ;    1558     /* Read FENTRYR to ensure it has been set to 0. Note that the top byte
                                 ;    1559        of the FENTRYR register is not retained and is read as 0x00. */
                                 ;    1560     while(0x0000 != FLASH.FENTRYR.WORD)
                                 ;    1561     {
                                 ;    1562         /* Wait until FENTRYR is 0 unless timeout occurs. */
                                 ;    1563         if (wait_cnt-- <= 0)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1563
000008D2 A809                    		MOV.L 04H[R0], R1
000008D4 A80A                    		MOV.L 04H[R0], R2
000008D6 6012                    		SUB #01H, R2
000008D8 A00A                    		MOV.L R2, 04H[R0]
000008DA 6101                    		CMP #00H, R1
000008DC 2Brr                    		BLE L274
000008DE                         L273:	; bb89
000008DE FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1560
000008E3 5CEE                    		MOVU.W [R14], R14
000008E5 610E                    		CMP #00H, R14
000008E7 21rr                    		BNE L272
000008E9                         L274:	; bb96
000008E9 FBEE12C47F              		MOV.L #007FC412H, R14
                                 ;    1564         {
                                 ;    1565             /* This should not happen. FENTRYR getting written to 0 should
                                 ;    1566                only take 2-4 PCLK cycles. Could add a call to FlashError()
                                 ;    1567                here if user wants to process this. */
                                 ;    1568             break;
                                 ;    1569         }
                                 ;    1570     }
                                 ;    1571 
                                 ;    1572     /* Disable the FRDYI interrupt */
                                 ;    1573     FLASH.FRDYIE.BIT.FRDYIE = 0;            
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1573
000008EE F0E8                    		BCLR #00H, [R14].B
000008F0                         L275:	; bb96.split
000008F0 FBEE96C208              		MOV.L #0008C296H, R14
                                 ;    1574     
                                 ;    1575     /* Flash write/erase disabled */
                                 ;    1576     FLASH.FWEPROR.BYTE = 0x02;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1576
000008F5 F8E402                  		MOV.B #02H, [R14]
000008F8 6704                    		RTSD #10H
000008FA                         _R_FlashErase:
                                 		.STACK	_R_FlashErase=28
                                 ;    1577 
                                 ;    1578 }
                                 ;    1579 /******************************************************************************
                                 ;    1580 End of function  exit_pe_mode
                                 ;    1581 ******************************************************************************/
                                 ;    1582 
                                 ;    1583 /******************************************************************************
                                 ;    1584 * Function Name: R_FlashErase
                                 ;    1585 * Description  : Erases an entire flash block.
                                 ;    1586 *                NOTE: This function MUST execute from in RAM for 'ROM Area' 
                                 ;    1587 *                programming, but if you are ONLY doing Data Flash programming,
                                 ;    1588 *                this function can reside and execute in Flash.
                                 ;    1589 * Arguments    : block - 
                                 ;    1590 *                    The block number to erase (BLOCK_0, BLOCK_1, etc...)
                                 ;    1591 * Return Value : FLASH_SUCCESS - 
                                 ;    1592 *                    Operation Successful
                                 ;    1593 *                FLASH_FAILURE - 
                                 ;    1594 *                    Operation Failed
                                 ;    1595 *                FLASH_BUSY - 
                                 ;    1596 *                    Another flash operation is in progress
                                 ;    1597 ******************************************************************************/
                                 ;    1598 uint8_t R_FlashErase (uint32_t block)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1598
000008FA 7100E8                  		ADD #0FFFFFFE8H, R0
000008FD A109                    		MOV.L R1, 14H[R0]
                                 ;    1599 {
                                 ;    1600     /* Declare address pointer */
                                 ;    1601     uint32_t p_addr;
                                 ;    1602     /* Declare erase operation result container variable */
                                 ;    1603     uint8_t  result = FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1603
000008FF 3C0B00                  		MOV.B #00H, 0BH[R0]
00000902                         L277:	; entry.split
00000902 6611                    		MOV.L #00000001H, R1
                                 ;    1604     
                                 ;    1605     /* Attempt to grab state */
                                 ;    1606     if( flash_grab_state(FLASH_ERASING) != FLASH_SUCCESS )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1606
00000904 39rrrr               W  		BSR __$flash_grab_state
00000907 6101                    		CMP #00H, R1
00000909 10                   S  		BEQ L279
0000090A                         L278:	; bb5
                                 ;    1607     {
                                 ;    1608         /* Another operation is already in progress */
                                 ;    1609         return FLASH_BUSY;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1609
0000090A 3C0305                  		MOV.B #05H, 03H[R0]
0000090D 38rrrr               W  		BRA L303
00000910                         L279:	; bb11
                                 ;    1610     }
                                 ;    1611     
                                 ;    1612     /* Erase Command Address */
                                 ;    1613     p_addr = g_flash_BlockAddresses[block];
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1613
00000910 FBE2rrrrrrrr            		MOV.L #_g_flash_BlockAddresses, R14
00000916 A909                    		MOV.L 14H[R0], R1
00000918 FE61E1                  		MOV.L [R1,R14], R1
0000091B A009                    		MOV.L R1, 04H[R0]
0000091D                         L280:	; bb11.split
                                 ;    1614 
                                 ;    1615     /* Do we want to erase a Data Flash block or ROM block? */
                                 ;    1616     if( block >= BLOCK_DB0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1616
0000091D A909                    		MOV.L 14H[R0], R1
0000091F 755146                  		CMP #46H, R1
00000922 23rr                    		BLTU L282
00000924                         L281:	; bb16
                                 ;    1617     {
                                 ;    1618         /* Set current FCU mode to data flash PE */
                                 ;    1619         g_current_mode = FLD_PE_MODE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1619
00000924 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
0000092A F8E402                  		MOV.B #02H, [R14]
0000092D 08                   S  		BRA L283
0000092E                         L282:	; bb17
                                 ;    1620     }
                                 ;    1621     else
                                 ;    1622     {
                                 ;    1623         /* Set current FCU mode to ROM PE */
                                 ;    1624         g_current_mode = ROM_PE_MODE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1624
0000092E FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000934 F8E401                  		MOV.B #01H, [R14]
00000937                         L283:	; bb23
                                 ;    1625     }
                                 ;    1626 
                                 ;    1627     /* Enter ROM PE mode, check if operation successful */
                                 ;    1628     if( enter_pe_mode(p_addr) != FLASH_SUCCESS)        
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1628
00000937 A809                    		MOV.L 04H[R0], R1
00000939 39rrrr               W  		BSR __$enter_pe_mode
0000093C 6101                    		CMP #00H, R1
0000093E 20rr                    		BEQ L287
00000940                         L284:	; bb24
                                 ;    1629     {
                                 ;    1630         /* Make sure part is in ROM read mode. */
                                 ;    1631         exit_pe_mode(p_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1631
00000940 A809                    		MOV.L 04H[R0], R1
00000942 39rrrr               W  		BSR __$exit_pe_mode
00000945                         L285:	; bb24.split
                                 ;    1632 
                                 ;    1633         /* Release state */
                                 ;    1634         flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1634
00000945 39rrrr               W  		BSR __$flash_release_state
00000948                         L286:	; bb24.split1
                                 ;    1635         
                                 ;    1636         /* Return FLASH_FAILURE, operation failure */
                                 ;    1637         return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1637
00000948 3C0306                  		MOV.B #06H, 03H[R0]
0000094B 2Err                 B  		BRA L303
0000094D                         L287:	; bb33
0000094D FBEEB4FF7F              		MOV.L #007FFFB4H, R14
                                 ;    1638     }
                                 ;    1639 
                                 ;    1640 #ifdef  FLASH_API_RX_CFG_IGNORE_LOCK_BITS
                                 ;    1641     /* Cancel the ROM Protect feature 
                                 ;    1642        NOTE: If you are using block locking feature to protect your data,
                                 ;    1643        then comment out 'FLASH_API_RX_CFG_IGNORE_LOCK_BITS' in r_flash_api_rx_config.h */
                                 ;    1644     FLASH.FPROTR.WORD = 0x5501;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1644
00000952 F8E90155                		MOV.W #5501H, [R14]
00000956                         L288:	; bb33.split
                                 ;    1645 #else
                                 ;    1646     /* Only disable lock bit protection if user has specified to 
                                 ;    1647        do so earlier */
                                 ;    1648     if( g_lock_bit_protection == false )
                                 ;    1649     {
                                 ;    1650         /* Cancel the ROM Protect feature */
                                 ;    1651         FLASH.FPROTR.WORD = 0x5501;    
                                 ;    1652     }       
                                 ;    1653 #endif
                                 ;    1654 
                                 ;    1655 
                                 ;    1656 #if defined(DF_GROUPED_BLOCKS)
                                 ;    1657     /* NOTE:
                                 ;    1658        Some RX MCUs (e.g. RX63N) actually has 1024 x 32 byte blocks instead of 
                                 ;    1659        the 16 x 2Kbyte blocks defined in port file. These are grouped 
                                 ;    1660        into 16 blocks to make it easier for the user to delete larger sections 
                                 ;    1661        of the data flash at once. The user can still delete individual blocks 
                                 ;    1662        but they will need to use the new flash erase function that takes 
                                 ;    1663        addresses instead of blocks. For reference, the 2KB blocks defined
                                 ;    1664        are called 'fake' blocks. */
                                 ;    1665     if( FLD_PE_MODE == g_current_mode ) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1665
00000956 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
0000095C 58EE                    		MOVU.B [R14], R14
0000095E 612E                    		CMP #02H, R14
00000960 21rr                    		BNE L297
00000962                         L289:	; bb35
                                 ;    1666 
                                 ;    1667         /* Calculate how many bytes to erase */
                                 ;    1668         int32_t bytes_to_erase = (int32_t)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1668
00000962 FBE2rrrrrrrr            		MOV.L #_g_flash_BlockAddresses, R14
00000968 EDE147                  		MOV.L 011CH[R14], R1
0000096B 0681E146                		SUB 0118H[R14].L, R1
0000096F A089                    		MOV.L R1, 0CH[R0]
00000971                         L290:	; bb35.split
                                 ;    1669                                  (g_flash_BlockAddresses[BLOCK_DB1] - 
                                 ;    1670                                   g_flash_BlockAddresses[BLOCK_DB0]);
                                 ;    1671 
                                 ;    1672         /* Erase real data flash blocks until the 'fake' block is erased .*/
                                 ;    1673         while(0 < bytes_to_erase) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1673
00000971 A889                    		MOV.L 0CH[R0], R1
00000973 6101                    		CMP #00H, R1
00000975 2Brr                    		BLE L298
00000977                         L291:	; bb39
                                 ;    1674 
                                 ;    1675             /* Send FCU command to erase block */
                                 ;    1676             result = flash_erase_command((FCU_BYTE_PTR)p_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1676
00000977 A809                    		MOV.L 04H[R0], R1
00000979 39rrrr               W  		BSR __$flash_erase_command
0000097C 8289                    		MOV.B R1, 0BH[R0]
0000097E                         L292:	; bb39.split
                                 ;    1677 
                                 ;    1678             /* Advance pointer to next block */
                                 ;    1679             p_addr += DF_ERASE_BLOCK_SIZE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1679
0000097E A809                    		MOV.L 04H[R0], R1
00000980 711120                  		ADD #20H, R1
00000983 A009                    		MOV.L R1, 04H[R0]
00000985                         L293:	; bb39.split2
                                 ;    1680 
                                 ;    1681             /* Subtract off bytes erased */
                                 ;    1682             bytes_to_erase -= DF_ERASE_BLOCK_SIZE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1682
00000985 A889                    		MOV.L 0CH[R0], R1
00000987 7111E0                  		ADD #0FFFFFFE0H, R1
0000098A A089                    		MOV.L R1, 0CH[R0]
0000098C                         L294:	; bb39.split3
                                 ;    1683 
                                 ;    1684     #if defined(FLASH_API_RX_CFG_DATA_FLASH_BGO)
                                 ;    1685             /* Set global variables so that erase can continue in ISR. */
                                 ;    1686             g_bgo_flash_addr = p_addr;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1686
0000098C FBE2rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R14
00000992 E10E01                  		MOV.L 04H[R0], [R14]
00000995                         L295:	; bb39.split4
                                 ;    1687             g_bgo_bytes = bytes_to_erase;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1687
00000995 FBE2rrrrrrrr            		MOV.L #__$g_bgo_bytes, R14
0000099B E10E03                  		MOV.L 0CH[R0], [R14]
0000099E                         L296:	; bb39.split5
                                 ;    1688 
                                 ;    1689             /* Return, check result and continue erasure later in ISR */
                                 ;    1690             return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1690
0000099E 3C0300                  		MOV.B #00H, 03H[R0]
000009A1 2Err                 B  		BRA L303
000009A3                         L297:	; bb56
                                 ;    1691     #endif    
                                 ;    1692         }
                                 ;    1693     }
                                 ;    1694     else
                                 ;    1695     {
                                 ;    1696         /* This is a ROM block erase */
                                 ;    1697         /* Send FCU command to erase block */
                                 ;    1698         result = flash_erase_command((FCU_BYTE_PTR)p_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1698
000009A3 A809                    		MOV.L 04H[R0], R1
000009A5 39rrrr               W  		BSR __$flash_erase_command
000009A8 8289                    		MOV.B R1, 0BH[R0]
000009AA                         L298:	; bb66
                                 ;    1699     }
                                 ;    1700 #else
                                 ;    1701     /* Send FCU command to erase block */
                                 ;    1702     result = flash_erase_command((FCU_BYTE_PTR)p_addr);
                                 ;    1703 #endif
                                 ;    1704 
                                 ;    1705 #if defined(FLASH_API_RX_CFG_ROM_BGO)
                                 ;    1706     if( g_current_mode == ROM_PE_MODE )
                                 ;    1707     {
                                 ;    1708         /* Return, check result later in ISR */
                                 ;    1709         return FLASH_SUCCESS;
                                 ;    1710     }
                                 ;    1711 #endif    
                                 ;    1712     
                                 ;    1713 #if defined(FLASH_API_RX_CFG_DATA_FLASH_BGO)
                                 ;    1714     if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1714
000009AA FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
000009B0 58EE                    		MOVU.B [R14], R14
000009B2 612E                    		CMP #02H, R14
000009B4 18                   S  		BNE L300
000009B5                         L299:	; bb67
                                 ;    1715     {
                                 ;    1716         /* Return, check result later in ISR */
                                 ;    1717         return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1717
000009B5 3C0300                  		MOV.B #00H, 03H[R0]
000009B8 2Err                 B  		BRA L303
000009BA                         L300:	; bb74
                                 ;    1718     }
                                 ;    1719 #endif 
                                 ;    1720 
                                 ;    1721     /* Leave Program/Erase Mode */
                                 ;    1722     exit_pe_mode(p_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1722
000009BA A809                    		MOV.L 04H[R0], R1
000009BC 39rrrr               W  		BSR __$exit_pe_mode
000009BF                         L301:	; bb74.split
                                 ;    1723 
                                 ;    1724     /* Release state */
                                 ;    1725     flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1725
000009BF 39rrrr               W  		BSR __$flash_release_state
000009C2                         L302:	; bb74.split6
                                 ;    1726 
                                 ;    1727     /* Return erase result */
                                 ;    1728     return result;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1728
000009C2 C5000B03                		MOV.B 0BH[R0], 03H[R0]
000009C6                         L303:	; bb78
000009C6 C5000313                		MOV.B 03H[R0], 13H[R0]
                                 ;    1729 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1729
000009CA B489                    		MOVU.B 13H[R0], R1
000009CC 6706                    		RTSD #18H
000009CE                         _R_FlashEraseRange:
                                 		.STACK	_R_FlashEraseRange=20
                                 ;    1730 /******************************************************************************
                                 ;    1731 End of function  R_FlashErase
                                 ;    1732 ******************************************************************************/
                                 ;    1733 
                                 ;    1734 #if defined(DF_GROUPED_BLOCKS)
                                 ;    1735 /******************************************************************************
                                 ;    1736 * Function Name: R_FlashEraseRange
                                 ;    1737 * Description  : Erases blocks starting at an address and stopping when the
                                 ;    1738 *                number of bytes to erase has been reached.
                                 ;    1739 *                NOTE: This function is currently only for data flash blocks
                                 ;    1740 *                on RX MCUs.
                                 ;    1741 *                NOTE: This function MUST execute from in RAM for 'ROM Area' 
                                 ;    1742 *                programming, but if you are ONLY doing Data Flash programming,
                                 ;    1743 *                this function can reside and execute in Flash.
                                 ;    1744 * Arguments    : start_addr - 
                                 ;    1745 *                    The address of where to start erasing. Must be on
                                 ;    1746 *                    erase boundary.
                                 ;    1747 *                bytes - 
                                 ;    1748 *                    The numbers of bytes to erase. Must be multiple of 
                                 ;    1749 *                    erase size.
                                 ;    1750 * Return Value : FLASH_SUCCESS - 
                                 ;    1751 *                    Operation Successful
                                 ;    1752 *                FLASH_FAILURE - 
                                 ;    1753 *                    Operation Failed
                                 ;    1754 *                FLASH_ERROR_ALIGNED - 
                                 ;    1755 *                    Flash address was not on correct boundary
                                 ;    1756 *                FLASH_BUSY - 
                                 ;    1757 *                    Another flash operation is in progress
                                 ;    1758 *                FLASH_ERROR_BYTES - 
                                 ;    1759 *                    Number of bytes did not match erase size
                                 ;    1760 *                FLASH_ERROR_ADDRESS - 
                                 ;    1761 *                    Invalid address, this is only for DF
                                 ;    1762 ******************************************************************************/
                                 ;    1763 uint8_t R_FlashEraseRange (uint32_t start_addr, uint32_t bytes)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1763
000009CE 7100F0                  		ADD #0FFFFFFF0H, R0
000009D1 A089                    		MOV.L R1, 0CH[R0]
000009D3 A082                    		MOV.L R2, 08H[R0]
                                 ;    1764 {
                                 ;    1765     /* Declare erase operation result container variable */
                                 ;    1766     uint8_t result = FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1766
000009D5 3C0600                  		MOV.B #00H, 06H[R0]
000009D8                         L305:	; entry.split
                                 ;    1767     
                                 ;    1768     /* Take off upper byte since for programming/erase addresses for ROM are 
                                 ;    1769         the same as read addresses except upper byte is masked off to 0's.
                                 ;    1770         Data Flash addresses are not affected. */
                                 ;    1771     start_addr &= 0x00FFFFFF;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1771
000009D8 A889                    		MOV.L 0CH[R0], R1
000009DA 7421FFFFFF00            		AND #00FFFFFFH, R1
000009E0 A089                    		MOV.L R1, 0CH[R0]
000009E2                         L306:	; entry.split1
                                 ;    1772 
                                 ;    1773     /* Confirm this is for data flash */  
                                 ;    1774     if( start_addr >= DF_ADDRESS && start_addr < (DF_ADDRESS + BSP_DATA_FLASH_SIZE_BYTES) )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1774
000009E2 A889                    		MOV.L 0CH[R0], R1
000009E4 7701FFFF0F              		CMP #000FFFFFH, R1
000009E9 24rr                    		BGTU L312
000009EB 2Err                 B  		BRA L314
000009ED                         L307:	; bb7
000009ED 754E1F                  		MOV.L #0000001FH, R14
                                 ;    1775     {
                                 ;    1776         /* Check if the number of bytes were passed is a multiple of the 
                                 ;    1777            erase size for the data flash */
                                 ;    1778         if( bytes & (DF_ERASE_BLOCK_SIZE-1) )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1778
000009F0 06A10C0E02              		TST 08H[R0].L, R14
000009F5 10                   S  		BEQ L309
000009F6                         L308:	; bb8
                                 ;    1779         {
                                 ;    1780             /* Return number of bytes not a multiple of the programming size */
                                 ;    1781             return FLASH_ERROR_BYTES;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1781
000009F6 3C0502                  		MOV.B #02H, 05H[R0]
000009F9 38rrrr               W  		BRA L333
000009FC                         L309:	; bb15
000009FC 754E1F                  		MOV.L #0000001FH, R14
                                 ;    1782         }
                                 ;    1783         /* Check for an address on an erase boundary. */
                                 ;    1784         if( start_addr & (DF_ERASE_BLOCK_SIZE-1) )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1784
000009FF 06A10C0E03              		TST 0CH[R0].L, R14
00000A04 20rr                    		BEQ L316
00000A06                         L310:	; bb16
                                 ;    1785         {
                                 ;    1786             /* Return address not on a programming boundary */
                                 ;    1787             return FLASH_ERROR_ALIGNED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1787
00000A06 3C0501                  		MOV.B #01H, 05H[R0]
00000A09 38rrrr               W  		BRA L333
00000A0C                         L311:	; bb24
                                 ;    1788         }
                                 ;    1789     }
                                 ;    1790     else
                                 ;    1791     {
                                 ;    1792         /* This function is only for data flash blocks. */
                                 ;    1793         return FLASH_ERROR_ADDRESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1793
00000A0C 3C0503                  		MOV.B #03H, 05H[R0]
00000A0F 38rrrr               W  		BRA L333
00000A12                         L312:	; bb29
00000A12 A889                    		MOV.L 0CH[R0], R1
00000A14 7701FF7F10              		CMP #00107FFFH, R1
00000A19 24rr                    		BGTU L314
00000A1B                         L313:	; bb33
00000A1B F80601                  		MOV.L #00000001H, [R0]
00000A1E 08                   S  		BRA L315
00000A1F                         L314:	; bb34
00000A1F F80600                  		MOV.L #00000000H, [R0]
00000A22                         L315:	; bb35
00000A22 EC01                    		MOV.L [R0], R1
00000A24 6101                    		CMP #00H, R1
00000A26 21rr                    		BNE L307
00000A28 2Err                 B  		BRA L311
00000A2A                         L316:	; bb41
00000A2A 6611                    		MOV.L #00000001H, R1
                                 ;    1794     }
                                 ;    1795 
                                 ;    1796     /* Attempt to grab state */
                                 ;    1797     if( flash_grab_state(FLASH_ERASING) != FLASH_SUCCESS )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1797
00000A2C 39rrrr               W  		BSR __$flash_grab_state
00000A2F 6101                    		CMP #00H, R1
00000A31 10                   S  		BEQ L318
00000A32                         L317:	; bb42
                                 ;    1798     {
                                 ;    1799         /* Another operation is already in progress */
                                 ;    1800         return FLASH_BUSY;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1800
00000A32 3C0505                  		MOV.B #05H, 05H[R0]
00000A35 2Err                 B  		BRA L333
00000A37                         L318:	; bb49
                                 ;    1801     }
                                 ;    1802     
                                 ;    1803     /* Set current FCU mode to data flash PE */
                                 ;    1804     g_current_mode = FLD_PE_MODE;   
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1804
00000A37 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000A3D F8E402                  		MOV.B #02H, [R14]
00000A40                         L319:	; bb49.split
                                 ;    1805 
                                 ;    1806     /* Enter ROM PE mode, check if operation successful */
                                 ;    1807     if( enter_pe_mode(start_addr) != FLASH_SUCCESS)        
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1807
00000A40 A889                    		MOV.L 0CH[R0], R1
00000A42 39rrrr               W  		BSR __$enter_pe_mode
00000A45 6101                    		CMP #00H, R1
00000A47 20rr                    		BEQ L329
00000A49                         L320:	; bb51
                                 ;    1808     {
                                 ;    1809         /* Make sure part is in ROM read mode. */
                                 ;    1810         exit_pe_mode(start_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1810
00000A49 A889                    		MOV.L 0CH[R0], R1
00000A4B 39rrrr               W  		BSR __$exit_pe_mode
00000A4E                         L321:	; bb51.split
                                 ;    1811 
                                 ;    1812         /* Release state */
                                 ;    1813         flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1813
00000A4E 39rrrr               W  		BSR __$flash_release_state
00000A51                         L322:	; bb51.split2
                                 ;    1814         
                                 ;    1815         /* Return FLASH_FAILURE, operation failure */
                                 ;    1816         return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1816
00000A51 3C0506                  		MOV.B #06H, 05H[R0]
00000A54 2Err                 B  		BRA L333
00000A56                         L323:	; bb61
                                 ;    1817     }
                                 ;    1818 
                                 ;    1819     /* Erase real data flash blocks until the 'fake' block is erased .*/
                                 ;    1820     while(0 < bytes) {
                                 ;    1821 
                                 ;    1822         /* Send FCU command to erase block */
                                 ;    1823         result = flash_erase_command((FCU_BYTE_PTR)start_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1823
00000A56 39rrrr               W  		BSR __$flash_erase_command
00000A59 8181                    		MOV.B R1, 06H[R0]
00000A5B                         L324:	; bb61.split
                                 ;    1824 
                                 ;    1825         /* Advance pointer to next block */
                                 ;    1826         start_addr += DF_ERASE_BLOCK_SIZE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1826
00000A5B A889                    		MOV.L 0CH[R0], R1
00000A5D 711120                  		ADD #20H, R1
00000A60 A089                    		MOV.L R1, 0CH[R0]
00000A62                         L325:	; bb61.split3
                                 ;    1827 
                                 ;    1828         /* Subtract off bytes erased */
                                 ;    1829         bytes -= DF_ERASE_BLOCK_SIZE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1829
00000A62 A881                    		MOV.L 08H[R0], R1
00000A64 7111E0                  		ADD #0FFFFFFE0H, R1
00000A67 A081                    		MOV.L R1, 08H[R0]
00000A69                         L326:	; bb61.split4
                                 ;    1830 
                                 ;    1831 #if defined(FLASH_API_RX_CFG_DATA_FLASH_BGO)
                                 ;    1832         /* Set global variables so that erase can continue in ISR. */
                                 ;    1833         g_bgo_flash_addr = start_addr;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1833
00000A69 FBE2rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R14
00000A6F E10E03                  		MOV.L 0CH[R0], [R14]
00000A72                         L327:	; bb61.split5
                                 ;    1834         g_bgo_bytes = bytes;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1834
00000A72 FBE2rrrrrrrr            		MOV.L #__$g_bgo_bytes, R14
00000A78 E10E02                  		MOV.L 08H[R0], [R14]
00000A7B                         L328:	; bb61.split6
                                 ;    1835 
                                 ;    1836         /* Return, check result and continue erasure later in ISR */
                                 ;    1837         return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1837
00000A7B 3C0500                  		MOV.B #00H, 05H[R0]
00000A7E 2Err                 B  		BRA L333
00000A80                         L329:	; bb72
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1820
00000A80 A881                    		MOV.L 08H[R0], R1
00000A82 6101                    		CMP #00H, R1
00000A84 A889                    		MOV.L 0CH[R0], R1
00000A86 21rr                    		BNE L323
00000A88                         L330:	; bb77
                                 ;    1838 #endif    
                                 ;    1839     }
                                 ;    1840 
                                 ;    1841     /* Leave Program/Erase Mode */
                                 ;    1842     exit_pe_mode(start_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1842
00000A88 39rrrr               W  		BSR __$exit_pe_mode
00000A8B                         L331:	; bb77.split
                                 ;    1843 
                                 ;    1844     /* Release state */
                                 ;    1845     flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1845
00000A8B 39rrrr               W  		BSR __$flash_release_state
00000A8E                         L332:	; bb77.split7
                                 ;    1846 
                                 ;    1847     /* Return erase result */
                                 ;    1848     return result;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1848
00000A8E C5000605                		MOV.B 06H[R0], 05H[R0]
00000A92                         L333:	; bb81
00000A92 C5000507                		MOV.B 05H[R0], 07H[R0]
                                 ;    1849 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1849
00000A96 B189                    		MOVU.B 07H[R0], R1
00000A98 6704                    		RTSD #10H
00000A9A                         __$flash_erase_command:
                                 		.STACK	__$flash_erase_command=24
                                 ;    1850 /******************************************************************************
                                 ;    1851 End of function  R_FlashEraseRange
                                 ;    1852 ******************************************************************************/
                                 ;    1853 #endif /* defined(DF_GROUPED_BLOCKS) */
                                 ;    1854 
                                 ;    1855 /******************************************************************************
                                 ;    1856 * Function Name: flash_erase_command
                                 ;    1857 * Description  : Issues the FCU command to erase a flash block
                                 ;    1858 *                NOTE: This function MUST execute from in RAM for 'ROM Area' 
                                 ;    1859 *                programming, but if you are ONLY doing Data Flash programming,
                                 ;    1860 *                this function can reside and execute in Flash.
                                 ;    1861 * Arguments    : erase_addr - 
                                 ;    1862 *                    An address in the block to be erased
                                 ;    1863 * Return Value : FLASH_SUCCESS - 
                                 ;    1864 *                    Operation Successful
                                 ;    1865 *                FLASH_FAILURE - 
                                 ;    1866 *                    Operation Failed
                                 ;    1867 ******************************************************************************/
                                 ;    1868 static uint8_t flash_erase_command (FCU_BYTE_PTR const erase_addr)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1868
00000A9A 7100EC                  		ADD #0FFFFFFECH, R0
00000A9D A101                    		MOV.L R1, 10H[R0]
                                 ;    1869 {
                                 ;    1870     /* Declare timer wait count variable */
                                 ;    1871     volatile int32_t wait_cnt;
                                 ;    1872     /* Declare erase operation result container variable */
                                 ;    1873     uint8_t result = FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1873
00000A9F 3C0E00                  		MOV.B #00H, 0EH[R0]
00000AA2                         L335:	; entry.split
                                 ;    1874 
                                 ;    1875     /* Send the FCU Command */
                                 ;    1876     *erase_addr = 0x20;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1876
00000AA2 A901                    		MOV.L 10H[R0], R1
00000AA4 F81420                  		MOV.B #20H, [R1]
00000AA7                         L336:	; entry.split1
                                 ;    1877     *erase_addr = 0xD0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1877
00000AA7 A901                    		MOV.L 10H[R0], R1
00000AA9 F814D0                  		MOV.B #0D0H, [R1]
00000AAC                         L337:	; entry.split2
                                 ;    1878 
                                 ;    1879 #if defined(FLASH_API_RX_CFG_ROM_BGO)
                                 ;    1880     if( g_current_mode == ROM_PE_MODE )
                                 ;    1881     {
                                 ;    1882         /* Return, check result later in ISR */
                                 ;    1883         return FLASH_SUCCESS;
                                 ;    1884     }
                                 ;    1885 #endif    
                                 ;    1886     
                                 ;    1887 #if defined(FLASH_API_RX_CFG_DATA_FLASH_BGO)
                                 ;    1888     if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1888
00000AAC FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000AB2 58EE                    		MOVU.B [R14], R14
00000AB4 612E                    		CMP #02H, R14
00000AB6 18                   S  		BNE L339
00000AB7                         L338:	; bb6
                                 ;    1889     {
                                 ;    1890         /* Return, check result later in ISR */
                                 ;    1891         return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1891
00000AB7 3C0700                  		MOV.B #00H, 07H[R0]
00000ABA 2Err                 B  		BRA L352
00000ABC                         L339:	; bb12
                                 ;    1892     }
                                 ;    1893 #endif    
                                 ;    1894 
                                 ;    1895     /* Set the wait counter timeout duration */
                                 ;    1896     wait_cnt = WAIT_MAX_ERASE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1896
00000ABC F9020200D0DD06          		MOV.L #06DDD000H, 08H[R0]
00000AC3 2Err                 B  		BRA L344
00000AC5                         L340:	; bb13
                                 ;    1897 
                                 ;    1898     /* Wait while FCU operation is in progress */
                                 ;    1899     while(FLASH.FSTATR0.BIT.FRDY == 0)
                                 ;    1900     {
                                 ;    1901         /* Decrement the wait counter */
                                 ;    1902         wait_cnt--;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1902
00000AC5 A881                    		MOV.L 08H[R0], R1
00000AC7 6011                    		SUB #01H, R1
00000AC9 A081                    		MOV.L R1, 08H[R0]
00000ACB                         L341:	; bb13.split
                                 ;    1903         
                                 ;    1904         /* Check if the wait counter has reached zero */
                                 ;    1905         if(wait_cnt == 0){
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1905
00000ACB A881                    		MOV.L 08H[R0], R1
00000ACD 6101                    		CMP #00H, R1
00000ACF 18                   S  		BNE L344
00000AD0                         L342:	; bb17
                                 ;    1906 
                                 ;    1907             /* Maximum timeout duration for erasing a ROM block has 
                                 ;    1908                elapsed, assuming operation failure - reset the FCU */
                                 ;    1909             flash_reset();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1909
00000AD0 39rrrr               W  		BSR __$flash_reset
00000AD3                         L343:	; bb17.split
                                 ;    1910 
                                 ;    1911             /* Return FLASH_FAILURE, operation failure */
                                 ;    1912             return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1912
00000AD3 3C0706                  		MOV.B #06H, 07H[R0]
00000AD6 2Err                 B  		BRA L352
00000AD8                         L344:	; bb24
00000AD8 754E80                  		MOV.L #00000080H, R14
00000ADB FBFEB0FF7F              		MOV.L #007FFFB0H, R15
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1899
00000AE0 50FE                    		AND [R15].UB, R14
00000AE2 687E                    		SHLR #07H, R14
00000AE4 610E                    		CMP #00H, R14
00000AE6 20rr                    		BEQ L340
00000AE8                         L345:	; bb32
00000AE8 FBEEB0FF7F              		MOV.L #007FFFB0H, R14
                                 ;    1913         }
                                 ;    1914     }
                                 ;    1915 
                                 ;    1916     /* Check if erase operation was successful by checking 
                                 ;    1917        bit 'ERSERR' (bit5) and 'ILGLERR' (bit 6) of register 'FSTATR0' */
                                 ;    1918     /* Check FCU error */
                                 ;    1919     if((FLASH.FSTATR0.BIT.ILGLERR == 1) || (FLASH.FSTATR0.BIT.ERSERR  == 1)) 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1919
00000AED 58EE                    		MOVU.B [R14], R14
00000AEF 686E                    		SHLR #06H, R14
00000AF1 641E                    		AND #01H, R14
00000AF3 611E                    		CMP #01H, R14
00000AF5 20rr                    		BEQ L348
00000AF7 08                   S  		BRA L347
00000AF8                         L346:	; bb33
                                 ;    1920     {
                                 ;    1921         result = FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1921
00000AF8 3C0E06                  		MOV.B #06H, 0EH[R0]
00000AFB 2Err                 B  		BRA L351
00000AFD                         L347:	; bb40
00000AFD FBEEB0FF7F              		MOV.L #007FFFB0H, R14
00000B02 58EE                    		MOVU.B [R14], R14
00000B04 685E                    		SHLR #05H, R14
00000B06 641E                    		AND #01H, R14
00000B08 611E                    		CMP #01H, R14
00000B0A 18                   S  		BNE L349
00000B0B                         L348:	; bb47
00000B0B F80601                  		MOV.L #00000001H, [R0]
00000B0E 08                   S  		BRA L350
00000B0F                         L349:	; bb48
00000B0F F80600                  		MOV.L #00000000H, [R0]
00000B12                         L350:	; bb49
00000B12 EC01                    		MOV.L [R0], R1
00000B14 6101                    		CMP #00H, R1
00000B16 21rr                    		BNE L346
00000B18                         L351:	; bb54
                                 ;    1922     }
                                 ;    1923  
                                 ;    1924     /* Return erase result */
                                 ;    1925     return result;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1925
00000B18 C5000E07                		MOV.B 0EH[R0], 07H[R0]
00000B1C                         L352:	; bb57
00000B1C C500070F                		MOV.B 07H[R0], 0FH[R0]
                                 ;    1926 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1926
00000B20 B389                    		MOVU.B 0FH[R0], R1
00000B22 6705                    		RTSD #14H
00000B24                         _R_FlashWrite:
                                 		.STACK	_R_FlashWrite=32
                                 ;    1927 /******************************************************************************
                                 ;    1928 End of function  flash_erase_command
                                 ;    1929 ******************************************************************************/
                                 ;    1930 
                                 ;    1931 /******************************************************************************
                                 ;    1932 * Function Name: R_FlashWrite
                                 ;    1933 * Description  : Writes bytes into flash.
                                 ;    1934 *                NOTE: This function MUST execute from in RAM for 'ROM Area' 
                                 ;    1935 *                programming, but if you are ONLY doing Data Flash programming,
                                 ;    1936 *                this function can reside and execute in Flash.
                                 ;    1937 * Arguments    : flash_addr - 
                                 ;    1938 *                    Flash address location to write to. This address 
                                 ;    1939 *                    must be on a program boundary (e.g. RX62N has 
                                 ;    1940 *                    256-byte ROM writes and 8-byte DF writes).
                                 ;    1941 *                buffer_addr - 
                                 ;    1942 *                    Address location of data buffer to write into flash.
                                 ;    1943 *                bytes - 
                                 ;    1944 *                    The number of bytes to write. You must always pass a 
                                 ;    1945 *                    multiple of the programming size (e.g. RX62N has 
                                 ;    1946 *                    256-byte ROM writes and 8-byte DF writes).
                                 ;    1947 * Return Value : FLASH_SUCCESS - 
                                 ;    1948 *                    Operation Successful
                                 ;    1949 *                FLASH_FAILURE - 
                                 ;    1950 *                    Operation Failed
                                 ;    1951 *                FLASH_ERROR_ALIGNED - 
                                 ;    1952 *                    Flash address was not on correct boundary
                                 ;    1953 *                FLASH_ERROR_BYTES - 
                                 ;    1954 *                    Number of bytes did not match programming size of ROM or DF
                                 ;    1955 *                FLASH_ERROR_ADDRESS - 
                                 ;    1956 *                    Invalid address
                                 ;    1957 *                FLASH_ERROR_BOUNDARY - 
                                 ;    1958 *                    (ROM) Cannot write across flash areas.                                       
                                 ;    1959 *                FLASH_BUSY - 
                                 ;    1960 *                    Flash is busy with another operation
                                 ;    1961 ******************************************************************************/
                                 ;    1962 uint8_t R_FlashWrite (uint32_t flash_addr, 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1962
00000B24 7100E4                  		ADD #0FFFFFFE4H, R0
00000B27 A181                    		MOV.L R1, 18H[R0]
00000B29 A10A                    		MOV.L R2, 14H[R0]
00000B2B 920B                    		MOV.W R3, 12H[R0]
                                 ;    1963                       uint32_t buffer_addr, 
                                 ;    1964                       uint16_t bytes)
                                 ;    1965 {
                                 ;    1966     /* Declare result container and number of bytes to write variables */
                                 ;    1967     uint8_t  result = FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1967
00000B2D 3C0700                  		MOV.B #00H, 07H[R0]
00000B30                         L354:	; entry.split
                                 ;    1968     uint32_t num_byte_to_write;    
                                 ;    1969 #ifdef FLASH_API_RX_CFG_FLASH_TO_FLASH 
                                 ;    1970     /* Local variable when using FLASH_API_RX_CFG_FLASH_TO_FLASH */
                                 ;    1971     uint16_t i; 
                                 ;    1972 #endif    
                                 ;    1973         
                                 ;    1974     /* Take off upper byte since for programming/erase addresses for ROM are 
                                 ;    1975         the same as read addresses except upper byte is masked off to 0's.
                                 ;    1976         Data Flash addresses are not affected. */
                                 ;    1977     flash_addr &= 0x00FFFFFF;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1977
00000B30 A981                    		MOV.L 18H[R0], R1
00000B32 7421FFFFFF00            		AND #00FFFFFFH, R1
00000B38 A181                    		MOV.L R1, 18H[R0]
00000B3A                         L355:	; entry.split1
                                 ;    1978 
                                 ;    1979     /* ROM area or Data Flash area - Check for DF first */  
                                 ;    1980     if( flash_addr >= DF_ADDRESS && (flash_addr < DF_ADDRESS + BSP_DATA_FLASH_SIZE_BYTES) )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1980
00000B3A A981                    		MOV.L 18H[R0], R1
00000B3C 7701FFFF0F              		CMP #000FFFFFH, R1
00000B41 24rr                    		BGTU L367
00000B43 2Err                 B  		BRA L369
00000B45                         L356:	; bb10
                                 ;    1981     {
                                 ;    1982         /* Check if the number of bytes were passed is a multiple of the 
                                 ;    1983            programming size for the data flash */
                                 ;    1984         if( bytes & (DF_PROGRAM_SIZE_SMALL-1) )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1984
00000B45 BA09                    		MOVU.W 12H[R0], R1
00000B47 7C01                    		BTST #00H, R1
00000B49 10                   S  		BEQ L358
00000B4A                         L357:	; bb11
                                 ;    1985         {
                                 ;    1986             /* Return number of bytes not a multiple of the programming size */
                                 ;    1987             return FLASH_ERROR_BYTES;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1987
00000B4A 3C0602                  		MOV.B #02H, 06H[R0]
00000B4D 38rrrr               W  		BRA L435
00000B50                         L358:	; bb19
                                 ;    1988         }
                                 ;    1989         /* Check for an address on a programming boundary. */
                                 ;    1990         if( flash_addr & (DF_PROGRAM_SIZE_SMALL-1) )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1990
00000B50 A981                    		MOV.L 18H[R0], R1
00000B52 7C01                    		BTST #00H, R1
00000B54 20rr                    		BEQ L371
00000B56                         L359:	; bb20
                                 ;    1991         {
                                 ;    1992             /* Return address not on a programming boundary */
                                 ;    1993             return FLASH_ERROR_ALIGNED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1993
00000B56 3C0601                  		MOV.B #01H, 06H[R0]
00000B59 38rrrr               W  		BRA L435
00000B5C                         L360:	; bb29
                                 ;    1994         }
                                 ;    1995     }
                                 ;    1996     /* Check for ROM area */
                                 ;    1997     else if(    (flash_addr >= ROM_PE_ADDR)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",1997
00000B5C A981                    		MOV.L 18H[R0], R1
00000B5E 7401FFFFEF00            		CMP #00EFFFFFH, R1
00000B64 24rr                    		BGTU L363
00000B66 2Err                 B  		BRA L365
00000B68                         L361:	; bb30
                                 ;    1998             &&  (flash_addr < ROM_PE_ADDR + BSP_ROM_SIZE_BYTES) )
                                 ;    1999     {
                                 ;    2000         /* First make sure that ROM operations are enabled. */
                                 ;    2001 #ifndef FLASH_API_RX_CFG_ENABLE_ROM_PROGRAMMING
                                 ;    2002         /* ROM operations are not enabled! Enable them in r_flash_api_rx_config.h */
                                 ;    2003         return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2003
00000B68 3C0606                  		MOV.B #06H, 06H[R0]
00000B6B 38rrrr               W  		BRA L435
00000B6E                         L362:	; bb153
                                 ;    2004 #endif
                                 ;    2005 
                                 ;    2006         /* Check if the number of bytes were passed is a multiple of the 
                                 ;    2007            programming size for ROM */
                                 ;    2008         if( bytes & (ROM_PROGRAM_SIZE-1) )
                                 ;    2009         {
                                 ;    2010             /* Return number of bytes not a multiple of the programming size */
                                 ;    2011             return FLASH_ERROR_BYTES;
                                 ;    2012         }
                                 ;    2013 
                                 ;    2014         /* Check for an address on a programming boundary. */
                                 ;    2015         if( flash_addr & (ROM_PROGRAM_SIZE-1))
                                 ;    2016         {
                                 ;    2017             /* Return address not on a ROM programming byte boundary */
                                 ;    2018             return FLASH_ERROR_ALIGNED; 
                                 ;    2019         }
                                 ;    2020 
                                 ;    2021         /* Check for attempts to program over flash area boundaries. These 
                                 ;    2022            boundaries are defined in r_flash_api_rx*MCU Group*.h as 'ROM_AREA_#'. */
                                 ;    2023         if (((flash_addr < (ROM_AREA_0)) && ((flash_addr + bytes) > ROM_AREA_0))
                                 ;    2024 #if defined(ROM_AREA_1)
                                 ;    2025            || ((flash_addr < (ROM_AREA_1))  && ((flash_addr + bytes) > ROM_AREA_1))
                                 ;    2026 #endif
                                 ;    2027 #if defined(ROM_AREA_2)
                                 ;    2028            || ((flash_addr < (ROM_AREA_2))  && ((flash_addr + bytes) > ROM_AREA_2))
                                 ;    2029 #endif
                                 ;    2030 #if defined(ROM_AREA_3)
                                 ;    2031            || ((flash_addr < (ROM_AREA_3))  && ((flash_addr + bytes) > ROM_AREA_3))
                                 ;    2032 #endif
                                 ;    2033             )
                                 ;    2034         {
                                 ;    2035             /* Return cannot write across a flash area boundary */
                                 ;    2036             return FLASH_ERROR_BOUNDARY;
                                 ;    2037         } 
                                 ;    2038 
                                 ;    2039         /* Make sure write is not going over end of flash. */
                                 ;    2040         if ((flash_addr + bytes) > (ROM_PE_ADDR + BSP_ROM_SIZE_BYTES))
                                 ;    2041         {
                                 ;    2042             return FLASH_ERROR_BOUNDARY;
                                 ;    2043         }
                                 ;    2044     }
                                 ;    2045     else 
                                 ;    2046     {
                                 ;    2047         /* Return invalid flash address */
                                 ;    2048         return FLASH_ERROR_ADDRESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2048
00000B6E 3C0603                  		MOV.B #03H, 06H[R0]
00000B71 38rrrr               W  		BRA L435
00000B74                         L363:	; bb159
00000B74 A981                    		MOV.L 18H[R0], R1
00000B76 7401FFFFFF00            		CMP #00FFFFFFH, R1
00000B7C 24rr                    		BGTU L365
00000B7E                         L364:	; bb164
00000B7E F80601                  		MOV.L #00000001H, [R0]
00000B81 08                   S  		BRA L366
00000B82                         L365:	; bb165
00000B82 F80600                  		MOV.L #00000000H, [R0]
00000B85                         L366:	; bb166
00000B85 EC01                    		MOV.L [R0], R1
00000B87 6101                    		CMP #00H, R1
00000B89 21rr                    		BNE L361
00000B8B 2Err                 B  		BRA L362
00000B8D                         L367:	; bb175
00000B8D A981                    		MOV.L 18H[R0], R1
00000B8F 7701FF7F10              		CMP #00107FFFH, R1
00000B94 24rr                    		BGTU L369
00000B96                         L368:	; bb179
00000B96 F80601                  		MOV.L #00000001H, [R0]
00000B99 08                   S  		BRA L370
00000B9A                         L369:	; bb180
00000B9A F80600                  		MOV.L #00000000H, [R0]
00000B9D                         L370:	; bb181
00000B9D EC01                    		MOV.L [R0], R1
00000B9F 6101                    		CMP #00H, R1
00000BA1 21rr                    		BNE L356
00000BA3 2Err                 B  		BRA L360
00000BA5                         L371:	; bb187
00000BA5 6621                    		MOV.L #00000002H, R1
                                 ;    2049     }
                                 ;    2050     
                                 ;    2051     /* Attempt to grab state */
                                 ;    2052     if( flash_grab_state(FLASH_WRITING) != FLASH_SUCCESS )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2052
00000BA7 39rrrr               W  		BSR __$flash_grab_state
00000BAA 6101                    		CMP #00H, R1
00000BAC 10                   S  		BEQ L373
00000BAD                         L372:	; bb188
                                 ;    2053     {
                                 ;    2054         /* Another operation is already in progress */
                                 ;    2055         return FLASH_BUSY;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2055
00000BAD 3C0605                  		MOV.B #05H, 06H[R0]
00000BB0 38rrrr               W  		BRA L435
00000BB3                         L373:	; bb196
                                 ;    2056     }
                                 ;    2057     
                                 ;    2058     /* Do we want to program a DF area or ROM area? */
                                 ;    2059     if( flash_addr < g_flash_BlockAddresses[ROM_NUM_BLOCKS-1] )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2059
00000BB3 FBE2rrrrrrrr            		MOV.L #_g_flash_BlockAddresses, R14
00000BB9 A981                    		MOV.L 18H[R0], R1
00000BBB 0685E135                		CMP 0D4H[R14].L, R1
00000BBF 22rr                    		BGEU L375
00000BC1                         L374:	; bb197
                                 ;    2060     {
                                 ;    2061         /* Set current FCU mode to data flash PE */
                                 ;    2062         g_current_mode = FLD_PE_MODE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2062
00000BC1 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000BC7 F8E402                  		MOV.B #02H, [R14]
00000BCA 08                   S  		BRA L376
00000BCB                         L375:	; bb198
                                 ;    2063     }
                                 ;    2064     else
                                 ;    2065     {
                                 ;    2066         /* Set FCU to ROM PE mode */
                                 ;    2067         g_current_mode = ROM_PE_MODE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2067
00000BCB FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000BD1 F8E401                  		MOV.B #01H, [R14]
00000BD4                         L376:	; bb205
                                 ;    2068     }     
                                 ;    2069     
                                 ;    2070 #ifdef FLASH_API_RX_CFG_FLASH_TO_FLASH    
                                 ;    2071     /* Are we doing a ROM to ROM or DF to DF transfer? */
                                 ;    2072     if( (buffer_addr >= ROM_PE_ADDR) ||
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2072
00000BD4 A909                    		MOV.L 14H[R0], R1
00000BD6 7401FFFFEF00            		CMP #00EFFFFFH, R1
00000BDC 25rr                  * 		BGTU L391
         38rrrr                  
00000BE1 2Err                 B  		BRA L386
00000BE3                         L377:	; bb206
                                 ;    2073         ((buffer_addr >= DF_ADDRESS) && (buffer_addr < (DF_ADDRESS + BSP_DATA_FLASH_SIZE_BYTES))))
                                 ;    2074     {
                                 ;    2075         /* Buffering is needed. */
                                 ;    2076         /* Get maximum programming size that can currently be used. */
                                 ;    2077         num_byte_to_write = flash_get_program_size(bytes, flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2077
00000BE3 A982                    		MOV.L 18H[R0], R2
00000BE5 BA09                    		MOVU.W 12H[R0], R1
00000BE7 39rrrr               W  		BSR __$flash_get_program_size
00000BEA A081                    		MOV.L R1, 08H[R0]
00000BEC                         L378:	; bb206.split
                                 ;    2078                        
                                 ;    2079         /* Copy over first buffer */
                                 ;    2080         for(i = 0; i < num_byte_to_write; i++)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2080
00000BEC 3D0700                  		MOV.W #0000H, 0EH[R0]
00000BEF 2Err                 B  		BRA L380
00000BF1                         L379:	; bb211
                                 ;    2081         {
                                 ;    2082             /* Copy over each byte */
                                 ;    2083             g_temp_array[i] = *((uint8_t *)(buffer_addr+i));             
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2083
00000BF1 B989                    		MOVU.W 0EH[R0], R1
00000BF3 A90A                    		MOV.L 14H[R0], R2
00000BF5 FEC21E                  		MOVU.B [R2,R1], R14
00000BF8 FBF2rrrrrrrr            		MOV.L #__$g_temp_array, R15
00000BFE FE0F1E                  		MOV.B R14, [R15,R1]
00000C01 9989                    		MOV.W 0EH[R0], R1
00000C03 6211                    		ADD #01H, R1
00000C05 9189                    		MOV.W R1, 0EH[R0]
00000C07                         L380:	; bb223
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2080
00000C07 B989                    		MOVU.W 0EH[R0], R1
00000C09 06850102                		CMP 08H[R0].L, R1
00000C0D 23rr                    		BLTU L379
00000C0F                         L381:	; bb231
                                 ;    2084         }
                                 ;    2085 
                                 ;    2086         /* Check size */
                                 ;    2087         if( bytes == num_byte_to_write )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2087
00000C0F BA09                    		MOVU.W 12H[R0], R1
00000C11 06850102                		CMP 08H[R0].L, R1
00000C15 21rr                    		BNE L384
00000C17                         L382:	; bb232
                                 ;    2088         {        
                                 ;    2089             /* Since we were able to put the entire buffer in RAM we can
                                 ;    2090                just change the buffer pointer and go on as usual. */
                                 ;    2091             g_flash_to_flash_op = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2091
00000C17 FBE2rrrrrrrr            		MOV.L #__$g_flash_to_flash_op, R14
00000C1D F8E400                  		MOV.B #00H, [R14]
00000C20                         L383:	; bb232.split
                                 ;    2092             
                                 ;    2093             /* Set new buffer address */
                                 ;    2094             buffer_addr = (uint32_t)&g_temp_array[0];
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2094
00000C20 FB12rrrrrrrr            		MOV.L #__$g_temp_array, R1
00000C26 A109                    		MOV.L R1, 14H[R0]
00000C28 2Err                 B  		BRA L394
00000C2A                         L384:	; bb233
                                 ;    2095         }        
                                 ;    2096         else
                                 ;    2097         {
                                 ;    2098             /* Set FLASH_API_RX_CFG_FLASH_TO_FLASH flag */
                                 ;    2099             g_flash_to_flash_op = 1;   
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2099
00000C2A FBE2rrrrrrrr            		MOV.L #__$g_flash_to_flash_op, R14
00000C30 F8E401                  		MOV.B #01H, [R14]
00000C33 2Err                 B  		BRA L394
00000C35                         L385:	; bb241
                                 ;    2100         }        
                                 ;    2101     }
                                 ;    2102     else
                                 ;    2103     {
                                 ;    2104         /* No need to buffer */
                                 ;    2105         g_flash_to_flash_op = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2105
00000C35 FBE2rrrrrrrr            		MOV.L #__$g_flash_to_flash_op, R14
00000C3B F8E400                  		MOV.B #00H, [R14]
00000C3E 2Err                 B  		BRA L394
00000C40                         L386:	; bb246
00000C40 A909                    		MOV.L 14H[R0], R1
00000C42 7701000010              		CMP #00100000H, R1
00000C47 23rr                    		BLTU L389
00000C49                         L387:	; bb250
00000C49 A909                    		MOV.L 14H[R0], R1
00000C4B 7701FF7F10              		CMP #00107FFFH, R1
00000C50 24rr                    		BGTU L389
00000C52                         L388:	; bb254
00000C52 F80601                  		MOV.L #00000001H, [R0]
00000C55 08                   S  		BRA L390
00000C56                         L389:	; bb255
00000C56 F80600                  		MOV.L #00000000H, [R0]
00000C59                         L390:	; bb256
00000C59 EC01                    		MOV.L [R0], R1
00000C5B 6101                    		CMP #00H, R1
00000C5D 10                   S  		BEQ L392
00000C5E                         L391:	; bb260
00000C5E F80601                  		MOV.L #00000001H, [R0]
00000C61 08                   S  		BRA L393
00000C62                         L392:	; bb261
00000C62 F80600                  		MOV.L #00000000H, [R0]
00000C65                         L393:	; bb262
00000C65 EC01                    		MOV.L [R0], R1
00000C67 6101                    		CMP #00H, R1
00000C69 3Brrrr               W  		BNE L377
00000C6C 2Err                 B  		BRA L385
00000C6E                         L394:	; bb268
                                 ;    2106     }
                                 ;    2107               
                                 ;    2108 #endif /* FLASH_API_RX_CFG_FLASH_TO_FLASH */
                                 ;    2109 
                                 ;    2110     /* Enter PE mode, check if operation is successful */
                                 ;    2111     if( enter_pe_mode(flash_addr) != FLASH_SUCCESS)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2111
00000C6E A981                    		MOV.L 18H[R0], R1
00000C70 39rrrr               W  		BSR __$enter_pe_mode
00000C73 6101                    		CMP #00H, R1
00000C75 20rr                    		BEQ L398
00000C77                         L395:	; bb269
                                 ;    2112     {
                                 ;    2113         /* Make sure part is in ROM read mode. */
                                 ;    2114         exit_pe_mode(flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2114
00000C77 A981                    		MOV.L 18H[R0], R1
00000C79 39rrrr               W  		BSR __$exit_pe_mode
00000C7C                         L396:	; bb269.split
                                 ;    2115 
                                 ;    2116         /* Release state */
                                 ;    2117         flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2117
00000C7C 39rrrr               W  		BSR __$flash_release_state
00000C7F                         L397:	; bb269.split2
                                 ;    2118                 
                                 ;    2119         /* Return operation failure */
                                 ;    2120         return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2120
00000C7F 3C0606                  		MOV.B #06H, 06H[R0]
00000C82 38rrrr               W  		BRA L435
00000C85                         L398:	; bb278
00000C85 FBEEB4FF7F              		MOV.L #007FFFB4H, R14
                                 ;    2121     }
                                 ;    2122     
                                 ;    2123     #ifdef  FLASH_API_RX_CFG_IGNORE_LOCK_BITS
                                 ;    2124     /* Cancel the ROM Protect feature 
                                 ;    2125        NOTE: If you are using block locking feature to protect your data,
                                 ;    2126        then comment out 'FLASH_API_RX_CFG_IGNORE_LOCK_BITS' in r_flash_api_rx_config.h */
                                 ;    2127     FLASH.FPROTR.WORD = 0x5501;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2127
00000C8A F8E90155                		MOV.W #5501H, [R14]
00000C8E 38rrrr               W  		BRA L431
00000C91                         L399:	; bb279
                                 ;    2128     #else
                                 ;    2129     /* Only disable lock bit protection if user has specified to 
                                 ;    2130        do so earlier */
                                 ;    2131     if( g_lock_bit_protection == false )
                                 ;    2132     {
                                 ;    2133         /* Cancel the ROM Protect feature */
                                 ;    2134         FLASH.FPROTR.WORD = 0x5501;    
                                 ;    2135     }       
                                 ;    2136     #endif
                                 ;    2137     
                                 ;    2138     /* Iterate while there are still bytes remaining to write */
                                 ;    2139     while( bytes )
                                 ;    2140     {
                                 ;    2141         /* Get maximum programming size that can currently be used. */
                                 ;    2142         num_byte_to_write = flash_get_program_size((uint32_t)bytes, flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2142
00000C91 A982                    		MOV.L 18H[R0], R2
00000C93 BA09                    		MOVU.W 12H[R0], R1
00000C95 39rrrr               W  		BSR __$flash_get_program_size
00000C98 A081                    		MOV.L R1, 08H[R0]
00000C9A                         L400:	; bb279.split
                                 ;    2143 
                                 ;    2144 #ifdef FLASH_API_RX_CFG_DATA_FLASH_BGO
                                 ;    2145         if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2145
00000C9A FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000CA0 58EE                    		MOVU.B [R14], R14
00000CA2 612E                    		CMP #02H, R14
00000CA4 21rr                    		BNE L404
00000CA6                         L401:	; bb285
                                 ;    2146         {
                                 ;    2147             /* At this point we are going to set some global variables which
                                 ;    2148                will continue on with write after these bytes are written. 
                                 ;    2149                I set these values before the actual first write because I was 
                                 ;    2150                getting an error when the flash ready interrupt was being called
                                 ;    2151                before these values were set. */        
                                 ;    2152             g_bgo_flash_addr = flash_addr + num_byte_to_write;               
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2152
00000CA6 A981                    		MOV.L 18H[R0], R1
00000CA8 06890102                		ADD 08H[R0].L, R1
00000CAC FBE2rrrrrrrr            		MOV.L #__$g_bgo_flash_addr, R14
00000CB2 E3E1                    		MOV.L R1, [R14]
00000CB4                         L402:	; bb285.split
                                 ;    2153             g_bgo_buffer_addr = buffer_addr + num_byte_to_write;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2153
00000CB4 A909                    		MOV.L 14H[R0], R1
00000CB6 06890102                		ADD 08H[R0].L, R1
00000CBA FBE2rrrrrrrr            		MOV.L #__$g_bgo_buffer_addr, R14
00000CC0 E3E1                    		MOV.L R1, [R14]
00000CC2                         L403:	; bb285.split3
                                 ;    2154             g_bgo_bytes = bytes - num_byte_to_write;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2154
00000CC2 BA09                    		MOVU.W 12H[R0], R1
00000CC4 06810102                		SUB 08H[R0].L, R1
00000CC8 FBE2rrrrrrrr            		MOV.L #__$g_bgo_bytes, R14
00000CCE E3E1                    		MOV.L R1, [R14]
00000CD0                         L404:	; bb302
                                 ;    2155         }        
                                 ;    2156 #endif
                                 ;    2157 
                                 ;    2158 #ifdef FLASH_API_RX_CFG_ROM_BGO
                                 ;    2159         if( g_current_mode == ROM_PE_MODE )
                                 ;    2160         {
                                 ;    2161             /* At this point we are going to set some global variables which
                                 ;    2162                will continue on with write after these bytes are written. 
                                 ;    2163                I set these values before the actual first write because I was 
                                 ;    2164                getting an error when the flash ready interrupt was being called
                                 ;    2165                before these values were set. */        
                                 ;    2166             g_bgo_flash_addr = flash_addr + num_byte_to_write;               
                                 ;    2167             g_bgo_buffer_addr = buffer_addr + num_byte_to_write;
                                 ;    2168             g_bgo_bytes = bytes - num_byte_to_write;
                                 ;    2169         }        
                                 ;    2170 #endif
                                 ;    2171 
                                 ;    2172         /* Call the Programming function, store the operation status in the
                                 ;    2173            container variable, result */
                                 ;    2174 #ifdef FLASH_API_RX_CFG_FLASH_TO_FLASH           
                                 ;    2175         if( g_flash_to_flash_op == 1 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2175
00000CD0 FBE2rrrrrrrr            		MOV.L #__$g_flash_to_flash_op, R14
00000CD6 58EE                    		MOVU.B [R14], R14
00000CD8 611E                    		CMP #01H, R14
00000CDA FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000CE0 58EE                    		MOVU.B [R14], R14
00000CE2 A981                    		MOV.L 18H[R0], R1
00000CE4 21rr                    		BNE L408
00000CE6                         L405:	; bb304
                                 ;    2176         {
                                 ;    2177             if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2177
00000CE6 5BEE                    		MOVU.B R14, R14
00000CE8 612E                    		CMP #02H, R14
00000CEA A883                    		MOV.L 08H[R0], R3
00000CEC 21rr                    		BNE L407
00000CEE                         L406:	; bb305
                                 ;    2178             {
                                 ;    2179                 result = data_flash_write( flash_addr, (uint32_t)&g_temp_array[0],
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2179
00000CEE FB22rrrrrrrr            		MOV.L #__$g_temp_array, R2
00000CF4 39rrrr               W  		BSR __$data_flash_write
00000CF7 8189                    		MOV.B R1, 07H[R0]
00000CF9 2Err                 B  		BRA L411
00000CFB                         L407:	; bb309
                                 ;    2180                                            num_byte_to_write);                
                                 ;    2181             }
                                 ;    2182             else
                                 ;    2183             {
                                 ;    2184                 result = rom_write( flash_addr, (uint32_t)&g_temp_array[0],
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2184
00000CFB FB22rrrrrrrr            		MOV.L #__$g_temp_array, R2
00000D01 39rrrr               W  		BSR __$rom_write
00000D04 8189                    		MOV.B R1, 07H[R0]
00000D06 2Err                 B  		BRA L411
00000D08                         L408:	; bb320
                                 ;    2185                                     num_byte_to_write);                
                                 ;    2186             }
                                 ;    2187         }
                                 ;    2188         else
                                 ;    2189         {
                                 ;    2190             if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2190
00000D08 5BEE                    		MOVU.B R14, R14
00000D0A 612E                    		CMP #02H, R14
00000D0C A883                    		MOV.L 08H[R0], R3
00000D0E A90A                    		MOV.L 14H[R0], R2
00000D10 18                   S  		BNE L410
00000D11                         L409:	; bb321
                                 ;    2191             {
                                 ;    2192                 result = data_flash_write( flash_addr, buffer_addr,
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2192
00000D11 39rrrr               W  		BSR __$data_flash_write
00000D14 8189                    		MOV.B R1, 07H[R0]
00000D16 08                   S  		BRA L411
00000D17                         L410:	; bb326
                                 ;    2193                                            num_byte_to_write);                
                                 ;    2194             }
                                 ;    2195             else
                                 ;    2196             {
                                 ;    2197                 result = rom_write( flash_addr, buffer_addr, 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2197
00000D17 39rrrr               W  		BSR __$rom_write
00000D1A 8189                    		MOV.B R1, 07H[R0]
00000D1C                         L411:	; bb343
                                 ;    2198                                     num_byte_to_write);     
                                 ;    2199             }
                                 ;    2200         }
                                 ;    2201 #else                                       
                                 ;    2202         if( g_current_mode == FLD_PE_MODE )
                                 ;    2203         {
                                 ;    2204             result = data_flash_write(flash_addr, buffer_addr, num_byte_to_write);
                                 ;    2205         }
                                 ;    2206         else
                                 ;    2207         {
                                 ;    2208             result = rom_write(flash_addr, buffer_addr, num_byte_to_write);
                                 ;    2209         }
                                 ;    2210 #endif                                       
                                 ;    2211 
                                 ;    2212         /* Check the container variable result for errors */
                                 ;    2213         if( result != FLASH_SUCCESS )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2213
00000D1C B189                    		MOVU.B 07H[R0], R1
00000D1E 6101                    		CMP #00H, R1
00000D20 3Brrrr               W  		BNE L432
00000D23                         L412:	; bb352
                                 ;    2214         {
                                 ;    2215             /* Data flash write error detected, break from flash write
                                 ;    2216                while loop prematurely */
                                 ;    2217             break;
                                 ;    2218         }
                                 ;    2219 
                                 ;    2220 #if defined(FLASH_API_RX_CFG_DATA_FLASH_BGO)
                                 ;    2221         if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2221
00000D23 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000D29 58EE                    		MOVU.B [R14], R14
00000D2B 612E                    		CMP #02H, R14
00000D2D 18                   S  		BNE L414
00000D2E                         L413:	; bb353
                                 ;    2222         {
                                 ;    2223             /* Return FLASH_SUCCESS, rest of programming will be done 
                                 ;    2224                in interrupt */
                                 ;    2225             return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2225
00000D2E 3C0600                  		MOV.B #00H, 06H[R0]
00000D31 38rrrr               W  		BRA L435
00000D34                         L414:	; bb360
                                 ;    2226         }
                                 ;    2227 #endif
                                 ;    2228 #if defined(FLASH_API_RX_CFG_ROM_BGO)            
                                 ;    2229         if( g_current_mode == ROM_PE_MODE )
                                 ;    2230         {
                                 ;    2231             /* Return FLASH_SUCCESS, rest of programming will be done 
                                 ;    2232                in interrupt */
                                 ;    2233             return FLASH_SUCCESS;
                                 ;    2234         }
                                 ;    2235 #endif 
                                 ;    2236 
                                 ;    2237 #if (!defined(FLASH_API_RX_CFG_ROM_BGO)) || (!defined(FLASH_API_RX_CFG_DATA_FLASH_BGO))
                                 ;    2238 
                                 ;    2239         /* Increment the flash address and the buffer address by the size
                                 ;    2240            of the transfer thats just completed */
                                 ;    2241         flash_addr += num_byte_to_write;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2241
00000D34 A981                    		MOV.L 18H[R0], R1
00000D36 06890102                		ADD 08H[R0].L, R1
00000D3A A181                    		MOV.L R1, 18H[R0]
00000D3C                         L415:	; bb360.split
                                 ;    2242         buffer_addr += num_byte_to_write;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2242
00000D3C A909                    		MOV.L 14H[R0], R1
00000D3E 06890102                		ADD 08H[R0].L, R1
00000D42 A109                    		MOV.L R1, 14H[R0]
00000D44                         L416:	; bb360.split4
                                 ;    2243         
                                 ;    2244         /* Decrement the number of bytes remaining by the size of the last
                                 ;    2245            flash write */
                                 ;    2246         bytes -= num_byte_to_write;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2246
00000D44 BA09                    		MOVU.W 12H[R0], R1
00000D46 06810102                		SUB 08H[R0].L, R1
00000D4A 9209                    		MOV.W R1, 12H[R0]
00000D4C                         L417:	; bb360.split5
                                 ;    2247                     
                                 ;    2248     #ifdef FLASH_API_RX_CFG_FLASH_TO_FLASH
                                 ;    2249         /* Check to see if we need to buffer more data */
                                 ;    2250         if( (bytes > 0) &&
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2250
00000D4C BA09                    		MOVU.W 12H[R0], R1
00000D4E 6101                    		CMP #00H, R1
00000D50 2Arr                    		BGT L427
00000D52 2Err                 B  		BRA L429
00000D54                         L418:	; bb373
                                 ;    2251             (g_flash_to_flash_op == 1) )
                                 ;    2252         {
                                 ;    2253             /* We must leave PE mode to transfer next buffer to RAM */
                                 ;    2254             exit_pe_mode(flash_addr);                
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2254
00000D54 A981                    		MOV.L 18H[R0], R1
00000D56 39rrrr               W  		BSR __$exit_pe_mode
00000D59                         L419:	; bb373.split
                                 ;    2255 
                                 ;    2256             /* Get maximum programming size that can currently be used. */
                                 ;    2257             num_byte_to_write = flash_get_program_size(bytes, flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2257
00000D59 A982                    		MOV.L 18H[R0], R2
00000D5B BA09                    		MOVU.W 12H[R0], R1
00000D5D 39rrrr               W  		BSR __$flash_get_program_size
00000D60 A081                    		MOV.L R1, 08H[R0]
00000D62                         L420:	; bb373.split6
                                 ;    2258 
                                 ;    2259             /* Copy over up to next bytes */
                                 ;    2260             for(i = 0; i < num_byte_to_write; i++)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2260
00000D62 3D0700                  		MOV.W #0000H, 0EH[R0]
00000D65 2Err                 B  		BRA L422
00000D67                         L421:	; bb379
                                 ;    2261             {
                                 ;    2262                 /* Copy over each byte */
                                 ;    2263                 g_temp_array[i] = *((uint8_t *)(buffer_addr+i));             
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2263
00000D67 B989                    		MOVU.W 0EH[R0], R1
00000D69 A90A                    		MOV.L 14H[R0], R2
00000D6B FEC21E                  		MOVU.B [R2,R1], R14
00000D6E FBF2rrrrrrrr            		MOV.L #__$g_temp_array, R15
00000D74 FE0F1E                  		MOV.B R14, [R15,R1]
00000D77 9989                    		MOV.W 0EH[R0], R1
00000D79 6211                    		ADD #01H, R1
00000D7B 9189                    		MOV.W R1, 0EH[R0]
00000D7D                         L422:	; bb391
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2260
00000D7D B989                    		MOVU.W 0EH[R0], R1
00000D7F 06850102                		CMP 08H[R0].L, R1
00000D83 23rr                    		BLTU L421
00000D85                         L423:	; bb399
                                 ;    2264             }
                                 ;    2265 
                                 ;    2266             /* Re-enter PE mode, check if operation is successful */
                                 ;    2267             if( enter_pe_mode(flash_addr) != FLASH_SUCCESS)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2267
00000D85 A981                    		MOV.L 18H[R0], R1
00000D87 39rrrr               W  		BSR __$enter_pe_mode
00000D8A 6101                    		CMP #00H, R1
00000D8C 20rr                    		BEQ L431
00000D8E                         L424:	; bb400
                                 ;    2268             {
                                 ;    2269                 /* Make sure part is in ROM read mode. */
                                 ;    2270                 exit_pe_mode(flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2270
00000D8E A981                    		MOV.L 18H[R0], R1
00000D90 39rrrr               W  		BSR __$exit_pe_mode
00000D93                         L425:	; bb400.split
                                 ;    2271 
                                 ;    2272                 /* Release state */
                                 ;    2273                 flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2273
00000D93 39rrrr               W  		BSR __$flash_release_state
00000D96                         L426:	; bb400.split7
                                 ;    2274     
                                 ;    2275                 /* Return operation failure */
                                 ;    2276                 return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2276
00000D96 3C0606                  		MOV.B #06H, 06H[R0]
00000D99 2Err                 B  		BRA L435
00000D9B                         L427:	; bb414
00000D9B FBE2rrrrrrrr            		MOV.L #__$g_flash_to_flash_op, R14
00000DA1 58EE                    		MOVU.B [R14], R14
00000DA3 611E                    		CMP #01H, R14
00000DA5 18                   S  		BNE L429
00000DA6                         L428:	; bb419
00000DA6 F80601                  		MOV.L #00000001H, [R0]
00000DA9 08                   S  		BRA L430
00000DAA                         L429:	; bb420
00000DAA F80600                  		MOV.L #00000000H, [R0]
00000DAD                         L430:	; bb421
00000DAD EC01                    		MOV.L [R0], R1
00000DAF 6101                    		CMP #00H, R1
00000DB1 21rr                    		BNE L418
00000DB3                         L431:	; bb427
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2139
00000DB3 BA09                    		MOVU.W 12H[R0], R1
00000DB5 6101                    		CMP #00H, R1
00000DB7 3Brrrr               W  		BNE L399
00000DBA                         L432:	; bb434
                                 ;    2277             }                
                                 ;    2278         }
                                 ;    2279     #endif /* FLASH_API_RX_CFG_FLASH_TO_FLASH */  
                                 ;    2280 #endif           
                                 ;    2281     }
                                 ;    2282 
                                 ;    2283     /* Leave Program/Erase Mode */
                                 ;    2284     exit_pe_mode(flash_addr);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2284
00000DBA A981                    		MOV.L 18H[R0], R1
00000DBC 39rrrr               W  		BSR __$exit_pe_mode
00000DBF                         L433:	; bb434.split
                                 ;    2285     
                                 ;    2286     /* Release state */
                                 ;    2287     flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2287
00000DBF 39rrrr               W  		BSR __$flash_release_state
00000DC2                         L434:	; bb434.split8
                                 ;    2288 
                                 ;    2289     /* Return flash programming result */
                                 ;    2290     return result;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2290
00000DC2 C5000706                		MOV.B 07H[R0], 06H[R0]
00000DC6                         L435:	; bb438
00000DC6 C5000611                		MOV.B 06H[R0], 11H[R0]
                                 ;    2291 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2291
00000DCA B409                    		MOVU.B 11H[R0], R1
00000DCC 6707                    		RTSD #1CH
00000DCE                         __$notify_peripheral_clock:
                                 		.STACK	__$notify_peripheral_clock=20
                                 ;    2292 /******************************************************************************
                                 ;    2293 End of function  R_FlashWrite
                                 ;    2294 ******************************************************************************/
                                 ;    2295 
                                 ;    2296 /******************************************************************************
                                 ;    2297 * Function Name: notify_peripheral_clock
                                 ;    2298 * Description  : Notifies FCU or clock supplied to flash unit
                                 ;    2299 *                NOTE: This function MUST execute from in RAM for 'ROM Area' 
                                 ;    2300 *                programming, but if you are ONLY doing Data Flash programming,
                                 ;    2301 *                this function can reside and execute in Flash.
                                 ;    2302 * Arguments    : flash_addr - 
                                 ;    2303 *                    Flash address you will be erasing or writing to
                                 ;    2304 * Return Value : FLASH_SUCCESS - 
                                 ;    2305 *                    Operation Successful
                                 ;    2306 *                FLASH_FAILURE -
                                 ;    2307 *                    Operation Failed
                                 ;    2308 ******************************************************************************/
                                 ;    2309 static uint8_t notify_peripheral_clock (FCU_BYTE_PTR flash_addr)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2309
00000DCE 7100F0                  		ADD #0FFFFFFF0H, R0
00000DD1 A089                    		MOV.L R1, 0CH[R0]
                                 ;    2310 {
                                 ;    2311     /* Declare wait counter variable */
                                 ;    2312     volatile int32_t wait_cnt;
                                 ;    2313 
                                 ;    2314     /* Notify Peripheral Clock(PCK) */
                                 ;    2315     /* Set frequency of PCK in MHz */
                                 ;    2316     FLASH.PCKAR.WORD = (FLASH_CLOCK_HZ/1000000);            
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2316
00000DD3 FB1EB0FF7F              		MOV.L #007FFFB0H, R1
00000DD8 3D9C30                  		MOV.W #0030H, 38H[R1]
00000DDB                         L437:	; entry.split
                                 ;    2317 
                                 ;    2318     /* Execute Peripheral Clock Notification Commands */
                                 ;    2319     *flash_addr = 0xE9;         
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2319
00000DDB A889                    		MOV.L 0CH[R0], R1
00000DDD F814E9                  		MOV.B #0E9H, [R1]
00000DE0                         L438:	; entry.split1
                                 ;    2320     *flash_addr = 0x03;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2320
00000DE0 A889                    		MOV.L 0CH[R0], R1
00000DE2 F81403                  		MOV.B #03H, [R1]
00000DE5                         L439:	; entry.split2
                                 ;    2321     *(FCU_WORD_PTR)flash_addr = 0x0F0F;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2321
00000DE5 A889                    		MOV.L 0CH[R0], R1
00000DE7 F8190F0F                		MOV.W #0F0FH, [R1]
00000DEB                         L440:	; entry.split3
                                 ;    2322     *(FCU_WORD_PTR)flash_addr = 0x0F0F;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2322
00000DEB A889                    		MOV.L 0CH[R0], R1
00000DED F8190F0F                		MOV.W #0F0FH, [R1]
00000DF1                         L441:	; entry.split4
                                 ;    2323     *(FCU_WORD_PTR)flash_addr = 0x0F0F;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2323
00000DF1 A889                    		MOV.L 0CH[R0], R1
00000DF3 F8190F0F                		MOV.W #0F0FH, [R1]
00000DF7                         L442:	; entry.split5
                                 ;    2324     *flash_addr = 0xD0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2324
00000DF7 A889                    		MOV.L 0CH[R0], R1
00000DF9 F814D0                  		MOV.B #0D0H, [R1]
00000DFC                         L443:	; entry.split6
                                 ;    2325 
                                 ;    2326     /* Set timeout wait duration */
                                 ;    2327     wait_cnt = WAIT_MAX_NOTIFY_FCU_CLOCK;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2327
00000DFC F90A014017              		MOV.L #00001740H, 04H[R0]
00000E01 2Err                 B  		BRA L448
00000E03                         L444:	; bb
                                 ;    2328 
                                 ;    2329     /* Check FRDY */
                                 ;    2330     while(FLASH.FSTATR0.BIT.FRDY == 0)
                                 ;    2331     {
                                 ;    2332         /* Decrement wait counter */
                                 ;    2333         wait_cnt--;                             
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2333
00000E03 A809                    		MOV.L 04H[R0], R1
00000E05 6011                    		SUB #01H, R1
00000E07 A009                    		MOV.L R1, 04H[R0]
00000E09                         L445:	; bb.split
                                 ;    2334         
                                 ;    2335         /* Check if wait counter has reached zero */
                                 ;    2336         if(wait_cnt == 0)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2336
00000E09 A809                    		MOV.L 04H[R0], R1
00000E0B 6101                    		CMP #00H, R1
00000E0D 18                   S  		BNE L448
00000E0E                         L446:	; bb15
                                 ;    2337         {
                                 ;    2338             /* Timeout duration elapsed, assuming operation failure - Reset
                                 ;    2339                FCU */
                                 ;    2340             flash_reset();                      
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2340
00000E0E 39rrrr               W  		BSR __$flash_reset
00000E11                         L447:	; bb15.split
                                 ;    2341 
                                 ;    2342             /* Return FLASH_FAILURE, operation failure  */
                                 ;    2343             return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2343
00000E11 3C0306                  		MOV.B #06H, 03H[R0]
00000E14 2Err                 B  		BRA L452
00000E16                         L448:	; bb21
00000E16 754E80                  		MOV.L #00000080H, R14
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2330
00000E19 FBFEB0FF7F              		MOV.L #007FFFB0H, R15
00000E1E 50FE                    		AND [R15].UB, R14
00000E20 687E                    		SHLR #07H, R14
00000E22 610E                    		CMP #00H, R14
00000E24 20rr                    		BEQ L444
00000E26                         L449:	; bb29
                                 ;    2344         }
                                 ;    2345     }
                                 ;    2346 
                                 ;    2347     /* Check ILGLERR */
                                 ;    2348     if(FLASH.FSTATR0.BIT.ILGLERR == 1)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2348
00000E26 FBEEB0FF7F              		MOV.L #007FFFB0H, R14
00000E2B 58EE                    		MOVU.B [R14], R14
00000E2D 686E                    		SHLR #06H, R14
00000E2F 641E                    		AND #01H, R14
00000E31 611E                    		CMP #01H, R14
00000E33 18                   S  		BNE L451
00000E34                         L450:	; bb30
                                 ;    2349     {
                                 ;    2350         /* Return FLASH_FAILURE, operation failure*/
                                 ;    2351         return FLASH_FAILURE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2351
00000E34 3C0306                  		MOV.B #06H, 03H[R0]
00000E37 08                   S  		BRA L452
00000E38                         L451:	; bb39
                                 ;    2352     }
                                 ;    2353 
                                 ;    2354     /* Return FLASH_SUCCESS, operation success */
                                 ;    2355     return FLASH_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2355
00000E38 3C0300                  		MOV.B #00H, 03H[R0]
00000E3B                         L452:	; bb41
00000E3B C500030B                		MOV.B 03H[R0], 0BH[R0]
                                 ;    2356 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2356
00000E3F B289                    		MOVU.B 0BH[R0], R1
00000E41 6704                    		RTSD #10H
00000E43                         __$flash_reset:
                                 		.STACK	__$flash_reset=8
                                 ;    2357 /******************************************************************************
                                 ;    2358 End of function notify_peripheral_clock
                                 ;    2359 ******************************************************************************/
                                 ;    2360 
                                 ;    2361 /******************************************************************************
                                 ;    2362 * Function Name: flash_reset
                                 ;    2363 * Description  : Reset the FCU.
                                 ;    2364 *                NOTE: This function MUST execute from in RAM for 'ROM Area' 
                                 ;    2365 *                programming, but if you are ONLY doing Data Flash 
                                 ;    2366 *                programming, this function can reside and execute in Flash.
                                 ;    2367 * Arguments    : none
                                 ;    2368 * Return Value : none
                                 ;    2369 ******************************************************************************/
                                 ;    2370 static void flash_reset (void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2370
00000E43 6040                    		SUB #04H, R0
00000E45 FBEEB6FF7F              		MOV.L #007FFFB6H, R14
                                 ;    2371 {
                                 ;    2372     /* Declare wait counter variable */
                                 ;    2373     volatile int32_t    wait_cnt;
                                 ;    2374 
                                 ;    2375     /* Reset the FCU */
                                 ;    2376     FLASH.FRESETR.WORD = 0xCC01;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2376
00000E4A F8E901CC                		MOV.W #0CC01H, [R14]
00000E4E                         L454:	; entry.split
                                 ;    2377 
                                 ;    2378     /* Give FCU time to reset */
                                 ;    2379     wait_cnt = WAIT_TRESW;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2379
00000E4E F80A200D                		MOV.L #00000D20H, [R0]
00000E52 08                   S  		BRA L456
00000E53                         L455:	; bb
                                 ;    2380 
                                 ;    2381     /* Wait until the timer reaches zero */
                                 ;    2382     while(wait_cnt != 0)
                                 ;    2383     {
                                 ;    2384         /* Decrement the timer count each iteration */
                                 ;    2385         wait_cnt--;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2385
00000E53 EC01                    		MOV.L [R0], R1
00000E55 6011                    		SUB #01H, R1
00000E57 E301                    		MOV.L R1, [R0]
00000E59                         L456:	; bb3
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2382
00000E59 EC01                    		MOV.L [R0], R1
00000E5B 6101                    		CMP #00H, R1
00000E5D 21rr                    		BNE L455
00000E5F                         L457:	; bb7
                                 ;    2386     }
                                 ;    2387 
                                 ;    2388     /* Release state */
                                 ;    2389     flash_release_state();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2389
00000E5F 39rrrr               W  		BSR __$flash_release_state
00000E62                         L458:	; bb7.split
00000E62 FBEEB6FF7F              		MOV.L #007FFFB6H, R14
                                 ;    2390 
                                 ;    2391     /* FCU is not reset anymore */
                                 ;    2392     FLASH.FRESETR.WORD = 0xCC00;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2392
00000E67 F8E900CC                		MOV.W #0CC00H, [R14]
00000E6B                         L459:	; bb7.split1
00000E6B FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 ;    2393     
                                 ;    2394     /* Enter ROM Read mode */
                                 ;    2395     FLASH.FENTRYR.WORD = 0xAA00;                
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2395
00000E70 F8E900AA                		MOV.W #0AA00H, [R14]
00000E74                         L460:	; bb7.split2
                                 ;    2396 
                                 ;    2397     /* Initialize timeout for FENTRYR being written. */
                                 ;    2398     wait_cnt = FLASH_FENTRYR_TIMEOUT;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2398
00000E74 F80604                  		MOV.L #00000004H, [R0]
00000E77 2Err                 B  		BRA L462
00000E79                         L461:	; bb9
                                 ;    2399 
                                 ;    2400     /* Read FENTRYR to ensure it has been set to 0. Note that the top byte
                                 ;    2401        of the FENTRYR register is not retained and is read as 0x00. */
                                 ;    2402     while(0x0000 != FLASH.FENTRYR.WORD)
                                 ;    2403     {
                                 ;    2404         /* Wait until FENTRYR is 0 unless timeout occurs. */
                                 ;    2405         if (wait_cnt-- <= 0)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2405
00000E79 EC01                    		MOV.L [R0], R1
00000E7B EC02                    		MOV.L [R0], R2
00000E7D 6012                    		SUB #01H, R2
00000E7F E302                    		MOV.L R2, [R0]
00000E81 6101                    		CMP #00H, R1
00000E83 2Brr                    		BLE L463
00000E85                         L462:	; bb19
00000E85 FBEEB2FF7F              		MOV.L #007FFFB2H, R14
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2402
00000E8A 5CEE                    		MOVU.W [R14], R14
00000E8C 610E                    		CMP #00H, R14
00000E8E 21rr                    		BNE L461
00000E90                         L463:	; bb26
00000E90 FBEE96C208              		MOV.L #0008C296H, R14
                                 ;    2406         {
                                 ;    2407             /* This should not happen. FENTRYR getting written to 0 should
                                 ;    2408                only take 2-4 PCLK cycles. Could add a call to FlashError()
                                 ;    2409                here if user wants to process this. */
                                 ;    2410             break;
                                 ;    2411         }
                                 ;    2412     }
                                 ;    2413     
                                 ;    2414     /* Flash write/erase disabled */
                                 ;    2415     FLASH.FWEPROR.BYTE = 0x02;    
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2415
00000E95 F8E402                  		MOV.B #02H, [R14]
00000E98 6701                    		RTSD #04H
00000E9A                         __$flash_get_program_size:
                                 		.STACK	__$flash_get_program_size=20
                                 ;    2416 }
                                 ;    2417 /******************************************************************************
                                 ;    2418 End of function  flash_reset
                                 ;    2419 ******************************************************************************/
                                 ;    2420 
                                 ;    2421 /******************************************************************************
                                 ;    2422 * Function Name: flash_get_program_size
                                 ;    2423 * Description  : Gets the number of bytes that can be written at this time. 
                                 ;    2424 *                Since the DF and ROM have different available programming 
                                 ;    2425 *                sizes, we want to use the largest option to save time.
                                 ;    2426 * Arguments    : bytes - 
                                 ;    2427 *                    How many bytes are left to write total.
                                 ;    2428 *                flash_addr - 
                                 ;    2429 *                    Current address we are writing to.
                                 ;    2430 * Return Value : Number of bytes to write at this time.
                                 ;    2431 ******************************************************************************/
                                 ;    2432 static uint32_t flash_get_program_size (uint32_t bytes, uint32_t flash_addr)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2432
00000E9A 7100F0                  		ADD #0FFFFFFF0H, R0
00000E9D A089                    		MOV.L R1, 0CH[R0]
00000E9F A082                    		MOV.L R2, 08H[R0]
                                 ;    2433 {
                                 ;    2434     uint32_t num_byte_to_write = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2434
00000EA1 F80600                  		MOV.L #00000000H, [R0]
00000EA4                         L465:	; entry.split
                                 ;    2435    
                                 ;    2436     if( g_current_mode == FLD_PE_MODE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2436
00000EA4 FBE2rrrrrrrr            		MOV.L #__$g_current_mode, R14
00000EAA 58EE                    		MOVU.B [R14], R14
00000EAC 612E                    		CMP #02H, R14
00000EAE 18                   S  		BNE L467
00000EAF                         L466:	; bb4
                                 ;    2437     {
                                 ;    2438         /* This is a DF write. */
                                 ;    2439 #if defined(DF_PROGRAM_SIZE_LARGE)
                                 ;    2440         if( (bytes >= DF_PROGRAM_SIZE_LARGE) && 
                                 ;    2441             ((flash_addr & (DF_PROGRAM_SIZE_LARGE-1)) == 0x00))
                                 ;    2442         {
                                 ;    2443             /* Use large write size since it's more time efficient */
                                 ;    2444             num_byte_to_write = DF_PROGRAM_SIZE_LARGE;
                                 ;    2445         }
                                 ;    2446         else
                                 ;    2447         {   
                                 ;    2448             /* Cannot use large program size, use small */
                                 ;    2449             num_byte_to_write = DF_PROGRAM_SIZE_SMALL;
                                 ;    2450         }
                                 ;    2451 #else
                                 ;    2452         /* Set the next data transfer size to be DF_PROGRAM_SIZE_SMALL*/
                                 ;    2453         num_byte_to_write = DF_PROGRAM_SIZE_SMALL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2453
00000EAF F80602                  		MOV.L #00000002H, [R0]
00000EB2 08                   S  		BRA L468
00000EB3                         L467:	; bb5
                                 ;    2454 #endif
                                 ;    2455     }
                                 ;    2456     else
                                 ;    2457     {
                                 ;    2458         /* This is a ROM write. */
                                 ;    2459 #if defined(ROM_PROGRAM_SIZE_LARGE)
                                 ;    2460         if( (bytes >= ROM_PROGRAM_SIZE_LARGE) && 
                                 ;    2461             ((flash_addr & (ROM_PROGRAM_SIZE_LARGE-1)) == 0x00))
                                 ;    2462         {
                                 ;    2463             /* Use large write size since it's more time efficient */
                                 ;    2464             num_byte_to_write = ROM_PROGRAM_SIZE_LARGE;
                                 ;    2465         }
                                 ;    2466     #if defined(ROM_PROGRAM_SIZE_MEDIUM)
                                 ;    2467         else if( (bytes >= ROM_PROGRAM_SIZE_MEDIUM) && 
                                 ;    2468                  ((flash_addr & (ROM_PROGRAM_SIZE_MEDIUM-1)) == 0x00))
                                 ;    2469         {
                                 ;    2470             /* Use large write size since it's more time efficient */
                                 ;    2471             num_byte_to_write = ROM_PROGRAM_SIZE_MEDIUM;
                                 ;    2472         }
                                 ;    2473     #endif
                                 ;    2474         else
                                 ;    2475         {   
                                 ;    2476             /* Cannot use large program size, use small */
                                 ;    2477             num_byte_to_write = ROM_PROGRAM_SIZE_SMALL;
                                 ;    2478         }
                                 ;    2479 #else
                                 ;    2480         /* Set the next data transfer size to be smallest supported write. */
                                 ;    2481         num_byte_to_write = ROM_PROGRAM_SIZE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2481
00000EB3 3E0080                  		MOV.L #00000080H, 00H[R0]
00000EB6                         L468:	; bb10
                                 ;    2482 #endif
                                 ;    2483     }
                                 ;    2484 
                                 ;    2485     return num_byte_to_write;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2485
00000EB6 EC01                    		MOV.L [R0], R1
00000EB8 A009                    		MOV.L R1, 04H[R0]
00000EBA                         L469:	; bb10.split
                                 ;    2486 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_flash_api_rx\src\r_flash_api_rx.c",2486
00000EBA 6704                    		RTSD #10H
                                 ;    2487 
                                 ;    2488 #ifndef  FLASH_API_RX_CFG_IGNORE_LOCK_BITS
                                 ;    2489 /******************************************************************************
                                 ;    2490 * Function Name: R_FlashProgramLockBit
                                 ;    2491 * Description  : Programs the lock bit for a specified ROM erasure block. If
                                 ;    2492 *                the lock bit for a block is set and lock bit protection is 
                                 ;    2493 *                enabled then that block cannot be programmed/erased.
                                 ;    2494 *                NOTE: This function MUST execute from RAM
                                 ;    2495 * Arguments    : block - 
                                 ;    2496 *                    Which ROM erasure block to set the lock bit for
                                 ;    2497 * Return Value : FLASH_SUCCESS -
                                 ;    2498 *                    Operation Successful
                                 ;    2499 *                FLASH_FAILURE -
                                 ;    2500 *                    Operation Failed
                                 ;    2501 *                FLASH_BUSY -
                                 ;    2502 *                    Another flash operation is in progress
                                 ;    2503 ******************************************************************************/
                                 ;    2504 uint8_t R_FlashProgramLockBit (uint32_t block)
                                 ;    2505 {
                                 ;    2506     /* Declare address pointer */
                                 ;    2507     FCU_BYTE_PTR p_addr;
                                 ;    2508     
                                 ;    2509     /* Declare operation result container variable */
                                 ;    2510     uint8_t result = FLASH_SUCCESS;
                                 ;    2511     
                                 ;    2512     /* Declare timer wait count variable */
                                 ;    2513     volatile int32_t wait_cnt;
                                 ;    2514     
                                 ;    2515     /* Attempt to grab state */
                                 ;    2516     if( flash_grab_state(FLASH_LOCK_BIT) != FLASH_SUCCESS )
                                 ;    2517     {
                                 ;    2518         /* Another operation is already in progress */
                                 ;    2519         return FLASH_BUSY;
                                 ;    2520     }
                                 ;    2521     
                                 ;    2522     /* Flash Command Address */
                                 ;    2523     p_addr = (FCU_BYTE_PTR)(g_flash_BlockAddresses[block]);
                                 ;    2524     
                                 ;    2525     /* Set FCU to ROM PE mode */
                                 ;    2526     g_current_mode = ROM_PE_MODE;    
                                 ;    2527     
                                 ;    2528     /* Enter ROM PE mode, check if operation successful */
                                 ;    2529     if( enter_pe_mode((uint32_t)p_addr) != FLASH_SUCCESS)        
                                 ;    2530     {
                                 ;    2531         /* Make sure part is in ROM read mode. */
                                 ;    2532         exit_pe_mode((uint32_t)p_addr);
                                 ;    2533 
                                 ;    2534         /* Release state */
                                 ;    2535         flash_release_state();
                                 ;    2536         
                                 ;    2537         /* Return FLASH_FAILURE, operation failure */
                                 ;    2538         return FLASH_FAILURE;
                                 ;    2539     }
                                 ;    2540     
                                 ;    2541     /* Send the FCU Command */
                                 ;    2542     *p_addr = 0x77;
                                 ;    2543     *p_addr = 0xD0;
                                 ;    2544 
                                 ;    2545     /* Set timeout wait counter value */
                                 ;    2546     wait_cnt = WAIT_MAX_ROM_WRITE;
                                 ;    2547 
                                 ;    2548     /* Wait until FCU operation finishes, or a timeout occurs */
                                 ;    2549     while(FLASH.FSTATR0.BIT.FRDY == 0)
                                 ;    2550     {
                                 ;    2551         /* Decrement the wait counter */
                                 ;    2552         wait_cnt--;
                                 ;    2553 
                                 ;    2554         /* Check if the wait counter has reached zero */
                                 ;    2555         if(wait_cnt == 0)
                                 ;    2556         {    
                                 ;    2557             /* Maximum timeout duration for writing to ROM has elapsed - 
                                 ;    2558                assume operation failure and reset the FCU */
                                 ;    2559             flash_reset();
                                 ;    2560 
                                 ;    2561             /* Return FLASH_FAILURE, operation failure */
                                 ;    2562             result = FLASH_FAILURE;
                                 ;    2563         }
                                 ;    2564     }
                                 ;    2565 
                                 ;    2566     /* Check for illegal command or programming errors */
                                 ;    2567     if((FLASH.FSTATR0.BIT.ILGLERR == 1) || (FLASH.FSTATR0.BIT.PRGERR  == 1)) 
                                 ;    2568     {        
                                 ;    2569         /* Return FLASH_FAILURE, operation failure */
                                 ;    2570         result = FLASH_FAILURE;
                                 ;    2571     }      
                                 ;    2572     
                                 ;    2573     /* Leave Program/Erase Mode */
                                 ;    2574     exit_pe_mode((uint32_t)p_addr);
                                 ;    2575     
                                 ;    2576     /* Release state */
                                 ;    2577     flash_release_state();              
                                 ;    2578     
                                 ;    2579     /* Return result of lock bit programming */
                                 ;    2580     return result;
                                 ;    2581 }
                                 ;    2582 /******************************************************************************
                                 ;    2583 End of function  R_FlashProgramLockBit
                                 ;    2584 ******************************************************************************/
                                 ;    2585 
                                 ;    2586 /******************************************************************************
                                 ;    2587 * Function Name: R_FlashReadLockBit
                                 ;    2588 * Description  : Reads and returns the lock bit status for a ROM block
                                 ;    2589 *                NOTE: This function MUST execute from RAM
                                 ;    2590 * Arguments    : block - 
                                 ;    2591 *                    Which ROM erasure block to read the lock bit of
                                 ;    2592 * Return Value : FLASH_LOCK_BIT_SET -
                                 ;    2593 *                    Lock bit was set
                                 ;    2594 *                FLASH_LOCK_BIT_NOT_SET -
                                 ;    2595 *                    Lock bit was not set
                                 ;    2596 *                FLASH_FAILURE -
                                 ;    2597 *                    Operation Failed
                                 ;    2598 *                FLASH_BUSY -
                                 ;    2599 *                    Another flash operation is in progress
                                 ;    2600 ******************************************************************************/
                                 ;    2601 uint8_t R_FlashReadLockBit (uint32_t block)
                                 ;    2602 {
                                 ;    2603     /* Declare address pointer */
                                 ;    2604     FCU_BYTE_PTR p_addr;
                                 ;    2605     
                                 ;    2606     /* Declare operation result container variable */
                                 ;    2607     uint8_t result = FLASH_SUCCESS;
                                 ;    2608         
                                 ;    2609     /* Holds outcome of lock-bit read */
                                 ;    2610     uint8_t lock_bit;
                                 ;    2611     
                                 ;    2612     /* Attempt to grab state */;
                                 ;    2613     if( flash_grab_state(FLASH_LOCK_BIT) != FLASH_SUCCESS )
                                 ;    2614     {
                                 ;    2615         /* Another operation is already in progress */
                                 ;    2616         return FLASH_BUSY;
                                 ;    2617     }
                                 ;    2618     
                                 ;    2619     /* Flash Command Address */
                                 ;    2620     p_addr = (FCU_BYTE_PTR)(g_flash_BlockAddresses[ block ]);
                                 ;    2621     
                                 ;    2622     /* Set FCU to ROM PE mode */
                                 ;    2623     g_current_mode = ROM_PE_MODE;
                                 ;    2624 
                                 ;    2625     /* Enter ROM PE mode, check if operation successful */
                                 ;    2626     if( enter_pe_mode((uint32_t)p_addr) != FLASH_SUCCESS)        
                                 ;    2627     {
                                 ;    2628         /* Make sure part is in ROM read mode. */
                                 ;    2629         exit_pe_mode((uint32_t)p_addr);
                                 ;    2630 
                                 ;    2631         /* Release state */
                                 ;    2632         flash_release_state();
                                 ;    2633         
                                 ;    2634         /* Return FLASH_FAILURE, operation failure */
                                 ;    2635         return FLASH_FAILURE;
                                 ;    2636     }
                                 ;    2637     
                                 ;    2638     /* Switch to ROM Lock-Bit Read Mode */
                                 ;    2639     *p_addr = 0x71;
                                 ;    2640     
                                 ;    2641     /* Check for illegal command */
                                 ;    2642     if(FLASH.FSTATR0.BIT.ILGLERR == 1) 
                                 ;    2643     {        
                                 ;    2644         /* Return FLASH_FAILURE, operation failure */
                                 ;    2645         result = FLASH_FAILURE;        
                                 ;    2646     }      
                                 ;    2647     else
                                 ;    2648     {       
                                 ;    2649         /* Read lock bit value */
                                 ;    2650         lock_bit = *p_addr;
                                 ;    2651         
                                 ;    2652         /* Set return value */
                                 ;    2653         if(lock_bit != 0x00)
                                 ;    2654         {
                                 ;    2655             /* Lock bit is not set */
                                 ;    2656             result = FLASH_LOCK_BIT_NOT_SET;
                                 ;    2657         }
                                 ;    2658         else
                                 ;    2659         {
                                 ;    2660             /* Lock bit is set */
                                 ;    2661             result = FLASH_LOCK_BIT_SET;
                                 ;    2662         }
                                 ;    2663     }
                                 ;    2664               
                                 ;    2665     /* Leave Program/Erase Mode */
                                 ;    2666     exit_pe_mode((uint32_t)p_addr);
                                 ;    2667     
                                 ;    2668     /* Release state */
                                 ;    2669     flash_release_state();   
                                 ;    2670         
                                 ;    2671     /* Return result of lock bit programming */
                                 ;    2672     return result;
                                 ;    2673 }
                                 ;    2674 /******************************************************************************
                                 ;    2675 End of function  R_FlashReadLockBit
                                 ;    2676 ******************************************************************************/
                                 ;    2677 #endif /* FLASH_API_RX_CFG_IGNORE_LOCK_BITS */
                                 ;    2678 
                                 		.SECTION	C,ROMDATA,ALIGN=4
00000000                         _g_flash_BlockAddresses:
00000000 00F0FF00                		.lword	00FFF000H
00000004 00E0FF00                		.lword	00FFE000H
00000008 00D0FF00                		.lword	00FFD000H
0000000C 00C0FF00                		.lword	00FFC000H
00000010 00B0FF00                		.lword	00FFB000H
00000014 00A0FF00                		.lword	00FFA000H
00000018 0090FF00                		.lword	00FF9000H
0000001C 0080FF00                		.lword	00FF8000H
00000020 0040FF00                		.lword	00FF4000H
00000024 0000FF00                		.lword	00FF0000H
00000028 00C0FE00                		.lword	00FEC000H
0000002C 0080FE00                		.lword	00FE8000H
00000030 0040FE00                		.lword	00FE4000H
00000034 0000FE00                		.lword	00FE0000H
00000038 00C0FD00                		.lword	00FDC000H
0000003C 0080FD00                		.lword	00FD8000H
00000040 0040FD00                		.lword	00FD4000H
00000044 0000FD00                		.lword	00FD0000H
00000048 00C0FC00                		.lword	00FCC000H
0000004C 0080FC00                		.lword	00FC8000H
00000050 0040FC00                		.lword	00FC4000H
00000054 0000FC00                		.lword	00FC0000H
00000058 00C0FB00                		.lword	00FBC000H
0000005C 0080FB00                		.lword	00FB8000H
00000060 0040FB00                		.lword	00FB4000H
00000064 0000FB00                		.lword	00FB0000H
00000068 00C0FA00                		.lword	00FAC000H
0000006C 0080FA00                		.lword	00FA8000H
00000070 0040FA00                		.lword	00FA4000H
00000074 0000FA00                		.lword	00FA0000H
00000078 00C0F900                		.lword	00F9C000H
0000007C 0080F900                		.lword	00F98000H
00000080 0040F900                		.lword	00F94000H
00000084 0000F900                		.lword	00F90000H
00000088 00C0F800                		.lword	00F8C000H
0000008C 0080F800                		.lword	00F88000H
00000090 0040F800                		.lword	00F84000H
00000094 0000F800                		.lword	00F80000H
00000098 0080F700                		.lword	00F78000H
0000009C 0000F700                		.lword	00F70000H
000000A0 0080F600                		.lword	00F68000H
000000A4 0000F600                		.lword	00F60000H
000000A8 0080F500                		.lword	00F58000H
000000AC 0000F500                		.lword	00F50000H
000000B0 0080F400                		.lword	00F48000H
000000B4 0000F400                		.lword	00F40000H
000000B8 0080F300                		.lword	00F38000H
000000BC 0000F300                		.lword	00F30000H
000000C0 0080F200                		.lword	00F28000H
000000C4 0000F200                		.lword	00F20000H
000000C8 0080F100                		.lword	00F18000H
000000CC 0000F100                		.lword	00F10000H
000000D0 0080F000                		.lword	00F08000H
000000D4 0000F000                		.lword	00F00000H
000000D8 0000EF00                		.lword	00EF0000H
000000DC 0000EE00                		.lword	00EE0000H
000000E0 0000ED00                		.lword	00ED0000H
000000E4 0000EC00                		.lword	00EC0000H
000000E8 0000EB00                		.lword	00EB0000H
000000EC 0000EA00                		.lword	00EA0000H
000000F0 0000E900                		.lword	00E90000H
000000F4 0000E800                		.lword	00E80000H
000000F8 0000E700                		.lword	00E70000H
000000FC 0000E600                		.lword	00E60000H
00000100 0000E500                		.lword	00E50000H
00000104 0000E400                		.lword	00E40000H
00000108 0000E300                		.lword	00E30000H
0000010C 0000E200                		.lword	00E20000H
00000110 0000E100                		.lword	00E10000H
00000114 0000E000                		.lword	00E00000H
00000118 00001000                		.lword	00100000H
0000011C 00081000                		.lword	00100800H
00000120 00101000                		.lword	00101000H
00000124 00181000                		.lword	00101800H
00000128 00201000                		.lword	00102000H
0000012C 00281000                		.lword	00102800H
00000130 00301000                		.lword	00103000H
00000134 00381000                		.lword	00103800H
00000138 00401000                		.lword	00104000H
0000013C 00481000                		.lword	00104800H
00000140 00501000                		.lword	00105000H
00000144 00581000                		.lword	00105800H
00000148 00601000                		.lword	00106000H
0000014C 00681000                		.lword	00106800H
00000150 00701000                		.lword	00107000H
00000154 00781000                		.lword	00107800H
                                 		.SECTION	D_1,ROMDATA
00000000                         __$g_fcu_transfer_complete:
00000000 00                      		.byte	00H
00000001                         __$g_fcu_pclk_command:
00000001 00                      		.byte	00H
                                 		.SECTION	B,DATA,ALIGN=4
00000000                         __$g_flash_state:
00000000(00000004H)              		.blkl	1
00000004                         __$g_bgo_bytes:
00000004(00000004H)              		.blkl	1
00000008                         __$g_bgo_flash_addr:
00000008(00000004H)              		.blkl	1
0000000C                         __$g_bgo_buffer_addr:
0000000C(00000004H)              		.blkl	1
                                 		.SECTION	B_1,DATA
00000000                         __$g_current_mode:
00000000(00000001H)              		.blkb	1
00000001                         __$g_temp_array:
00000001(00000080H)              		.blkb	128
00000081                         __$g_flash_to_flash_op:
00000081(00000001H)              		.blkb	1
                                 		.END

Information List

TOTAL ERROR(S)    00000
TOTAL WARNING(S)  00000
TOTAL LINE(S)     05082   LINES

Section List

Attr         Size               Name
CODE     0000003772(00000EBCH)  P
ROMDATA  0000000344(00000158H)  C
ROMDATA  0000000002(00000002H)  D_1
DATA     0000000016(00000010H)  B
DATA     0000000130(00000082H)  B_1

Cpu Type

-ISA=RXV1 -FPU

Command Parameter

-subcommand=C:\Users\LAFONS~1\AppData\Local\Temp\$ccrx4DB7\$ccrx\r_flash_api_rx.src.cmd
    -nologo
    -isa=rxv1
    -fpu
    -show=conditionals,definitions,expansions
    -define=__RXV1=1
    -fint_register=0
    -debug
    -endian=little
-listfile=C:\Workspace\e2studio\git\MT01_master\MT01_build\r_flash_api_rx.lst
-output=C:\Workspace\e2studio\git\MT01_master\MT01_build\r_flash_api_rx\src\r_flash_api_rx.obj
