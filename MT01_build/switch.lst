* RX FAMILY ASSEMBLER V2.03.00.01 [24 Oct 2014] *  SOURCE LIST  Mon Mar 20 17:11:46 2017

LOC.     OBJ.              0XMDA SOURCE STATEMENT

                                 ;RX Family C/C++ Compiler (V2.03.00.03 [04 Dec 2014])  20-Mar-2017 17:11:45
                                 
                                 ;*** CPU TYPE ***
                                 
                                 ;-ISA=RXV1
                                 
                                 ;*** COMMAND PARAMETER ***
                                 
                                 ;-output=src=switch.src
                                 ;-lang=c99
                                 ;-include=C:\PROGRA~2\Renesas\RX\2_3_0/include,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx\src,C:/Workspace/e2studio/
                                 ;-debug
                                 ;-show=source,conditionals,definitions,expansions
                                 ;-listfile=switch.lst
                                 ;-isa=rxv1
                                 ;-optimize=0
                                 ;-fpu
                                 ;-alias=noansi
                                 ;-nologo
                                 ;-nomessage
                                 ;-define=__RX,COMPACTAXP=0,EASYMAK=1,MOBILE=0,FREE_RTOS_PP
                                 ;switch.c
                                 
                                 		.glb	_cm
                                 		.glb	_sw
                                 		.glb	_zinhibitor
                                 		.glb	_switch_init
                                 		.glb	_cm_request_feedhold
                                 		.glb	_switch_rtc_callback
                                 		.glb	_get_switch_mode
                                 		.glb	_get_limit_switch_thrown
                                 		.glb	_get_switch_thrown
                                 		.glb	_set_switch_type
                                 		.glb	_get_switch_type
                                 		.glb	_reset_switches
                                 		.glb	_read_switch
                                 		.glb	_sw_set_st
                                 		.glb	_set_01
                                 		.glb	_sw_set_sw
                                 		.glb	_set_ui8
                                 		.glb	_sw_print_st
                                 		.glb	_text_print_ui8
                                 ;LineNo. C-SOURCE STATEMENT
                                 
                                 		.SECTION	P,CODE
00000000                         _switch_init:
                                 		.STACK	_switch_init=4
                                 ;       1 /*
                                 ;       2  * switch.c - switch handling functions
                                 ;       3  * This file is part of the TinyG project
                                 ;       4  *
                                 ;       5  * Copyright (c) 2010 - 2015 Alden S. Hart, Jr.
                                 ;       6  *
                                 ;       7  * This file ("the software") is free software: you can redistribute it and/or modify
                                 ;       8  * it under the terms of the GNU General Public License, version 2 as published by the
                                 ;       9  * Free Software Foundation. You should have received a copy of the GNU General Public
                                 ;      10  * License, version 2 along with the software. If not, see <http://www.gnu.org/licenses/>.
                                 ;      11  *
                                 ;      12  * As a special exception, you may use this file as part of a software library without
                                 ;      13  * restriction. Specifically, if other files instantiate templates or use macros or
                                 ;      14  * inline functions from this file, or you compile this file and link it with  other
                                 ;      15  * files to produce an executable, this file does not by itself cause the resulting
                                 ;      16  * executable to be covered by the GNU General Public License. This exception does not
                                 ;      17  * however invalidate any other reasons why the executable file might be covered by the
                                 ;      18  * GNU General Public License.
                                 ;      19  *
                                 ;      20  * THE SOFTWARE IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT WITHOUT ANY
                                 ;      21  * WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
                                 ;      22  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
                                 ;      23  * SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                 ;      24  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
                                 ;      25  * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                                 ;      26  */
                                 ;      27 /* Switch Modes
                                 ;      28  *
                                 ;      29  *	The switches are considered to be homing switches when machine_state is
                                 ;      30  *	MACHINE_HOMING. At all other times they are treated as limit switches:
                                 ;      31  *	  - Hitting a homing switch puts the current move into feedhold
                                 ;      32  *	  - Hitting a limit switch causes the machine to shut down and go into lockdown until reset
                                 ;      33  *
                                 ;      34  * 	The normally open switch modes (NO) trigger an interrupt on the falling edge
                                 ;      35  *	and lockout subsequent interrupts for the defined lockout period. This approach
                                 ;      36  *	beats doing debouncing as an integration as switches fire immediately.
                                 ;      37  *
                                 ;      38  * 	The normally closed switch modes (NC) trigger an interrupt on the rising edge
                                 ;      39  *	and lockout subsequent interrupts for the defined lockout period. Ditto on the method.
                                 ;      40  */
                                 ;      41 
                                 ;      42 #include "tinyg.h"
                                 ;      43 #include "config.h"
                                 ;      44 #include "switch.h"
                                 ;      45 #include "hardware.h"
                                 ;      46 #include "canonical_machine.h"
                                 ;      47 #include "text_parser.h"
                                 ;      48 
                                 ;      49 struct swStruct sw;
                                 ;      50 bool zinhibitor = false;
                                 ;      51 
                                 ;      52 static void _switch_isr_helper(uint8_t sw_num);
                                 ;      53 
                                 ;      54 /*
                                 ;      55  * switch_init() - initialize homing/limit switches
                                 ;      56  *
                                 ;      57  *	This function assumes sys_init() and st_init() have been run previously to
                                 ;      58  *	bind the ports and set bit IO directions, repsectively. See system.h for details
                                 ;      59  */
                                 ;      60 /* Note: v7 boards have external strong pullups on GPIO2 pins (2.7K ohm).
                                 ;      61  *	v6 and earlier use internal pullups only. Internal pullups are set
                                 ;      62  *	regardless of board type but are extraneous for v7 boards.
                                 ;      63  */
                                 ;      64 
                                 ;      65 
                                 ;      66 void switch_init(void)
                                 ;      67 {
                                 ;      68     ICU.IRQCR[2].BIT.IRQMD = 2;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",68
00000000 FBEE427008              		MOV.L #00087042H, R14
00000005 5AEFC004                		MOVU.B 04C0H[R14], R15
00000009 783F                    		BSET #03H, R15
0000000B 762FFB00                		AND #0FBH, R15
0000000F CBEFC004                		MOV.B R15, 04C0H[R14]
00000013                         L11:	; entry.split
                                 ;      69     IR(ICU, IRQ2)  = 0;            //Clear any previously pending interrupts
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",69
00000013 FBEE427008              		MOV.L #00087042H, R14
00000018 F0E8                    		BCLR #00H, [R14].B
0000001A                         L12:	; entry.split1
                                 ;      70     IPR(ICU, IRQ2) = 5;            //Set interrupt priority
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",70
0000001A FBEE427008              		MOV.L #00087042H, R14
0000001F 5AEF0003                		MOVU.B 0300H[R14], R15
00000023 655F                    		OR #05H, R15
00000025 762FF500                		AND #0F5H, R15
00000029 CBEF0003                		MOV.B R15, 0300H[R14]
0000002D                         L13:	; entry.split2
                                 ;      71     IEN(ICU, IRQ2) = 0;            // Enable interrupt
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",71
0000002D FBEE427008              		MOV.L #00087042H, R14
00000032 F2EAC601                		BCLR #02H, 01C6H[R14].B
00000036                         L14:	; entry.split3
                                 ;      72     reset_switches();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",72
00000036 39rrrr               W  		BSR _reset_switches
00000039 02                      		RTS
0000003A                         __$IRQ2_isr:
                                 		.STACK	__$IRQ2_isr=40
                                 		.RVECTOR	66,__$IRQ2_isr
                                 ;      73 }
                                 ;      74 
                                 ;      75 #pragma interrupt IRQ2_isr(vect=VECT(ICU, IRQ2))
                                 ;      76 static void IRQ2_isr (void) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",76
0000003A 6EEF                    		PUSHM R14-R15
0000003C 6E15                    		PUSHM R1-R5
0000003E 6040                    		SUB #04H, R0
                                 ;      77 //	_switch_isr_helper(SW_MIN_Z);
                                 ;      78 	if ((cm.cycle_state == CYCLE_HOMING) || (cm.cycle_state == CYCLE_PROBE)) {		// regardless of switch type
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",78
00000040 FB12rrrrrrrr            		MOV.L #_cm, R1
00000046 5A111E02                		MOVU.B 021EH[R1], R1
0000004A 6131                    		CMP #03H, R1
0000004C 20rr                    		BEQ L20
0000004E 2Err                 B  		BRA L19
00000050                         L16:	; bb1
                                 ;      79 		zinhibitor = true;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",79
00000050 FB12rrrrrrrr            		MOV.L #_zinhibitor, R1
00000056 F81401                  		MOV.B #01H, [R1]
00000059                         L17:	; bb1.split
                                 ;      80 		cm_request_feedhold();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",80
00000059 05rrrrrr             A  		BSR _cm_request_feedhold
0000005D                         L18:	; bb1.split1
0000005D FB1E087208              		MOV.L #00087208H, R1
                                 ;      81 	    IEN(ICU, IRQ2) = 0;            // Disable interrupt
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",81
00000062 F01A                    		BCLR #02H, [R1].B
00000064 6240                    		ADD #04H, R0
00000066 6F15                    		POPM R1-R5
00000068 6FEF                    		POPM R14-R15
0000006A 7F95                    		RTE
0000006C                         L19:	; bb8
0000006C FB12rrrrrrrr            		MOV.L #_cm, R1
00000072 5A111E02                		MOVU.B 021EH[R1], R1
00000076 6121                    		CMP #02H, R1
00000078 18                   S  		BNE L21
00000079                         L20:	; bb13
00000079 F80601                  		MOV.L #00000001H, [R0]
0000007C 08                   S  		BRA L22
0000007D                         L21:	; bb14
0000007D F80600                  		MOV.L #00000000H, [R0]
00000080                         L22:	; bb15
00000080 EC01                    		MOV.L [R0], R1
00000082 6101                    		CMP #00H, R1
00000084 21rr                    		BNE L16
00000086                         L23:	; return
                                 ;      82 	}
                                 ;      83 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",83
00000086 6240                    		ADD #04H, R0
00000088 6F15                    		POPM R1-R5
0000008A 6FEF                    		POPM R14-R15
0000008C 7F95                    		RTE
0000008E                         _switch_rtc_callback:
                                 		.STACK	_switch_rtc_callback=16
                                 ;      84 
                                 ;      85 /*
                                 ;      86  * Switch closure processing routines
                                 ;      87  *
                                 ;      88  * ISRs 				 - switch interrupt handler vectors
                                 ;      89  * _isr_helper()		 - common code for all switch ISRs
                                 ;      90  * switch_rtc_callback() - called from RTC for each RTC tick.
                                 ;      91  *
                                 ;      92  *	These functions interact with each other to process switch closures and firing.
                                 ;      93  *	Each switch has a counter which is initially set to negative SW_DEGLITCH_TICKS.
                                 ;      94  *	When a switch closure is DETECTED the count increments for each RTC tick.
                                 ;      95  *	When the count reaches zero the switch is tripped and action occurs.
                                 ;      96  *	The counter continues to increment positive until the lockout is exceeded.
                                 ;      97  */
                                 ;      98 
                                 ;      99 static void _switch_isr_helper(uint8_t sw_num)
                                 ;     100 {
                                 ;     101 	if (sw.mode[sw_num] == SW_MODE_DISABLED) return;	// this is never supposed to happen
                                 ;     102 	if (sw.debounce[sw_num] == SW_LOCKOUT) return;		// exit if switch is in lockout
                                 ;     103 	sw.debounce[sw_num] = SW_DEGLITCHING;				// either transitions state from IDLE or overwrites it
                                 ;     104 	sw.count[sw_num] = -SW_DEGLITCH_TICKS;				// reset deglitch count regardless of entry state
                                 ;     105 	read_switch(sw_num);							// sets the state value in the struct
                                 ;     106 }
                                 ;     107 
                                 ;     108 void switch_rtc_callback(void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",108
0000008E 7EA6                    		PUSH.L R6
00000090 6080                    		SUB #08H, R0
                                 ;     109 {
                                 ;     110 	for (uint8_t i=0; i < NUM_SWITCHES; i++) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",110
00000092 3C0600                  		MOV.B #00H, 06H[R0]
00000095 38rrrr               W  		BRA L48
00000098                         L25:	; bb3
                                 ;     111 		if (sw.mode[i] == SW_MODE_DISABLED || sw.debounce[i] == SW_IDLE)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",111
00000098 FB12rrrrrrrr            		MOV.L #_sw, R1
0000009E 490106                  		ADD 06H[R0].UB, R1
000000A1 B299                    		MOVU.B 0BH[R1], R1
000000A3 6101                    		CMP #00H, R1
000000A5 20rr                    		BEQ L27
000000A7                         L26:	; bb12
000000A7 FB12rrrrrrrr            		MOV.L #_sw, R1
000000AD 490106                  		ADD 06H[R0].UB, R1
000000B0 B499                    		MOVU.B 13H[R1], R1
000000B2 6101                    		CMP #00H, R1
000000B4 18                   S  		BNE L28
000000B5                         L27:	; bb20
000000B5 F80601                  		MOV.L #00000001H, [R0]
000000B8 08                   S  		BRA L29
000000B9                         L28:	; bb21
000000B9 F80600                  		MOV.L #00000000H, [R0]
000000BC                         L29:	; bb22
000000BC EC01                    		MOV.L [R0], R1
000000BE 6101                    		CMP #00H, R1
000000C0 3Brrrr               W  		BNE L47
000000C3                         L30:	; bb27
                                 ;     112             continue;
                                 ;     113 
                                 ;     114 		if (++sw.count[i] == SW_LOCKOUT_TICKS) {		// state is either lockout or deglitching
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",114
000000C3 FB12rrrrrrrr            		MOV.L #_sw, R1
000000C9 490106                  		ADD 06H[R0].UB, R1
000000CC B69A                    		MOVU.B 1BH[R1], R2
000000CE 6212                    		ADD #01H, R2
000000D0 869A                    		MOV.B R2, 1BH[R1]
000000D2 8E99                    		MOV.B 1BH[R1], R1
000000D4 755119                  		CMP #19H, R1
000000D7 21rr                    		BNE L36
000000D9                         L31:	; bb28
                                 ;     115 			sw.debounce[i] = SW_IDLE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",115
000000D9 FB12rrrrrrrr            		MOV.L #_sw, R1
000000DF 490106                  		ADD 06H[R0].UB, R1
000000E2 3C9300                  		MOV.B #00H, 13H[R1]
000000E5                         L32:	; bb28.split
                                 ;     116             // check if the state has changed while we were in lockout...
                                 ;     117             uint8_t old_state = sw.state[i];
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",117
000000E5 FB12rrrrrrrr            		MOV.L #_sw, R1
000000EB 490106                  		ADD 06H[R0].UB, R1
000000EE C5100307                		MOV.B 03H[R1], 07H[R0]
000000F2                         L33:	; bb28.split1
                                 ;     118             if(old_state != read_switch(i)) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",118
000000F2 B181                    		MOVU.B 06H[R0], R1
000000F4 B18E                    		MOVU.B 07H[R0], R6
000000F6 39rrrr               W  		BSR _read_switch
000000F9 4716                    		CMP R1, R6
000000FB 3Arrrr               W  		BEQ L47
000000FE                         L34:	; bb37
                                 ;     119                 sw.debounce[i] = SW_DEGLITCHING;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",119
000000FE FB12rrrrrrrr            		MOV.L #_sw, R1
00000104 490106                  		ADD 06H[R0].UB, R1
00000107 3C9301                  		MOV.B #01H, 13H[R1]
0000010A                         L35:	; bb37.split
                                 ;     120                 sw.count[i] = -SW_DEGLITCH_TICKS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",120
0000010A FB12rrrrrrrr            		MOV.L #_sw, R1
00000110 490106                  		ADD 06H[R0].UB, R1
00000113 3C9BFB                  		MOV.B #0FBH, 1BH[R1]
00000116 2Err                 B  		BRA L47
00000118                         L36:	; bb65
                                 ;     121             }
                                 ;     122             continue;
                                 ;     123 		}
                                 ;     124 		if (sw.count[i] == 0) {							// trigger point
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",124
00000118 FB12rrrrrrrr            		MOV.L #_sw, R1
0000011E 490106                  		ADD 06H[R0].UB, R1
00000121 8E99                    		MOV.B 1BH[R1], R1
00000123 6101                    		CMP #00H, R1
00000125 21rr                    		BNE L47
00000127                         L37:	; bb66
                                 ;     125 			sw.sw_num_thrown = i;						// record number of thrown switch
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",125
00000127 FBE2rrrrrrrr            		MOV.L #_sw, R14
0000012D C50E0602                		MOV.B 06H[R0], 02H[R14]
00000131                         L38:	; bb66.split
                                 ;     126 			sw.debounce[i] = SW_LOCKOUT;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",126
00000131 FB12rrrrrrrr            		MOV.L #_sw, R1
00000137 490106                  		ADD 06H[R0].UB, R1
0000013A 3C9302                  		MOV.B #02H, 13H[R1]
0000013D                         L39:	; bb66.split2
                                 ;     127 //			sw_show_switch();							// only called if __DEBUG enabled
                                 ;     128 
                                 ;     129 			if ((cm.cycle_state == CYCLE_HOMING) || (cm.cycle_state == CYCLE_PROBE)) {		// regardless of switch type
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",129
0000013D FBE2rrrrrrrr            		MOV.L #_cm, R14
00000143 5AEE1E02                		MOVU.B 021EH[R14], R14
00000147 613E                    		CMP #03H, R14
00000149 20rr                    		BEQ L44
0000014B 2Err                 B  		BRA L43
0000014D                         L40:	; bb72
                                 ;     130 				cm_request_feedhold();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",130
0000014D 05rrrrrr             A  		BSR _cm_request_feedhold
00000151 2Err                 B  		BRA L47
00000153                         L41:	; bb74
                                 ;     131 			} else if (sw.mode[i] & SW_LIMIT_BIT) {		// should be a limit switch, so fire it.
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",131
00000153 FBE2rrrrrrrr            		MOV.L #_sw, R14
00000159 490E06                  		ADD 06H[R0].UB, R14
0000015C F5E10B                  		BTST #01H, 0BH[R14].B
0000015F 20rr                    		BEQ L47
00000161                         L42:	; bb75
                                 ;     132 				sw.limit_flag = true;					// triggers an emergency shutdown
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",132
00000161 FB12rrrrrrrr            		MOV.L #_sw, R1
00000167 3C1101                  		MOV.B #01H, 01H[R1]
0000016A 2Err                 B  		BRA L47
0000016C                         L43:	; bb91
0000016C FBE2rrrrrrrr            		MOV.L #_cm, R14
00000172 5AEE1E02                		MOVU.B 021EH[R14], R14
00000176 612E                    		CMP #02H, R14
00000178 18                   S  		BNE L45
00000179                         L44:	; bb96
00000179 F80601                  		MOV.L #00000001H, [R0]
0000017C 08                   S  		BRA L46
0000017D                         L45:	; bb97
0000017D F80600                  		MOV.L #00000000H, [R0]
00000180                         L46:	; bb98
00000180 EC01                    		MOV.L [R0], R1
00000182 6101                    		CMP #00H, R1
00000184 21rr                    		BNE L40
00000186 2Err                 B  		BRA L41
00000188                         L47:	; bb113
00000188 B181                    		MOVU.B 06H[R0], R1
0000018A 6211                    		ADD #01H, R1
0000018C 8181                    		MOV.B R1, 06H[R0]
0000018E                         L48:	; bb116
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",110
0000018E B181                    		MOVU.B 06H[R0], R1
00000190 6181                    		CMP #08H, R1
00000192 28rr                  * 		BLT L25
         38rrrr                  
00000197                         L49:	; return
                                 ;     133 			}
                                 ;     134 		}
                                 ;     135 	}
                                 ;     136 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",136
00000197 3F6603                  		RTSD #0CH, R6-R6
0000019A                         _get_switch_mode:
                                 		.STACK	_get_switch_mode=8
                                 ;     137 
                                 ;     138 /*
                                 ;     139  * get_switch_mode()  - return switch mode setting
                                 ;     140  * get_limit_thrown() - return true if a limit was tripped
                                 ;     141  * get_switch_num()   - return switch number most recently thrown
                                 ;     142  */
                                 ;     143 
                                 ;     144 uint8_t get_switch_mode(uint8_t sw_num) { return (sw.mode[sw_num]);}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",144
0000019A 6040                    		SUB #04H, R0
0000019C 8089                    		MOV.B R1, 03H[R0]
0000019E FBE2rrrrrrrr            		MOV.L #_sw, R14
000001A4 490E03                  		ADD 03H[R0].UB, R14
000001A7 C5E00B02                		MOV.B 0BH[R14], 02H[R0]
000001AB B081                    		MOVU.B 02H[R0], R1
000001AD 6701                    		RTSD #04H
000001AF                         _get_limit_switch_thrown:
                                 		.STACK	_get_limit_switch_thrown=8
                                 ;     145 uint8_t get_limit_switch_thrown(void) { return(sw.limit_flag);}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",145
000001AF 6040                    		SUB #04H, R0
000001B1 FBE2rrrrrrrr            		MOV.L #_sw, R14
000001B7 C5E00103                		MOV.B 01H[R14], 03H[R0]
000001BB B089                    		MOVU.B 03H[R0], R1
000001BD 6701                    		RTSD #04H
000001BF                         _get_switch_thrown:
                                 		.STACK	_get_switch_thrown=8
                                 ;     146 uint8_t get_switch_thrown(void) { return(sw.sw_num_thrown);}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",146
000001BF 6040                    		SUB #04H, R0
000001C1 FBE2rrrrrrrr            		MOV.L #_sw, R14
000001C7 C5E00203                		MOV.B 02H[R14], 03H[R0]
000001CB B089                    		MOVU.B 03H[R0], R1
000001CD 6701                    		RTSD #04H
000001CF                         _set_switch_type:
                                 		.STACK	_set_switch_type=8
                                 ;     147 
                                 ;     148 
                                 ;     149 // global switch type
                                 ;     150 void set_switch_type( uint8_t switch_type ) { sw.switch_type = switch_type; }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",150
000001CF 6040                    		SUB #04H, R0
000001D1 8089                    		MOV.B R1, 03H[R0]
000001D3 FBE2rrrrrrrr            		MOV.L #_sw, R14
000001D9 C3E1                    		MOV.B R1, [R14]
000001DB 6701                    		RTSD #04H
000001DD                         _get_switch_type:
                                 		.STACK	_get_switch_type=8
                                 ;     151 uint8_t get_switch_type() { return sw.switch_type; }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",151
000001DD 6040                    		SUB #04H, R0
000001DF FBE2rrrrrrrr            		MOV.L #_sw, R14
000001E5 C4E003                  		MOV.B [R14], 03H[R0]
000001E8 B089                    		MOVU.B 03H[R0], R1
000001EA 6701                    		RTSD #04H
000001EC                         _reset_switches:
                                 		.STACK	_reset_switches=8
                                 ;     152 
                                 ;     153 /*
                                 ;     154  * reset_switches() - reset all switches and reset limit flag
                                 ;     155  */
                                 ;     156 
                                 ;     157 void reset_switches()
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",157
000001EC 6040                    		SUB #04H, R0
                                 ;     158 {
                                 ;     159 	for (uint8_t i=0; i < NUM_SWITCHES; i++) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",159
000001EE 3C0300                  		MOV.B #00H, 03H[R0]
000001F1 2Err                 B  		BRA L58
000001F3                         L56:	; bb
                                 ;     160 		sw.debounce[i] = SW_IDLE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",160
000001F3 FB12rrrrrrrr            		MOV.L #_sw, R1
000001F9 490103                  		ADD 03H[R0].UB, R1
000001FC 3C9300                  		MOV.B #00H, 13H[R1]
000001FF                         L57:	; bb.split
                                 ;     161         read_switch(i);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",161
000001FF B089                    		MOVU.B 03H[R0], R1
00000201 39rrrr               W  		BSR _read_switch
00000204 B089                    		MOVU.B 03H[R0], R1
00000206 6211                    		ADD #01H, R1
00000208 8089                    		MOV.B R1, 03H[R0]
0000020A                         L58:	; bb8
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",159
0000020A B089                    		MOVU.B 03H[R0], R1
0000020C 6181                    		CMP #08H, R1
0000020E 29rr                    		BLT L56
00000210                         L59:	; bb13
                                 ;     162 	}
                                 ;     163 	sw.limit_flag = false;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",163
00000210 FB12rrrrrrrr            		MOV.L #_sw, R1
00000216 3C1100                  		MOV.B #00H, 01H[R1]
00000219 6701                    		RTSD #04H
0000021B                         _read_switch:
                                 		.STACK	_read_switch=12
                                 ;     164 }
                                 ;     165 
                                 ;     166 /*
                                 ;     167  * read_switch() - read a switch directly with no interrupts or deglitching
                                 ;     168  */
                                 ;     169 uint8_t read_switch(uint8_t sw_num)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",169
0000021B 6080                    		SUB #08H, R0
0000021D 8189                    		MOV.B R1, 07H[R0]
                                 ;     170 {
                                 ;     171 	if (sw_num >= NUM_SWITCHES) return (uint8_t)(SW_DISABLED);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",171
0000021F B189                    		MOVU.B 07H[R0], R1
00000221 6181                    		CMP #08H, R1
00000223 29rr                    		BLT L62
00000225                         L61:	; bb3
00000225 3C04FF                  		MOV.B #0FFH, 04H[R0]
00000228 2Err                 B  		BRA L74
0000022A                         L62:	; bb9
                                 ;     172 
                                 ;     173 	uint8_t read = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",173
0000022A 3C0500                  		MOV.B #00H, 05H[R0]
0000022D                         L63:	; bb9.split
                                 ;     174 	switch (sw_num) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",174
0000022D B189                    		MOVU.B 07H[R0], R1
0000022F 6141                    		CMP #04H, R1
00000231 21rr                    		BNE L65
00000233                         L64:	; bb12
00000233 FBEE41C008              		MOV.L #0008C041H, R14
                                 ;     175 //		case SW_MIN_X: { read = hw.sw_port[AXIS_X]->IN & SW_MIN_BIT_bm; break;}
                                 ;     176 //		case SW_MAX_X: { read = hw.sw_port[AXIS_X]->IN & SW_MAX_BIT_bm; break;}
                                 ;     177 //		case SW_MIN_Y: { read = hw.sw_port[AXIS_Y]->IN & SW_MIN_BIT_bm; break;}
                                 ;     178 //		case SW_MAX_Y: { read = hw.sw_port[AXIS_Y]->IN & SW_MAX_BIT_bm; break;}
                                 ;     179 		case SW_MIN_Z: { read = MATERIAL; break;}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",179
00000238 58E1                    		MOVU.B [R14], R1
0000023A 6821                    		SHLR #02H, R1
0000023C 6411                    		AND #01H, R1
0000023E 8109                    		MOV.B R1, 05H[R0]
00000240                         L65:	; bb19
                                 ;     180 //		case SW_MAX_Z: { read = MATERIAL; break;}
                                 ;     181 //		case SW_MIN_A: { read = hw.sw_port[AXIS_A]->IN & SW_MIN_BIT_bm; break;}
                                 ;     182 //		case SW_MAX_A: { read = hw.sw_port[AXIS_A]->IN & SW_MAX_BIT_bm; break;}
                                 ;     183 	}
                                 ;     184 	if (sw.switch_type == SW_TYPE_NORMALLY_OPEN) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",184
00000240 FBE2rrrrrrrr            		MOV.L #_sw, R14
00000246 58EE                    		MOVU.B [R14], R14
00000248 610E                    		CMP #00H, R14
0000024A B109                    		MOVU.B 05H[R0], R1
0000024C B18A                    		MOVU.B 07H[R0], R2
0000024E 21rr                    		BNE L70
00000250                         L66:	; bb20
                                 ;     185 		sw.state[sw_num] = ((read == 0) ? SW_CLOSED : SW_OPEN);// confusing. An NO switch drives the pin LO when thrown
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",185
00000250 6101                    		CMP #00H, R1
00000252 18                   S  		BNE L68
00000253                         L67:	; bb28
00000253 F80601                  		MOV.L #00000001H, [R0]
00000256 08                   S  		BRA L69
00000257                         L68:	; bb29
00000257 F80600                  		MOV.L #00000000H, [R0]
0000025A                         L69:	; bb30
0000025A FBE2rrrrrrrr            		MOV.L #_sw, R14
00000260 623E                    		ADD #03H, R14
00000262 EC01                    		MOV.L [R0], R1
00000264 FE02E1                  		MOV.B R1, [R2,R14]
                                 ;     186 		return (sw.state[sw_num]);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",186
00000267 B189                    		MOVU.B 07H[R0], R1
00000269 FECE11                  		MOVU.B [R14,R1], R1
0000026C 8101                    		MOV.B R1, 04H[R0]
0000026E 2Err                 B  		BRA L74
00000270                         L70:	; bb39
                                 ;     187 	} else {
                                 ;     188 		sw.state[sw_num] = ((read != 0) ? SW_CLOSED : SW_OPEN);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",188
00000270 6101                    		CMP #00H, R1
00000272 10                   S  		BEQ L72
00000273                         L71:	; bb47
00000273 F80601                  		MOV.L #00000001H, [R0]
00000276 08                   S  		BRA L73
00000277                         L72:	; bb48
00000277 F80600                  		MOV.L #00000000H, [R0]
0000027A                         L73:	; bb49
0000027A FBE2rrrrrrrr            		MOV.L #_sw, R14
00000280 623E                    		ADD #03H, R14
00000282 EC01                    		MOV.L [R0], R1
00000284 FE02E1                  		MOV.B R1, [R2,R14]
                                 ;     189 		return (sw.state[sw_num]);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",189
00000287 B189                    		MOVU.B 07H[R0], R1
00000289 FECE11                  		MOVU.B [R14,R1], R1
0000028C 8101                    		MOV.B R1, 04H[R0]
0000028E                         L74:	; bb65
0000028E C5000406                		MOV.B 04H[R0], 06H[R0]
                                 ;     190 	}
                                 ;     191 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",191
00000292 B181                    		MOVU.B 06H[R0], R1
00000294 6702                    		RTSD #08H
00000296                         _sw_set_st:
                                 		.STACK	_sw_set_st=12
                                 ;     192 
                                 ;     193 /*
                                 ;     194  * _show_switch() - simple display routine
                                 ;     195  */
                                 ;     196 /*
                                 ;     197 void sw_show_switch(void)
                                 ;     198 {
                                 ;     199 	fprintf_P(stderr, PSTR("Limit Switch Thrown Xmin %d Xmax %d  Ymin %d Ymax %d  \
                                 ;     200 		Zmin %d Zmax %d Amin %d Amax %d\n"),
                                 ;     201 		sw.state[SW_MIN_X], sw.state[SW_MAX_X],
                                 ;     202 		sw.state[SW_MIN_Y], sw.state[SW_MAX_Y],
                                 ;     203 		sw.state[SW_MIN_Z], sw.state[SW_MAX_Z],
                                 ;     204 		sw.state[SW_MIN_A], sw.state[SW_MAX_A]);
                                 ;     205 }
                                 ;     206 */
                                 ;     207 
                                 ;     208 /***********************************************************************************
                                 ;     209  * CONFIGURATION AND INTERFACE FUNCTIONS
                                 ;     210  * Functions to get and set variables from the cfgArray table
                                 ;     211  * These functions are not part of the NIST defined functions
                                 ;     212  ***********************************************************************************/
                                 ;     213 
                                 ;     214 stat_t sw_set_st(nvObj_t *nv)			// switch type (global)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",214
00000296 6080                    		SUB #08H, R0
00000298 A009                    		MOV.L R1, 04H[R0]
                                 ;     215 {
                                 ;     216 	set_01(nv);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",216
0000029A 05rrrrrr             A  		BSR _set_01
0000029E                         L76:	; entry.split
                                 ;     217 	switch_init();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",217
0000029E 39rrrr               W  		BSR _switch_init
000002A1                         L77:	; entry.split1
                                 ;     218 	return (STAT_OK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",218
000002A1 3C0300                  		MOV.B #00H, 03H[R0]
000002A4 B089                    		MOVU.B 03H[R0], R1
000002A6                         L78:	; entry.split2
                                 ;     219 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",219
000002A6 5B11                    		MOVU.B R1, R1
000002A8 6702                    		RTSD #08H
000002AA                         _sw_set_sw:
                                 		.STACK	_sw_set_sw=12
                                 ;     220 
                                 ;     221 stat_t sw_set_sw(nvObj_t *nv)			// switch setting
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",221
000002AA 6080                    		SUB #08H, R0
000002AC A009                    		MOV.L R1, 04H[R0]
000002AE FBE200004040            		MOV.L #40400000H, R14
                                 ;     222 {
                                 ;     223 	if (nv->value > SW_MODE_MAX_VALUE)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",223
000002B4 FC851E04                		FCMP 10H[R1].L, R14
000002B8 26rr                    		BPZ L81
000002BA                         L80:	; bb2
                                 ;     224         return (STAT_INPUT_VALUE_RANGE_ERROR);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",224
000002BA 3C026E                  		MOV.B #6EH, 02H[R0]
000002BD 2Err                 B  		BRA L84
000002BF                         L81:	; bb9
                                 ;     225 	set_ui8(nv);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",225
000002BF A809                    		MOV.L 04H[R0], R1
000002C1 05rrrrrr             A  		BSR _set_ui8
000002C5                         L82:	; bb9.split
                                 ;     226 	switch_init();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",226
000002C5 39rrrr               W  		BSR _switch_init
000002C8                         L83:	; bb9.split1
                                 ;     227 	return (STAT_OK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",227
000002C8 3C0200                  		MOV.B #00H, 02H[R0]
000002CB                         L84:	; bb13
000002CB C5000203                		MOV.B 02H[R0], 03H[R0]
                                 ;     228 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",228
000002CF B089                    		MOVU.B 03H[R0], R1
000002D1 6702                    		RTSD #08H
000002D3                         _sw_print_st:
                                 		.STACK	_sw_print_st=8
                                 ;     229 
                                 ;     230 /***********************************************************************************
                                 ;     231  * TEXT MODE SUPPORT
                                 ;     232  * Functions to print variables from the cfgArray table
                                 ;     233  ***********************************************************************************/
                                 ;     234 
                                 ;     235 #ifdef __TEXT_MODE
                                 ;     236 
                                 ;     237 static const char fmt_st[] PROGMEM = "[st]  switch type%18d [0=NO,1=NC]\n";
                                 ;     238 void sw_print_st(nvObj_t *nv) { text_print_ui8(nv, fmt_st);}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\switch.c",238
000002D3 6040                    		SUB #04H, R0
000002D5 E301                    		MOV.L R1, [R0]
000002D7 FB22rrrrrrrr            		MOV.L #__$fmt_st, R2
000002DD 05rrrrrr             A  		BSR _text_print_ui8
000002E1 6701                    		RTSD #04H
                                 ;     239 
                                 ;     240 //static const char fmt_ss[] PROGMEM = "Switch %s state:     %d\n";
                                 ;     241 //void sw_print_ss(nvObj_t *nv) { fprintf(stderr, fmt_ss, nv->token, (uint8_t)nv->value);}
                                 ;     242 
                                 ;     243 /*
                                 ;     244 static const char msg_sw0[] PROGMEM = "Disabled";
                                 ;     245 static const char msg_sw1[] PROGMEM = "NO homing";
                                 ;     246 static const char msg_sw2[] PROGMEM = "NO homing & limit";
                                 ;     247 static const char msg_sw3[] PROGMEM = "NC homing";
                                 ;     248 static const char msg_sw4[] PROGMEM = "NC homing & limit";
                                 ;     249 static const char *const msg_sw[] PROGMEM = { msg_sw0, msg_sw1, msg_sw2, msg_sw3, msg_sw4 };
                                 ;     250 */
                                 ;     251 
                                 ;     252 
                                 ;     253 #endif
                                 ;     254 
                                 ;     255 /*============== G2 switch code - completely different, for now ===================
                                 ;     256 
                                 ;     257 #include "tinyg2.h"
                                 ;     258 #include "switch.h"
                                 ;     259 #include "hardware.h"
                                 ;     260 #include "canonical_machine.h"
                                 ;     261 
                                 ;     262 // Allocate switch array structure
                                 ;     263 switches_t sw;
                                 ;     264 
                                 ;     265 static void _no_action(switch_t *s);
                                 ;     266 static void _led_on(switch_t *s);
                                 ;     267 static void _led_off(switch_t *s);
                                 ;     268 static void _trigger_feedhold(switch_t *s);
                                 ;     269 static void _trigger_cycle_start(switch_t *s);
                                 ;     270 
                                 ;     271  *
                                 ;     272  * switch_init() - initialize homing/limit switches
                                 ;     273  *
                                 ;     274  *	This function assumes all Motate pins have been set up and that
                                 ;     275  *	SW_PAIRS and SW_POSITIONS is accurate
                                 ;     276  *
                                 ;     277  *	Note: `type` and `mode` are not initialized as they should be set from configuration
                                 ;     278  *
                                 ;     279 
                                 ;     280 void switch_init(void)
                                 ;     281 {
                                 ;     282 //	sw.type = SW_NORMALLY_OPEN;				// set from config
                                 ;     283 
                                 ;     284 	switch_t *s;	// shorthand
                                 ;     285 
                                 ;     286 	for (uint8_t axis=0; axis<SW_PAIRS; axis++) {
                                 ;     287 		for (uint8_t position=0; position<SW_POSITIONS; position++) {
                                 ;     288 			s = &sw.s[axis][position];
                                 ;     289 
                                 ;     290 			s->type = sw.type;				// propagate type from global type
                                 ;     291 //			s->mode = SW_MODE_DISABLED;		// set from config
                                 ;     292 			s->state = false;
                                 ;     293 			s->edge = SW_NO_EDGE;
                                 ;     294 			s->debounce_ticks = SW_LOCKOUT_TICKS;
                                 ;     295 			s->debounce_timeout = 0;
                                 ;     296 
                                 ;     297 			// functions bound to each switch
                                 ;     298 			s->when_open = _no_action;
                                 ;     299 			s->when_closed = _no_action;
                                 ;     300 			s->on_leading = _trigger_feedhold;
                                 ;     301 			s->on_trailing = _trigger_cycle_start;
                                 ;     302 		}
                                 ;     303 	}
                                 ;     304 	// functions bound to individual switches
                                 ;     305 	// <none>
                                 ;     306 	// sw.s[AXIS_X][SW_MIN].when_open = _led_off;
                                 ;     307 	// sw.s[AXIS_X][SW_MIN].when_closed = _led_on;
                                 ;     308 }
                                 ;     309 
                                 ;     310 static void _no_action(switch_t *s) { return; }
                                 ;     311 static void _led_on(switch_t *s) { IndicatorLed.clear(); }
                                 ;     312 static void _led_off(switch_t *s) { IndicatorLed.set(); }
                                 ;     313 
                                 ;     314  *
                                 ;     315  * poll_switches() - run a polling cycle on all switches
                                 ;     316  *
                                 ;     317 
                                 ;     318 stat_t poll_switches()
                                 ;     319 {
                                 ;     320 	read_switch(&sw.s[AXIS_X][SW_MIN], axis_X_min_pin);
                                 ;     321 	read_switch(&sw.s[AXIS_X][SW_MAX], axis_X_max_pin);
                                 ;     322 	read_switch(&sw.s[AXIS_Y][SW_MIN], axis_Y_min_pin);
                                 ;     323 	read_switch(&sw.s[AXIS_Y][SW_MAX], axis_Y_max_pin);
                                 ;     324 	read_switch(&sw.s[AXIS_Z][SW_MIN], axis_Z_min_pin);
                                 ;     325 	read_switch(&sw.s[AXIS_Z][SW_MAX], axis_Z_max_pin);
                                 ;     326 	read_switch(&sw.s[AXIS_A][SW_MIN], axis_A_min_pin);
                                 ;     327 	read_switch(&sw.s[AXIS_A][SW_MAX], axis_A_max_pin);
                                 ;     328 	read_switch(&sw.s[AXIS_B][SW_MIN], axis_B_min_pin);
                                 ;     329 	read_switch(&sw.s[AXIS_B][SW_MAX], axis_B_max_pin);
                                 ;     330 	read_switch(&sw.s[AXIS_C][SW_MIN], axis_C_min_pin);
                                 ;     331 	read_switch(&sw.s[AXIS_C][SW_MAX], axis_C_max_pin);
                                 ;     332 	return (STAT_OK);
                                 ;     333 }
                                 ;     334 
                                 ;     335  *
                                 ;     336  * read_switch() - read switch with NO/NC, debouncing and edge detection
                                 ;     337  *
                                 ;     338  *	Returns true if switch state changed - e.g. leading or falling edge detected
                                 ;     339  *	Assumes pin_value input = 1 means open, 0 is closed. Pin sense is adjusted to mean:
                                 ;     340  *	  0 = open for both NO and NC switches
                                 ;     341  *	  1 = closed for both NO and NC switches
                                 ;     342  *
                                 ;     343 uint8_t read_switch(switch_t *s, uint8_t pin_value)
                                 ;     344 {
                                 ;     345 	// instant return conditions: switch disabled or in a lockout period
                                 ;     346 	if (s->mode == SW_MODE_DISABLED) {
                                 ;     347 		return (false);
                                 ;     348 	}
                                 ;     349 	if (s->debounce_timeout > GetTickCount()) {
                                 ;     350 		return (false);
                                 ;     351 	}
                                 ;     352 	// return if no change in state
                                 ;     353 	uint8_t pin_sense_corrected = (pin_value ^ (s->type ^ 1));	// correct for NO or NC mode
                                 ;     354   	if ( s->state == pin_sense_corrected) {
                                 ;     355 		s->edge = SW_NO_EDGE;
                                 ;     356 		if (s->state == SW_OPEN) {
                                 ;     357 			s->when_open(s);
                                 ;     358 		} else {
                                 ;     359 			s->when_closed(s);
                                 ;     360 		}
                                 ;     361 		return (false);
                                 ;     362 	}
                                 ;     363 	// the switch legitimately changed state - process edges
                                 ;     364 	if ((s->state = pin_sense_corrected) == SW_OPEN) {
                                 ;     365 			s->edge = SW_TRAILING;
                                 ;     366 			s->on_trailing(s);
                                 ;     367 		} else {
                                 ;     368 			s->edge = SW_LEADING;
                                 ;     369 			s->on_leading(s);
                                 ;     370 	}
                                 ;     371 	s->debounce_timeout = (GetTickCount() + s->debounce_ticks);
                                 ;     372 	return (true);
                                 ;     373 }
                                 ;     374 
                                 ;     375 static void _trigger_feedhold(switch_t *s)
                                 ;     376 {
                                 ;     377 	IndicatorLed.toggle();
                                 ;     378 	cm_request_feedhold();
                                 ;     379 
                                 ;     380 //	if (cm.cycle_state == CYCLE_HOMING) {		// regardless of switch type
                                 ;     381 //		cm.request_feedhold = true;
                                 ;     382 //	} else if (s->mode & SW_LIMIT_BIT) {		// set flag if it's a limit switch
                                 ;     383 //		cm.limit_tripped_flag = true;
                                 ;     384 //	}
                                 ;     385 
                                 ;     386 }
                                 ;     387 
                                 ;     388 static void _trigger_cycle_start(switch_t *s)
                                 ;     389 {
                                 ;     390 	IndicatorLed.toggle();
                                 ;     391 	cm_request_cycle_start();
                                 ;     392 }
                                 ;     393 
                                 ;     394  *
                                 ;     395  * switch_get_switch_mode()  - return switch mode setting
                                 ;     396  * switch_get_limit_thrown() - return true if a limit was tripped
                                 ;     397  * switch_get_sw_num()  	 - return switch number most recently thrown
                                 ;     398  *
                                 ;     399 
                                 ;     400 uint8_t get_switch_mode(uint8_t sw_num) { return (0);}	// ++++
                                 ;     401 
                                 ;     402 */
                                 		.SECTION	C_1,ROMDATA
00000000                         __$fmt_st:
00000000 5B73745D                		.byte	"[st]  switch type%18d [0=NO,1=NC]"
         20207377                
         69746368                
         20747970                
         65253138                
         64205B30                
         3D4E4F2C                
         313D4E43                
         5D                      
00000021 0A00                    		.byte	0AH,00H
                                 		.SECTION	D_1,ROMDATA
00000000                         _zinhibitor:
00000000 00                      		.byte	00H
                                 		.SECTION	B_1,DATA
00000000                         _sw:
00000000(00000023H)              		.blkb	35
                                 		.END

Information List

TOTAL ERROR(S)    00000
TOTAL WARNING(S)  00000
TOTAL LINE(S)     00868   LINES

Section List

Attr         Size               Name
CODE     0000000739(000002E3H)  P
ROMDATA  0000000035(00000023H)  C_1
ROMDATA  0000000001(00000001H)  D_1
DATA     0000000035(00000023H)  B_1

Cpu Type

-ISA=RXV1 -FPU

Command Parameter

-subcommand=C:\Users\LAFONS~1\AppData\Local\Temp\$ccrx4DB7\$ccrx\switch.src.cmd
    -nologo
    -isa=rxv1
    -fpu
    -show=conditionals,definitions,expansions
    -define=__RXV1=1
    -fint_register=0
    -debug
    -endian=little
-listfile=C:\Workspace\e2studio\git\MT01_master\MT01_build\switch.lst
-output=C:\Workspace\e2studio\git\MT01_master\MT01_build\src\cnc\switch.obj
