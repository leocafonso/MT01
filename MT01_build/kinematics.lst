* RX FAMILY ASSEMBLER V2.03.00.01 [24 Oct 2014] *  SOURCE LIST  Mon Mar 20 17:11:42 2017

LOC.     OBJ.              0XMDA SOURCE STATEMENT

                                 ;RX Family C/C++ Compiler (V2.03.00.03 [04 Dec 2014])  20-Mar-2017 17:11:42
                                 
                                 ;*** CPU TYPE ***
                                 
                                 ;-ISA=RXV1
                                 
                                 ;*** COMMAND PARAMETER ***
                                 
                                 ;-output=src=kinematics.src
                                 ;-lang=c99
                                 ;-include=C:\PROGRA~2\Renesas\RX\2_3_0/include,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx\src,C:/Workspace/e2studio/
                                 ;-debug
                                 ;-show=source,conditionals,definitions,expansions
                                 ;-listfile=kinematics.lst
                                 ;-isa=rxv1
                                 ;-optimize=0
                                 ;-fpu
                                 ;-alias=noansi
                                 ;-nologo
                                 ;-nomessage
                                 ;-define=__RX,COMPACTAXP=0,EASYMAK=1,MOBILE=0,FREE_RTOS_PP
                                 ;kinematics.c
                                 
                                 		.glb	_cm
                                 		.glb	_st_cfg
                                 		.glb	_ik_kinematics
                                 ;LineNo. C-SOURCE STATEMENT
                                 
                                 		.SECTION	P,CODE
00000000                         _ik_kinematics:
                                 		.STACK	_ik_kinematics=40
                                 ;       1 /*
                                 ;       2  * kinematics.c - inverse kinematics routines
                                 ;       3  * This file is part of the TinyG project
                                 ;       4  *
                                 ;       5  * Copyright (c) 2010 - 2015 Alden S. Hart, Jr.
                                 ;       6  *
                                 ;       7  * This file ("the software") is free software: you can redistribute it and/or modify
                                 ;       8  * it under the terms of the GNU General Public License, version 2 as published by the
                                 ;       9  * Free Software Foundation. You should have received a copy of the GNU General Public
                                 ;      10  * License, version 2 along with the software.  If not, see <http://www.gnu.org/licenses/>.
                                 ;      11  *
                                 ;      12  * As a special exception, you may use this file as part of a software library without
                                 ;      13  * restriction. Specifically, if other files instantiate templates or use macros or
                                 ;      14  * inline functions from this file, or you compile this file and link it with  other
                                 ;      15  * files to produce an executable, this file does not by itself cause the resulting
                                 ;      16  * executable to be covered by the GNU General Public License. This exception does not
                                 ;      17  * however invalidate any other reasons why the executable file might be covered by the
                                 ;      18  * GNU General Public License.
                                 ;      19  *
                                 ;      20  * THE SOFTWARE IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT WITHOUT ANY
                                 ;      21  * WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
                                 ;      22  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
                                 ;      23  * SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                 ;      24  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
                                 ;      25  * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                                 ;      26  */
                                 ;      27 
                                 ;      28 #include "tinyg.h"
                                 ;      29 #include "config.h"
                                 ;      30 #include "canonical_machine.h"
                                 ;      31 #include "stepper.h"
                                 ;      32 #include "kinematics.h"
                                 ;      33 
                                 ;      34 #ifdef __cplusplus
                                 ;      35 extern "C"{
                                 ;      36 #endif
                                 ;      37 
                                 ;      38 //static void _inverse_kinematics(float travel[], float joint[]);
                                 ;      39 
                                 ;      40 /*
                                 ;      41  * ik_kinematics() - wrapper routine for inverse kinematics
                                 ;      42  *
                                 ;      43  *	Calls kinematics function(s).
                                 ;      44  *	Performs axis mapping & conversion of length units to steps (and deals with inhibited axes)
                                 ;      45  *
                                 ;      46  *	The reason steps are returned as floats (as opposed to, say, uint32_t) is to accommodate
                                 ;      47  *	fractional DDA steps. The DDA deals with fractional step values as fixed-point binary in
                                 ;      48  *	order to get the smoothest possible operation. Steps are passed to the move prep routine
                                 ;      49  *	as floats and converted to fixed-point binary during queue loading. See stepper.c for details.
                                 ;      50  */
                                 ;      51 
                                 ;      52 void ik_kinematics(const float travel[], float steps[])
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",52
00000000 7100DC                  		ADD #0FFFFFFDCH, R0
00000003 A201                    		MOV.L R1, 20H[R0]
00000005 A18A                    		MOV.L R2, 1CH[R0]
00000007 754318                  		MOV.L #00000018H, R3
0000000A EF01                    		MOV.L R0, R1
                                 ;      53 {
                                 ;      54 	float joint[AXES];
                                 ;      55 
                                 ;      56 //	_inverse_kinematics(travel, joint);				// you can insert inverse kinematics transformations here
                                 ;      57 	memcpy(joint, travel, sizeof(float)*AXES);		//...or just do a memcpy for Cartesian machines
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",57
0000000C AA02                    		MOV.L 20H[R0], R2
0000000E 7F8F                    		SMOVF
00000010                         L11:	; entry.split
                                 ;      58 
                                 ;      59 	// Map motors to axes and convert length units to steps
                                 ;      60 	// Most of the conversion math has already been done in during config in steps_per_unit()
                                 ;      61 	// which takes axis travel, step angle and microsteps into account.
                                 ;      62 	for (uint8_t axis=0; axis<AXES; axis++) {
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",62
00000010 3C8B00                  		MOV.B #00H, 1BH[R0]
00000013 38rrrr               W  		BRA L23
00000016                         L12:	; bb8
                                 ;      63 		if (cm.a[axis].axis_mode == AXIS_INHIBITED) { joint[axis] = 0;}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",63
00000016 B689                    		MOVU.B 1BH[R0], R1
00000018 751138                  		MUL #38H, R1
0000001B FBE2rrrrrrrr            		MOV.L #_cm, R14
00000021 4B1E                    		ADD R1, R14
00000023 59EECC                  		MOVU.B 0CCH[R14], R14
00000026 612E                    		CMP #02H, R14
00000028 18                   S  		BNE L14
00000029                         L13:	; bb9
00000029 B689                    		MOVU.B 1BH[R0], R1
0000002B EF0E                    		MOV.L R0, R14
0000002D 660F                    		MOV.L #00000000H, R15
0000002F FE21EF                  		MOV.L R15, [R1,R14]
00000032                         L14:	; bb23
                                 ;      64 		if (st_cfg.mot[MOTOR_1].motor_map == axis) { steps[MOTOR_1] = joint[axis] * st_cfg.mot[MOTOR_1].steps_per_unit;}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",64
00000032 FB12rrrrrrrr            		MOV.L #_st_cfg, R1
00000038 B111                    		MOVU.B 04H[R1], R1
0000003A 45011B                  		CMP 1BH[R0].UB, R1
0000003D 21rr                    		BNE L16
0000003F                         L15:	; bb24
0000003F EF0E                    		MOV.L R0, R14
00000041 B689                    		MOVU.B 1BH[R0], R1
00000043 FE61EE                  		MOV.L [R1,R14], R14
00000046 FBF2rrrrrrrr            		MOV.L #_st_cfg, R15
0000004C FC8DFE07                		FMUL 1CH[R15].L, R14
00000050 A989                    		MOV.L 1CH[R0], R1
00000052 E31E                    		MOV.L R14, [R1]
00000054                         L16:	; bb42
                                 ;      65 		if (st_cfg.mot[MOTOR_2].motor_map == axis) { steps[MOTOR_2] = joint[axis] * st_cfg.mot[MOTOR_2].steps_per_unit;}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",65
00000054 FBE2rrrrrrrr            		MOV.L #_st_cfg, R14
0000005A 59EE28                  		MOVU.B 28H[R14], R14
0000005D 450E1B                  		CMP 1BH[R0].UB, R14
00000060 21rr                    		BNE L18
00000062                         L17:	; bb43
00000062 EF0E                    		MOV.L R0, R14
00000064 B689                    		MOVU.B 1BH[R0], R1
00000066 FE61E1                  		MOV.L [R1,R14], R1
00000069 FBE2rrrrrrrr            		MOV.L #_st_cfg, R14
0000006F FC8DE110                		FMUL 40H[R14].L, R1
00000073 A98A                    		MOV.L 1CH[R0], R2
00000075 A029                    		MOV.L R1, 04H[R2]
00000077                         L18:	; bb61
                                 ;      66 		if (st_cfg.mot[MOTOR_3].motor_map == axis) { steps[MOTOR_3] = joint[axis] * st_cfg.mot[MOTOR_3].steps_per_unit;}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",66
00000077 FBE2rrrrrrrr            		MOV.L #_st_cfg, R14
0000007D 59EE4C                  		MOVU.B 4CH[R14], R14
00000080 450E1B                  		CMP 1BH[R0].UB, R14
00000083 21rr                    		BNE L20
00000085                         L19:	; bb62
00000085 EF0E                    		MOV.L R0, R14
00000087 B689                    		MOVU.B 1BH[R0], R1
00000089 FE61E1                  		MOV.L [R1,R14], R1
0000008C FBE2rrrrrrrr            		MOV.L #_st_cfg, R14
00000092 FC8DE119                		FMUL 64H[R14].L, R1
00000096 A98A                    		MOV.L 1CH[R0], R2
00000098 A0A1                    		MOV.L R1, 08H[R2]
0000009A                         L20:	; bb80
                                 ;      67 		if (st_cfg.mot[MOTOR_4].motor_map == axis) { steps[MOTOR_4] = joint[axis] * st_cfg.mot[MOTOR_4].steps_per_unit;}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",67
0000009A FBE2rrrrrrrr            		MOV.L #_st_cfg, R14
000000A0 59EE70                  		MOVU.B 70H[R14], R14
000000A3 450E1B                  		CMP 1BH[R0].UB, R14
000000A6 21rr                    		BNE L22
000000A8                         L21:	; bb81
000000A8 EF0E                    		MOV.L R0, R14
000000AA B689                    		MOVU.B 1BH[R0], R1
000000AC FE61E1                  		MOV.L [R1,R14], R1
000000AF FBE2rrrrrrrr            		MOV.L #_st_cfg, R14
000000B5 FC8DE122                		FMUL 88H[R14].L, R1
000000B9 A98A                    		MOV.L 1CH[R0], R2
000000BB A0A9                    		MOV.L R1, 0CH[R2]
000000BD                         L22:	; bb98
000000BD B689                    		MOVU.B 1BH[R0], R1
000000BF 6211                    		ADD #01H, R1
000000C1 8689                    		MOV.B R1, 1BH[R0]
000000C3                         L23:	; bb101
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",62
000000C3 B689                    		MOVU.B 1BH[R0], R1
000000C5 6161                    		CMP #06H, R1
000000C7 28rr                  * 		BLT L12
         38rrrr                  
000000CC                         L24:	; return
                                 ;      68 #if (MOTORS >= 5)
                                 ;      69 		if (st_cfg.mot[MOTOR_5].motor_map == axis) { steps[MOTOR_5] = joint[axis] * st_cfg.mot[MOTOR_5].steps_per_unit;}
                                 ;      70 #endif
                                 ;      71 #if (MOTORS >= 6)
                                 ;      72 		if (st_cfg.mot[MOTOR_6].motor_map == axis) { steps[MOTOR_6] = joint[axis] * st_cfg.mot[MOTOR_6].steps_per_unit;}
                                 ;      73 #endif
                                 ;      74 	}
                                 ;      75 
                                 ;      76 /* The above is a loop unrolled version of this:
                                 ;      77 	for (uint8_t axis=0; axis<AXES; axis++) {
                                 ;      78 		for (uint8_t motor=0; motor<MOTORS; motor++) {
                                 ;      79 			if (st_cfg.mot[motor].motor_map == axis) {
                                 ;      80 				steps[motor] = joint[axis] * st_cfg.mot[motor].steps_per_unit;
                                 ;      81 			}
                                 ;      82 		}
                                 ;      83 	}
                                 ;      84 */
                                 ;      85 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\src\cnc\kinematics.c",85
000000CC 6709                    		RTSD #24H
                                 ;      86 
                                 ;      87 /*
                                 ;      88  * _inverse_kinematics() - inverse kinematics - example is for a cartesian machine
                                 ;      89  *
                                 ;      90  *	You can glue in inverse kinematics here, but be aware of time budget constrants.
                                 ;      91  *	This function is run during the _exec() portion of the cycle and will therefore
                                 ;      92  *	be run once per interpolation segment. The total time for the segment load,
                                 ;      93  *	including the inverse kinematics transformation cannot exceed the segment time,
                                 ;      94  *	and ideally should be no more than 25-50% of the segment time. Currently segments
                                 ;      95  *	run avery 5 ms, but this might be lowered. To profile this time look at the
                                 ;      96  *	time it takes to complete the mp_exec_move() function.
                                 ;      97  */
                                 ;      98 /*
                                 ;      99 static void _inverse_kinematics(float travel[], float joint[])
                                 ;     100 {
                                 ;     101 	for (uint8_t i=0; i<AXES; i++) {
                                 ;     102 		joint[i] = travel[i];
                                 ;     103 	}
                                 ;     104 }
                                 ;     105 */
                                 ;     106 
                                 ;     107 #ifdef __cplusplus
                                 ;     108 }
                                 ;     109 #endif
                                 		.END

Information List

TOTAL ERROR(S)    00000
TOTAL WARNING(S)  00000
TOTAL LINE(S)     00236   LINES

Section List

Attr         Size               Name
CODE     0000000206(000000CEH)  P

Cpu Type

-ISA=RXV1 -FPU

Command Parameter

-subcommand=C:\Users\LAFONS~1\AppData\Local\Temp\$ccrx4D06\$ccrx\kinematics.src.cmd
    -nologo
    -isa=rxv1
    -fpu
    -show=conditionals,definitions,expansions
    -define=__RXV1=1
    -fint_register=0
    -debug
    -endian=little
-listfile=C:\Workspace\e2studio\git\MT01_master\MT01_build\kinematics.lst
-output=C:\Workspace\e2studio\git\MT01_master\MT01_build\src\cnc\kinematics.obj
