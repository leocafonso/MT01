* RX FAMILY ASSEMBLER V2.03.00.01 [24 Oct 2014] *  SOURCE LIST  Thu Mar 09 14:19:10 2017

LOC.     OBJ.              0XMDA SOURCE STATEMENT

                                 ;RX Family C/C++ Compiler (V2.03.00.03 [04 Dec 2014])  09-Mar-2017 14:19:10
                                 
                                 ;*** CPU TYPE ***
                                 
                                 ;-ISA=RXV1
                                 
                                 ;*** COMMAND PARAMETER ***
                                 
                                 ;-output=src=r_rspi_rx.src
                                 ;-lang=c99
                                 ;-include=C:\PROGRA~2\Renesas\RX\2_3_0/include,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx\src,C:/Workspace/e2studio/
                                 ;-debug
                                 ;-show=source,conditionals,definitions,expansions
                                 ;-listfile=r_rspi_rx.lst
                                 ;-isa=rxv1
                                 ;-optimize=0
                                 ;-fpu
                                 ;-alias=noansi
                                 ;-nologo
                                 ;-nomessage
                                 ;-define=__RX,COMPACTAXP=1,EASYMAK=0,MOBILE=0,FREE_RTOS_PP
                                 ;r_rspi_rx.c
                                 
                                 		.glb	_g_rspi_channels
                                 		.glb	_R_RSPI_Open
                                 		.glb	_R_BSP_HardwareLock
                                 		.glb	_R_BSP_HardwareUnlock
                                 		.glb	_R_RSPI_Control
                                 		.glb	_R_RSPI_Read
                                 		.glb	_R_RSPI_Write
                                 		.glb	_R_RSPI_WriteRead
                                 		.glb	_R_RSPI_Close
                                 		.glb	_rspi_get_data_type
                                 		.glb	_R_BSP_RegisterProtectDisable
                                 		.glb	_R_BSP_RegisterProtectEnable
                                 		.glb	_R_RSPI_GetVersion
                                 ;LineNo. C-SOURCE STATEMENT
                                 
                                 		.SECTION	P,CODE
00000000                         _R_RSPI_Open:
                                 		.STACK	_R_RSPI_Open=40
                                 ;       1 /***********************************************************************************************************************
                                 ;       2 * DISCLAIMER
                                 ;       3 * This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No 
                                 ;       4 * other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all 
                                 ;       5 * applicable laws, including copyright laws. 
                                 ;       6 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
                                 ;       7 * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, 
                                 ;       8 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM 
                                 ;       9 * EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES 
                                 ;      10 * SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS 
                                 ;      11 * SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
                                 ;      12 * Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of 
                                 ;      13 * this software. By using this software, you agree to the additional terms and conditions found by accessing the 
                                 ;      14 * following link:
                                 ;      15 * http://www.renesas.com/disclaimer 
                                 ;      16 *
                                 ;      17 * Copyright (C) 2013, 2014 Renesas Electronics Corporation. All rights reserved.
                                 ;      18 ***********************************************************************************************************************/
                                 ;      19 /***********************************************************************************************************************
                                 ;      20 * File Name    : r_rspi_rx.c
                                 ;      21 * Device(s)    : RX Family
                                 ;      22 * Tool-Chain   : Renesas RX Standard Toolchain 1.02
                                 ;      23 * OS           : None
                                 ;      24 * H/W Platform :
                                 ;      25 * Description  : Functions for using RSPI on RX devices.
                                 ;      26 ************************************************************************************************************************
                                 ;      27 * History : DD.MM.YYYY Version Description           
                                 ;      28 *         : 25.10.2013 1.00     First Release
                                 ;      29 *           01.05.2014 1.20     Added support for RX62N. Minor bug fixes.
                                 ;      30 ***********************************************************************************************************************/
                                 ;      31 /***********************************************************************************************************************
                                 ;      32 Includes   <System Includes> , "Project Includes"
                                 ;      33 ***********************************************************************************************************************/
                                 ;      34 /* Defines for RSPI support */
                                 ;      35 #include "platform.h"
                                 ;      36 #include "r_rspi_rx_if.h"
                                 ;      37 
                                 ;      38 /***********************************************************************************************************************
                                 ;      39 Typedef definitions
                                 ;      40 ***********************************************************************************************************************/
                                 ;      41 typedef enum
                                 ;      42 {   // Values will be used as bit flags.
                                 ;      43     RSPI_DO_TX    = 0x1,
                                 ;      44     RSPI_DO_RX    = 0x2,
                                 ;      45     RSPI_DO_TX_RX = 0x3
                                 ;      46 } rspi_operation_t;
                                 ;      47 
                                 ;      48 typedef struct rspi_tcb_s
                                 ;      49 {
                                 ;      50    void     *psrc;
                                 ;      51    void     *pdest;
                                 ;      52    uint16_t tx_count;
                                 ;      53    uint16_t rx_count;
                                 ;      54    uint16_t xfr_length;
                                 ;      55    uint8_t  bytes_per_transfer;     /* Source buffer bytes per transfer: 1, 2, or 4. */
                                 ;      56    bool     do_rx_now;              /* State flag for valid read data available. */
                                 ;      57    bool     do_tx;                  /* State flag for transmit operation. */
                                 ;      58    rspi_operation_t  transfer_mode; /* Transmit only, receive only, or transmit-receive. */
                                 ;      59    #if RSPI_CFG_MASK_UNUSED_BITS == (1)
                                 ;      60    uint32_t unused_bits_mask;       /* For masking the unused upper bits of non power-of-2 data. */
                                 ;      61    #endif
                                 ;      62 } rspi_tcb_t;
                                 ;      63 
                                 ;      64 /* Driver internal shadow copy of register settings. */
                                 ;      65 typedef struct rspi_ctrl_reg_values_s
                                 ;      66 {
                                 ;      67     uint8_t spcr_val;   /* RSPI Control Register (SPCR). */
                                 ;      68     uint8_t sslp_val;   /* RSPI Slave Select Polarity Register (SSLP) */
                                 ;      69     uint8_t sppcr_val;  /* RSPI Pin Control Register (SPPCR) */
                                 ;      70     uint8_t spscr_val;  /* RSPI Sequence Control Register (SPSCR) */
                                 ;      71     uint8_t spbr_val;   /* RSPI Bit Rate Register (SPBR). */
                                 ;      72     uint8_t spdcr_val;  /* RSPI Data Control Register (SPDCR) */
                                 ;      73     uint8_t spckd_val;  /* RSPI Clock Delay Register (SPCKD) */
                                 ;      74     uint8_t sslnd_val;  /* RSPI Slave Select Negation Delay Register (SSLND) */
                                 ;      75     uint8_t spnd_val;   /* RSPI Next-Access Delay Register (SPND) */
                                 ;      76     uint32_t spcr2_val;  /* RSPI Control Register 2 (SPCR2) */
                                 ;      77 } rspi_ctrl_reg_values_t;
                                 ;      78 
                                 ;      79 /***********************************************************************************************************************
                                 ;      80 Macro definitions
                                 ;      81 ***********************************************************************************************************************/
                                 ;      82 #if RSPI_CFG_USE_CH2 == 1
                                 ;      83     #define RSPI_NUM_CHANNELS (3)
                                 ;      84 #elif RSPI_CFG_USE_CH1 == 1
                                 ;      85     #define RSPI_NUM_CHANNELS (2)
                                 ;      86 #elif RSPI_CFG_USE_CH0 == 1
                                 ;      87     #define RSPI_NUM_CHANNELS (1)
                                 ;      88 #else
                                 ;      89     #error "ERROR in r_rspi_rx configuration. Must enable at least 1 channel for use."
                                 ;      90 #endif
                                 ;      91 
                                 ;      92 #define RSPI_POWER_ON (0)
                                 ;      93 #define RSPI_POWER_OFF (1)
                                 ;      94 
                                 ;      95 /***********************************************************************************************************************
                                 ;      96 Private global variables and functions
                                 ;      97 ***********************************************************************************************************************/
                                 ;      98 
                                 ;      99 /* Array of channel handles. One for each physical RSPI channel on the device. */
                                 ;     100 static struct rspi_config_block_s g_rspi_handles[RSPI_NUM_CHANNELS];
                                 ;     101 
                                 ;     102 /* Used to prevent having duplicate code for each channel. This only works if the channels are identical (just at 
                                 ;     103    different locations in memory). This is easy to tell by looking in iodefine.h and seeing if the same structure
                                 ;     104    was used for all channels. */
                                 ;     105 volatile struct st_rspi __evenaccess * g_rspi_channels[RSPI_NUM_CHANNELS] =
                                 ;     106 {
                                 ;     107 /* Initialize the array for up to 3 channels. Add more as needed. */
                                 ;     108 #if   RSPI_NUM_CHANNELS == 1
                                 ;     109     &RSPI0,
                                 ;     110 #elif RSPI_NUM_CHANNELS == 2
                                 ;     111     &RSPI0, &RSPI1
                                 ;     112 #elif RSPI_NUM_CHANNELS == 3
                                 ;     113     &RSPI0, &RSPI1, &RSPI2
                                 ;     114 #endif
                                 ;     115 };
                                 ;     116 
                                 ;     117 static volatile uint32_t g_rxdata[RSPI_NUM_CHANNELS]; /* Space for fast read of RSPI RX data register. */
                                 ;     118 
                                 ;     119 /* Allocate transfer control blocks for all channels. */
                                 ;     120 static struct rspi_tcb_s g_rspi_tcb[RSPI_NUM_CHANNELS] = {0};
                                 ;     121 /* Allocate transaction result code storage for all channels. */
                                 ;     122 static rspi_callback_data_t g_rspi_cb_data[RSPI_NUM_CHANNELS] = {0};
                                 ;     123 
                                 ;     124 /* Allocate register settings structure for all channels and initialize to defaults. */
                                 ;     125 static rspi_ctrl_reg_values_t g_ctrl_reg_values[] =
                                 ;     126 {
                                 ;     127     RSPI_SPCR_DEF,      /* Control Register (SPCR) */
                                 ;     128     RSPI_SSLP_DEF,      /* Slave Select Polarity Register (SSLP) */
                                 ;     129     RSPI_SPPCR_DEF,     /* Pin Control Register (SPPCR) */
                                 ;     130     RSPI_SPSCR_DEF,     /* Sequence Control Register (SPSCR) */
                                 ;     131     RSPI_SPBR_DEF,      /* Bit Rate Register (SPBR) */
                                 ;     132     RSPI_SPDCR_DEF,     /* Data Control Register (SPDCR) */
                                 ;     133     RSPI_SPCKD_DEF,     /* Clock Delay Register (SPCKD) */
                                 ;     134     RSPI_SSLND_DEF,     /* Slave Select Negation Delay Register (SSLND) */
                                 ;     135     RSPI_SPND_DEF,      /* Next-Access Delay Register (SPND) */
                                 ;     136     RSPI_SPCR2_DEF,     /* Control Register 2 (SPCR2) */
                                 ;     137 #if   RSPI_NUM_CHANNELS > 1
                                 ;     138     RSPI_SPCR_DEF, /* Control Register (SPCR) */
                                 ;     139     RSPI_SSLP_DEF,      /* Slave Select Polarity Register (SSLP) */
                                 ;     140     RSPI_SPPCR_DEF,     /* Pin Control Register (SPPCR) */
                                 ;     141     RSPI_SPSCR_DEF,     /* Sequence Control Register (SPSCR) */
                                 ;     142     RSPI_SPBR_DEF,      /* Bit Rate Register (SPBR) */
                                 ;     143     RSPI_SPDCR_DEF,     /* Data Control Register (SPDCR) */
                                 ;     144     RSPI_SPCKD_DEF,     /* Clock Delay Register (SPCKD) */
                                 ;     145     RSPI_SSLND_DEF,     /* Slave Select Negation Delay Register (SSLND) */
                                 ;     146     RSPI_SPND_DEF,      /* Next-Access Delay Register (SPND) */
                                 ;     147     RSPI_SPCR2_DEF,     /* Control Register 2 (SPCR2) */
                                 ;     148 #endif
                                 ;     149 #if   RSPI_NUM_CHANNELS >2
                                 ;     150     RSPI_SPCR_DEF, /* Control Register (SPCR) */
                                 ;     151     RSPI_SSLP_DEF,      /* Slave Select Polarity Register (SSLP) */
                                 ;     152     RSPI_SPPCR_DEF,     /* Pin Control Register (SPPCR) */
                                 ;     153     RSPI_SPSCR_DEF,     /* Sequence Control Register (SPSCR) */
                                 ;     154     RSPI_SPBR_DEF,      /* Bit Rate Register (SPBR) */
                                 ;     155     RSPI_SPDCR_DEF,     /* Data Control Register (SPDCR) */
                                 ;     156     RSPI_SPCKD_DEF,     /* Clock Delay Register (SPCKD) */
                                 ;     157     RSPI_SSLND_DEF,     /* Slave Select Negation Delay Register (SSLND) */
                                 ;     158     RSPI_SPND_DEF,      /* Next-Access Delay Register (SPND) */
                                 ;     159     RSPI_SPCR2_DEF,     /* Control Register 2 (SPCR2) */
                                 ;     160 #endif
                                 ;     161 };
                                 ;     162 
                                 ;     163 #if RSPI_CFG_MASK_UNUSED_BITS == (1)
                                 ;     164 /* This is a lookup table to hold bit masks for use when the
                                 ;     165  * RSPI_CFG_MASK_UNUSED_BITS config option is enabled.
                                 ;     166  * The bit-length specifier field in the SPCMD register is
                                 ;     167  * used as the index to select the corresponding mask */
                                 ;     168 static const uint32_t g_unused_bits_masks[16] = {
                                 ;     169     0x000FFFFF,     /* 0x0 = 20 bits data length */
                                 ;     170     0x00FFFFFF,     /* 0x1 = 24 bits data length */
                                 ;     171     0xFFFFFFFF,     /* 0x2 = 32 bits data length */
                                 ;     172     0xFFFFFFFF,     /* 0x3 = 32 bits data length */
                                 ;     173     0x000000FF,     /* 0x4 = 8 bits data length  */
                                 ;     174     0x000000FF,     /* 0x5 = 8 bits data length  */
                                 ;     175     0x000000FF,     /* 0x6 = 8 bits data length  */
                                 ;     176     0x000000FF,     /* 0x7 = 8 bits data length  */
                                 ;     177     0x000001FF,     /* 0x8 = 9 bits data length  */
                                 ;     178     0x000003FF,     /* 0x9 = 10 bits data length */
                                 ;     179     0x000007FF,     /* 0xA = 11 bits data length */
                                 ;     180     0x00000FFF,     /* 0xB = 12 bits data length */
                                 ;     181     0x00001FFF,     /* 0xC = 13 bits data length */
                                 ;     182     0x00003FFF,     /* 0xD = 14 bits data length */
                                 ;     183     0x00007FFF,     /* 0xE = 15 bits data length */
                                 ;     184     0x0000FFFF,     /* 0xF = 16 bits data length */
                                 ;     185 };
                                 ;     186 #endif
                                 ;     187 
                                 ;     188 /***********************************************************************************************************************
                                 ;     189 Private function declarations
                                 ;     190 ***********************************************************************************************************************/
                                 ;     191 /* Common routine used by RSPI API write or read functions. */
                                 ;     192 static rspi_err_t  rspi_write_read_common(rspi_handle_t handle,
                                 ;     193                                           rspi_command_word_t command_word,
                                 ;     194                                           void          *psrc,
                                 ;     195                                           void          *pdest,
                                 ;     196                                           uint16_t      length,
                                 ;     197                                           rspi_operation_t   tx_rx_mode);
                                 ;     198 /* Sets the baud rate registers for a given frequency. */
                                 ;     199 static uint32_t rspi_baud_set(uint8_t channel, uint32_t baud_target);
                                 ;     200 /* Determines the primitive data type required for accessing a given RSPI data frame bit length. */
                                 ;     201 uint8_t rspi_get_data_type(rspi_command_word_t frame_length_bits);
                                 ;     202 /* Common RSPI channel power-on utility. */
                                 ;     203 static void power_on_off (uint8_t channel, uint8_t on_or_off);
                                 ;     204 /* Set RSPI interrupt priorities. */
                                 ;     205 static void rspi_ir_priority_set(uint8_t channel, uint8_t rspi_priority);
                                 ;     206 /* Clear any pending RSPI interrupts. */
                                 ;     207 static void rspi_interrupts_clear(uint8_t channel);
                                 ;     208 /* Disable or enable RSPI interrupts. */
                                 ;     209 static void rspi_interrupts_enable(uint8_t channel, bool enabled);
                                 ;     210 /* Common subroutine for transmitting. */
                                 ;     211 static void rspi_tx_rx_common(uint8_t channel);
                                 ;     212 
                                 ;     213 /***********************************************************************************************************************
                                 ;     214 * Function Name: R_RSPI_Open
                                 ;     215 * Description  : This function applies power to the RSPI channel,
                                 ;     216 *                initializes the associated registers,
                                 ;     217 *                applies user-configurable options,
                                 ;     218 *                and provides the channel handle for use with other API functions.
                                 ;     219 * Arguments    : chan -
                                 ;     220 *                   Number of the RSPI channel to be initialized
                                 ;     221 *                pconfig -
                                 ;     222 *                   Pointer to RSPI channel configuration data structure.
                                 ;     223 *                pcallback -
                                 ;     224 *                   Pointer to function called from interrupt
                                 ;     225 *                phandle -
                                 ;     226 *                   Pointer to user-provided storage for a pointer to the handle data structure.
                                 ;     227 * Return Value : RSPI_SUCCESS-
                                 ;     228 *                   Successful; channel initialized
                                 ;     229 *                RSPI_ERR_BAD_CHAN-
                                 ;     230 *                   Channel number is invalid for part
                                 ;     231 *                RSPI_ERR_CH_NOT_CLOSED-
                                 ;     232 *                   Channel currently in operation; Perform R_RSPI_Close() first
                                 ;     233 *                RSPI_ERR_NULL_PTR-
                                 ;     234 *                   pconfig pointer or phandle pointer is NULL
                                 ;     235 *                RSPI_ERR_INVALID_ARG-
                                 ;     236 *                   An element of the pconfig structure contains an invalid value.
                                 ;     237 *                RSPI_ERR_LOCK-
                                 ;     238 *                      The lock could not be acquired. The channel is busy.
                                 ;     239 ***********************************************************************************************************************/
                                 ;     240 rspi_err_t   R_RSPI_Open(uint8_t                channel,
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",240
00000000 7100DC                  		ADD #0FFFFFFDCH, R0
00000003 C70123                  		MOV.B R1, 23H[R0]
00000006 A18A                    		MOV.L R2, 1CH[R0]
00000008 A183                    		MOV.L R3, 18H[R0]
0000000A A10C                    		MOV.L R4, 14H[R0]
                                 ;     241                          rspi_chnl_settings_t  *pconfig,
                                 ;     242                          void                 (*pcallback)(void *pcbdat),
                                 ;     243                          rspi_handle_t         *phandle)
                                 ;     244 {
                                 ;     245     rspi_ctrl_reg_values_t *my_settings = &(g_ctrl_reg_values[channel]);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",245
0000000C 590123                  		MOVU.B 23H[R0], R1
0000000F 6C41                    		SHLL #04H, R1
00000011 FB22rrrrrrrr            		MOV.L #__$g_ctrl_reg_values, R2
00000017 4B12                    		ADD R1, R2
00000019 A082                    		MOV.L R2, 08H[R0]
0000001B                         L11:	; entry.split
                                 ;     246 
                                 ;     247     #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     248     bool        lock_result = false;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",248
0000001B 3C0F00                  		MOV.B #00H, 0FH[R0]
0000001E                         L12:	; entry.split1
                                 ;     249     #endif
                                 ;     250 
                                 ;     251     #if RSPI_CFG_PARAM_CHECKING_ENABLE == 1
                                 ;     252     /* Check channel number. */
                                 ;     253     if (channel >= RSPI_NUM_CHANNELS)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",253
0000001E 590123                  		MOVU.B 23H[R0], R1
00000021 6121                    		CMP #02H, R1
00000023 29rr                    		BLT L14
00000025                         L13:	; bb10
                                 ;     254     {
                                 ;     255         /* Invalid channel. */
                                 ;     256         return RSPI_ERR_BAD_CHAN;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",256
00000025 3E0101                  		MOV.L #00000001H, 04H[R0]
00000028 38rrrr               W  		BRA L55
0000002B                         L14:	; bb17
                                 ;     257     }
                                 ;     258 
                                 ;     259     if ((NULL == pconfig) || (NULL == phandle))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",259
0000002B A989                    		MOV.L 1CH[R0], R1
0000002D 6101                    		CMP #00H, R1
0000002F 20rr                    		BEQ L17
00000031 08                   S  		BRA L16
00000032                         L15:	; bb18
                                 ;     260     {
                                 ;     261         return RSPI_ERR_NULL_PTR;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",261
00000032 3E0107                  		MOV.L #00000007H, 04H[R0]
00000035 38rrrr               W  		BRA L55
00000038                         L16:	; bb23
00000038 A909                    		MOV.L 14H[R0], R1
0000003A 6101                    		CMP #00H, R1
0000003C 18                   S  		BNE L18
0000003D                         L17:	; bb27
0000003D F80601                  		MOV.L #00000001H, [R0]
00000040 08                   S  		BRA L19
00000041                         L18:	; bb28
00000041 F80600                  		MOV.L #00000000H, [R0]
00000044                         L19:	; bb29
00000044 EC01                    		MOV.L [R0], R1
00000046 6101                    		CMP #00H, R1
00000048 21rr                    		BNE L15
0000004A                         L20:	; bb35
                                 ;     262     }
                                 ;     263 
                                 ;     264     /* Check to see if the peripheral has already been initialized. */
                                 ;     265     if (true == g_rspi_handles[channel].rspi_chnl_opened)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",265
0000004A 590123                  		MOVU.B 23H[R0], R1
0000004D 6C31                    		SHLL #03H, R1
0000004F FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
00000055 4B12                    		ADD R1, R2
00000057 B0A1                    		MOVU.B 02H[R2], R1
00000059 6111                    		CMP #01H, R1
0000005B 18                   S  		BNE L22
0000005C                         L21:	; bb36
                                 ;     266     {
                                 ;     267         /* This channel has already been initialized. */
                                 ;     268         return RSPI_ERR_CH_NOT_CLOSED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",268
0000005C 3E0103                  		MOV.L #00000003H, 04H[R0]
0000005F 38rrrr               W  		BRA L55
00000062                         L22:	; bb47
                                 ;     269     }
                                 ;     270     #endif
                                 ;     271 
                                 ;     272     #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     273     /* Attempt to acquire lock for this RSPI channel. Prevents reentrancy conflict. */
                                 ;     274     lock_result = R_BSP_HardwareLock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",274
00000062 590123                  		MOVU.B 23H[R0], R1
00000065 71113B                  		ADD #3BH, R1
00000068 05rrrrrr             A  		BSR _R_BSP_HardwareLock
0000006C 8389                    		MOV.B R1, 0FH[R0]
0000006E                         L23:	; bb47.split
                                 ;     275 
                                 ;     276     if(false == lock_result)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",276
0000006E B389                    		MOVU.B 0FH[R0], R1
00000070 6101                    		CMP #00H, R1
00000072 18                   S  		BNE L25
00000073                         L24:	; bb53
                                 ;     277     {
                                 ;     278         return RSPI_ERR_LOCK; /* The open function is currently locked. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",278
00000073 3E0108                  		MOV.L #00000008H, 04H[R0]
00000076 38rrrr               W  		BRA L55
00000079                         L25:	; bb60
                                 ;     279     }
                                 ;     280     #endif
                                 ;     281 
                                 ;     282     power_on_off(channel, RSPI_POWER_ON);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",282
00000079 590123                  		MOVU.B 23H[R0], R1
0000007C 6602                    		MOV.L #00000000H, R2
0000007E 39rrrr               W  		BSR __$power_on_off
00000081                         L26:	; bb60.split
                                 ;     283 
                                 ;     284     if (0 == channel)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",284
00000081 590123                  		MOVU.B 23H[R0], R1
00000084 6101                    		CMP #00H, R1
00000086 18                   S  		BNE L28
00000087                         L27:	; bb63
                                 ;     285     {
                                 ;     286         rspi_ir_priority_set(channel, RSPI_IR_PRIORITY_CHAN0);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",286
00000087 5B11                    		MOVU.B R1, R1
00000089 6632                    		MOV.L #00000003H, R2
0000008B 39rrrr               W  		BSR __$rspi_ir_priority_set
0000008E 2Err                 B  		BRA L30
00000090                         L28:	; bb66
                                 ;     287     }
                                 ;     288     #if RSPI_NUM_CHANNELS > 1
                                 ;     289     else if (1 == channel)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",289
00000090 5B1E                    		MOVU.B R1, R14
00000092 611E                    		CMP #01H, R14
00000094 18                   S  		BNE L30
00000095                         L29:	; bb67
                                 ;     290     {
                                 ;     291         rspi_ir_priority_set(channel, RSPI_IR_PRIORITY_CHAN1);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",291
00000095 590123                  		MOVU.B 23H[R0], R1
00000098 6632                    		MOV.L #00000003H, R2
0000009A 39rrrr               W  		BSR __$rspi_ir_priority_set
0000009D                         L30:	; bb82
                                 ;     292     }
                                 ;     293     #endif
                                 ;     294     #if RSPI_NUM_CHANNELS > 2
                                 ;     295     else if (2 == channel)
                                 ;     296     {
                                 ;     297         rspi_ir_priority_set(channel, RSPI_IR_PRIORITY_CHAN2);
                                 ;     298     }
                                 ;     299     #endif
                                 ;     300     else
                                 ;     301     {
                                 ;     302         /* Nothing else. */
                                 ;     303     }
                                 ;     304 
                                 ;     305     /* Disable interrupts in ICU. */
                                 ;     306     rspi_interrupts_enable(channel, false);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",306
0000009D 590123                  		MOVU.B 23H[R0], R1
000000A0 6602                    		MOV.L #00000000H, R2
000000A2 39rrrr               W  		BSR __$rspi_interrupts_enable
000000A5                         L31:	; bb82.split
                                 ;     307 
                                 ;     308     /* Set the base bit rate. Modifies the SPBR register setting with requested baud rate.*/
                                 ;     309     if (0 == rspi_baud_set(channel, pconfig->bps_target))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",309
000000A5 A989                    		MOV.L 1CH[R0], R1
000000A7 A892                    		MOV.L 08H[R1], R2
000000A9 590123                  		MOVU.B 23H[R0], R1
000000AC 39rrrr               W  		BSR __$rspi_baud_set
000000AF 6101                    		CMP #00H, R1
000000B1 590123                  		MOVU.B 23H[R0], R1
000000B4 21rr                    		BNE L34
000000B6                         L32:	; bb85
                                 ;     310     {   // Failed
                                 ;     311         #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     312         R_BSP_HardwareUnlock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",312
000000B6 71113B                  		ADD #3BH, R1
000000B9 05rrrrrr             A  		BSR _R_BSP_HardwareUnlock
000000BD                         L33:	; bb85.split
                                 ;     313         #endif
                                 ;     314         return RSPI_ERR_ARG_RANGE; /* Could not calculate settings for the requested baud rate. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",314
000000BD 3E0106                  		MOV.L #00000006H, 04H[R0]
000000C0 38rrrr               W  		BRA L55
000000C3                         L34:	; bb99
                                 ;     315     }
                                 ;     316 
                                 ;     317     /* Set pin control register (SPPCR) */
                                 ;     318     (*g_rspi_channels[channel]).SPPCR.BYTE = (uint8_t)(my_settings->sppcr_val & RSPI_SPPCR_MASK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",318
000000C3 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000000C9 FE61E1                  		MOV.L [R1,R14], R1
000000CC A882                    		MOV.L 08H[R0], R2
000000CE B0A2                    		MOVU.B 02H[R2], R2
000000D0 752233                  		AND #33H, R2
000000D3 8092                    		MOV.B R2, 02H[R1]
000000D5                         L35:	; bb99.split
                                 ;     319 
                                 ;     320     /* Set slave select polarity register (SSLP). */
                                 ;     321     (*g_rspi_channels[channel]).SSLP.BYTE = (uint8_t)(my_settings->sslp_val & RSPI_SSLP_MASK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",321
000000D5 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000000DB 590123                  		MOVU.B 23H[R0], R1
000000DE FE61E1                  		MOV.L [R1,R14], R1
000000E1 A882                    		MOV.L 08H[R0], R2
000000E3 B02A                    		MOVU.B 01H[R2], R2
000000E5 64F2                    		AND #0FH, R2
000000E7 801A                    		MOV.B R2, 01H[R1]
000000E9                         L36:	; bb99.split2
                                 ;     322 
                                 ;     323     /* Apply the SPBR setting. */
                                 ;     324     (*g_rspi_channels[channel]).SPBR = my_settings->spbr_val;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",324
000000E9 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000000EF 590123                  		MOVU.B 23H[R0], R1
000000F2 FE61EE                  		MOV.L [R1,R14], R14
000000F5 A881                    		MOV.L 08H[R0], R1
000000F7 C51E040A                		MOV.B 04H[R1], 0AH[R14]
000000FB                         L37:	; bb99.split3
                                 ;     325 
                                 ;     326     /* Set RSPI data control register (SPDCR). Only SPLW bit supported in this ver. */
                                 ;     327     /* Force to long word data access here regardless of user defined setting. */
                                 ;     328     (*g_rspi_channels[channel]).SPDCR.BYTE = RSPI_SPDCR_SPLW;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",328
000000FB FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
00000101 590123                  		MOVU.B 23H[R0], R1
00000104 FE61E1                  		MOV.L [R1,R14], R1
00000107 3C1B20                  		MOV.B #20H, 0BH[R1]
0000010A                         L38:	; bb99.split4
                                 ;     329 
                                 ;     330     /* Set RSPI clock delay registers (SPCKD) */
                                 ;     331     (*g_rspi_channels[channel]).SPCKD.BYTE = (uint8_t)(my_settings->spckd_val & RSPI_SPCKD_MASK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",331
0000010A FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
00000110 590123                  		MOVU.B 23H[R0], R1
00000113 FE61E1                  		MOV.L [R1,R14], R1
00000116 A882                    		MOV.L 08H[R0], R2
00000118 B1A2                    		MOVU.B 06H[R2], R2
0000011A 6472                    		AND #07H, R2
0000011C 8312                    		MOV.B R2, 0CH[R1]
0000011E                         L39:	; bb99.split5
                                 ;     332 
                                 ;     333     /* Set RSPI slave select negation delay register (SSLND) */
                                 ;     334     (*g_rspi_channels[channel]).SSLND.BYTE = (uint8_t)(my_settings->sslnd_val & RSPI_SSLND_MASK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",334
0000011E FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
00000124 590123                  		MOVU.B 23H[R0], R1
00000127 FE61E1                  		MOV.L [R1,R14], R1
0000012A A882                    		MOV.L 08H[R0], R2
0000012C B1AA                    		MOVU.B 07H[R2], R2
0000012E 6472                    		AND #07H, R2
00000130 831A                    		MOV.B R2, 0DH[R1]
00000132                         L40:	; bb99.split6
                                 ;     335 
                                 ;     336     /* Set RSPI next-access delay register (SPND) */
                                 ;     337     (*g_rspi_channels[channel]).SPND.BYTE = (uint8_t)(my_settings->spnd_val & RSPI_SPND_MASK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",337
00000132 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
00000138 590123                  		MOVU.B 23H[R0], R1
0000013B FE61E1                  		MOV.L [R1,R14], R1
0000013E A882                    		MOV.L 08H[R0], R2
00000140 B222                    		MOVU.B 08H[R2], R2
00000142 6472                    		AND #07H, R2
00000144 8392                    		MOV.B R2, 0EH[R1]
00000146                         L41:	; bb99.split7
                                 ;     338 
                                 ;     339     /* Set RSPI control register 2 (SPCR2) */
                                 ;     340     (*g_rspi_channels[channel]).SPCR2.BYTE = (uint8_t)(my_settings->spcr2_val & RSPI_SPCR2_MASK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",340
00000146 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
0000014C 590123                  		MOVU.B 23H[R0], R1
0000014F FE61E1                  		MOV.L [R1,R14], R1
00000152 A882                    		MOV.L 08H[R0], R2
00000154 A8AA                    		MOV.L 0CH[R2], R2
00000156 64F2                    		AND #0FH, R2
00000158 839A                    		MOV.B R2, 0FH[R1]
0000015A                         L42:	; bb99.split8
                                 ;     341 
                                 ;     342     /* Determine master/slave mode setting based on channel settings argument.
                                 ;     343      * Overrides prior state for this bit . */
                                 ;     344     if (RSPI_MS_MODE_MASTER == pconfig->master_slave_mode)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",344
0000015A A989                    		MOV.L 1CH[R0], R1
0000015C A819                    		MOV.L 04H[R1], R1
0000015E 6181                    		CMP #08H, R1
00000160 A881                    		MOV.L 08H[R0], R1
00000162 581E                    		MOVU.B [R1], R14
00000164 18                   S  		BNE L44
00000165                         L43:	; bb186
                                 ;     345     {
                                 ;     346         my_settings->spcr_val |= RSPI_MS_MODE_MASTER;   // Set the master mode bit
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",346
00000165 783E                    		BSET #03H, R14
00000167 C31E                    		MOV.B R14, [R1]
00000169 08                   S  		BRA L45
0000016A                         L44:	; bb193
                                 ;     347     }
                                 ;     348     else
                                 ;     349     {
                                 ;     350         my_settings->spcr_val &= RSPI_MS_MODE_SLAVE;    // Clear the master mode bit
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",350
0000016A 762EF700                		AND #0F7H, R14
0000016E C31E                    		MOV.B R14, [R1]
00000170                         L45:	; bb207
                                 ;     351     }
                                 ;     352 
                                 ;     353     /* Determine RSPI slave select mode setting based on channel settings argument.
                                 ;     354      * Overrides prior state for this bit . */
                                 ;     355     if (RSPI_IF_MODE_4WIRE == pconfig->gpio_ssl)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",355
00000170 A989                    		MOV.L 1CH[R0], R1
00000172 EC1E                    		MOV.L [R1], R14
00000174 750EFE                  		CMP #0FFFFFFFEH, R14
00000177 A881                    		MOV.L 08H[R0], R1
00000179 581E                    		MOVU.B [R1], R14
0000017B 18                   S  		BNE L47
0000017C                         L46:	; bb208
                                 ;     356     {
                                 ;     357         my_settings->spcr_val &= RSPI_IF_MODE_4WIRE; // Clear the SPMS bit
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",357
0000017C 762EFE00                		AND #0FEH, R14
00000180 C31E                    		MOV.B R14, [R1]
00000182 08                   S  		BRA L48
00000183                         L47:	; bb215
                                 ;     358     }
                                 ;     359     else
                                 ;     360     {
                                 ;     361         my_settings->spcr_val |= RSPI_IF_MODE_3WIRE; // Set the SPMS bit
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",361
00000183 780E                    		BSET #00H, R14
00000185 C31E                    		MOV.B R14, [R1]
00000187                         L48:	; bb228
                                 ;     362     }
                                 ;     363     /* Set RSPI control register (SPCR) */
                                 ;     364     (*g_rspi_channels[channel]).SPCR.BYTE = my_settings->spcr_val;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",364
00000187 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
0000018D 590123                  		MOVU.B 23H[R0], R1
00000190 FE61EE                  		MOV.L [R1,R14], R14
00000193 A881                    		MOV.L 08H[R0], R1
00000195 C01E                    		MOV.B [R1], [R14]
00000197                         L49:	; bb228.split
                                 ;     365 
                                 ;     366     /* Peripheral Initialized */
                                 ;     367     g_rspi_handles[channel].rspi_chnl_opened = true;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",367
00000197 590123                  		MOVU.B 23H[R0], R1
0000019A 6C31                    		SHLL #03H, R1
0000019C FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
000001A2 4B12                    		ADD R1, R2
000001A4 3C2201                  		MOV.B #01H, 02H[R2]
000001A7                         L50:	; bb228.split9
                                 ;     368     g_rspi_handles[channel].pcallback = pcallback;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",368
000001A7 590123                  		MOVU.B 23H[R0], R1
000001AA 6C31                    		SHLL #03H, R1
000001AC FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
000001B2 4B12                    		ADD R1, R2
000001B4 E5020601                		MOV.L 18H[R0], 04H[R2]
000001B8                         L51:	; bb228.split10
                                 ;     369     g_rspi_handles[channel].channel = channel;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",369
000001B8 590123                  		MOVU.B 23H[R0], R1
000001BB FDC31E                  		SHLL #03H, R1, R14
000001BE FBF2rrrrrrrr            		MOV.L #__$g_rspi_handles, R15
000001C4 FE0FE1                  		MOV.B R1, [R15,R14]
000001C7                         L52:	; bb228.split11
                                 ;     370 
                                 ;     371     *phandle = &(g_rspi_handles[channel]);  // Return a pointer to the channel handle structure.
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",371
000001C7 590123                  		MOVU.B 23H[R0], R1
000001CA 6C31                    		SHLL #03H, R1
000001CC FBE2rrrrrrrr            		MOV.L #__$g_rspi_handles, R14
000001D2 4B1E                    		ADD R1, R14
000001D4 A909                    		MOV.L 14H[R0], R1
000001D6 E31E                    		MOV.L R14, [R1]
000001D8                         L53:	; bb228.split12
                                 ;     372 
                                 ;     373     #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     374     /* Release lock for this channel. */
                                 ;     375     R_BSP_HardwareUnlock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",375
000001D8 590123                  		MOVU.B 23H[R0], R1
000001DB 71113B                  		ADD #3BH, R1
000001DE 05rrrrrr             A  		BSR _R_BSP_HardwareUnlock
000001E2                         L54:	; bb228.split13
                                 ;     376     #endif
                                 ;     377 
                                 ;     378     return RSPI_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",378
000001E2 3E0100                  		MOV.L #00000000H, 04H[R0]
000001E5                         L55:	; bb261
000001E5 A809                    		MOV.L 04H[R0], R1
000001E7 A101                    		MOV.L R1, 10H[R0]
                                 ;     379 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",379
000001E9 6709                    		RTSD #24H
000001EB                         _R_RSPI_Control:
                                 		.STACK	_R_RSPI_Control=48
                                 ;     380 /* end of function R_RSPI_Open(). */
                                 ;     381 
                                 ;     382 
                                 ;     383 /***********************************************************************************************************************
                                 ;     384 * Function Name: R_RSPI_Control
                                 ;     385 * Description  : This function is responsible for handling special hardware or software operations for the RSPI channel.
                                 ;     386 * Arguments    : handle-
                                 ;     387 *                   Handle for the channel
                                 ;     388 *                cmd
                                 ;     389 *                   Enumerated command code
                                 ;     390 *                pcmd_data
                                 ;     391 *                   Pointer to the command-data structure parameter of type void that is used to reference the location
                                 ;     392 *                   of any data specific to the command that is needed for its completion.
                                 ;     393 * Return Value : RSPI_SUCCESS-
                                 ;     394 *                   Command successfully completed.
                                 ;     395 *                RSPI_ERR_CH_NOT_OPEN-
                                 ;     396 *                   The channel has not been opened.  Perform R_RSPI_Open() first
                                 ;     397 *                RSPI_ERR_BAD_CHAN-
                                 ;     398 *                   Channel number is invalid for part
                                 ;     399 *                RSPI_ERR_UNKNOWN_CMD-
                                 ;     400 *                   Control command is not recognized.
                                 ;     401 *                RSPI_ERR_NULL_PTR-
                                 ;     402 *                   pcmd_data  pointer or handle is NULL
                                 ;     403 *                RSPI_ERR_INVALID_ARG-
                                 ;     404 *                   An element of the pcmd_data structure contains an invalid value.
                                 ;     405 *                RSPI_ERR_LOCK-
                                 ;     406 *                      The lock could not be acquired. The channel is busy.
                                 ;     407 ***********************************************************************************************************************/
                                 ;     408 rspi_err_t  R_RSPI_Control(rspi_handle_t handle,
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",408
000001EB 7100D4                  		ADD #0FFFFFFD4H, R0
000001EE A281                    		MOV.L R1, 28H[R0]
000001F0 A20A                    		MOV.L R2, 24H[R0]
000001F2 A203                    		MOV.L R3, 20H[R0]
                                 ;     409                            rspi_cmd_t     cmd,
                                 ;     410                            void          *pcmd_data)
                                 ;     411 {
                                 ;     412     /* Command function data structure definitions. One for each command in rspi_cmd_t. */
                                 ;     413     rspi_cmd_baud_t        *p_baud_struct;
                                 ;     414     rspi_cmd_setregs_t     *p_setregs_struct;
                                 ;     415     uint8_t                 reg_temp = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",415
000001F4 3C8200                  		MOV.B #00H, 12H[R0]
000001F7                         L57:	; entry.split
                                 ;     416     uint8_t                 channel  = handle->channel;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",416
000001F7 AA81                    		MOV.L 28H[R0], R1
000001F9 C41013                  		MOV.B [R1], 13H[R0]
000001FC                         L58:	; entry.split1
                                 ;     417     rspi_ctrl_reg_values_t *new_reg_settings = &(g_ctrl_reg_values[channel]);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",417
000001FC B489                    		MOVU.B 13H[R0], R1
000001FE 6C41                    		SHLL #04H, R1
00000200 FB22rrrrrrrr            		MOV.L #__$g_ctrl_reg_values, R2
00000206 4B12                    		ADD R1, R2
00000208 A10A                    		MOV.L R2, 14H[R0]
0000020A                         L59:	; entry.split2
                                 ;     418 
                                 ;     419     #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     420     bool        lock_result = false;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",420
0000020A 3C8B00                  		MOV.B #00H, 1BH[R0]
0000020D                         L60:	; entry.split3
                                 ;     421     #endif
                                 ;     422 
                                 ;     423     #if RSPI_CFG_PARAM_CHECKING_ENABLE == 1
                                 ;     424     if ((NULL == handle) || ((NULL == pcmd_data) && ((void *)FIT_NO_PTR != pcmd_data)))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",424
0000020D AA81                    		MOV.L 28H[R0], R1
0000020F 6101                    		CMP #00H, R1
00000211 20rr                    		BEQ L67
00000213 08                   S  		BRA L62
00000214                         L61:	; bb16
                                 ;     425     {
                                 ;     426         return RSPI_ERR_NULL_PTR;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",426
00000214 3E0107                  		MOV.L #00000007H, 04H[R0]
00000217 38rrrr               W  		BRA L109
0000021A                         L62:	; bb21
0000021A AA01                    		MOV.L 20H[R0], R1
0000021C 6101                    		CMP #00H, R1
0000021E 21rr                    		BNE L65
00000220                         L63:	; bb25
00000220 AA01                    		MOV.L 20H[R0], R1
00000222 740100000010            		CMP #10000000H, R1
00000228 10                   S  		BEQ L65
00000229                         L64:	; bb29
00000229 F80601                  		MOV.L #00000001H, [R0]
0000022C 08                   S  		BRA L66
0000022D                         L65:	; bb30
0000022D F80600                  		MOV.L #00000000H, [R0]
00000230                         L66:	; bb31
00000230 EC01                    		MOV.L [R0], R1
00000232 6101                    		CMP #00H, R1
00000234 10                   S  		BEQ L68
00000235                         L67:	; bb34
00000235 F80601                  		MOV.L #00000001H, [R0]
00000238 08                   S  		BRA L69
00000239                         L68:	; bb35
00000239 F80600                  		MOV.L #00000000H, [R0]
0000023C                         L69:	; bb36
0000023C EC01                    		MOV.L [R0], R1
0000023E 6101                    		CMP #00H, R1
00000240 21rr                    		BNE L61
00000242                         L70:	; bb42
                                 ;     427     }
                                 ;     428     if (!g_rspi_handles[channel].rspi_chnl_opened)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",428
00000242 B489                    		MOVU.B 13H[R0], R1
00000244 6C31                    		SHLL #03H, R1
00000246 FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
0000024C 4B12                    		ADD R1, R2
0000024E B0A1                    		MOVU.B 02H[R2], R1
00000250 6101                    		CMP #00H, R1
00000252 18                   S  		BNE L72
00000253 2Err                 B  		BRA L73
00000255                         L71:	; bb43
                                 ;     429     {
                                 ;     430         return RSPI_ERR_CH_NOT_OPENED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",430
00000255 3E0102                  		MOV.L #00000002H, 04H[R0]
00000258 38rrrr               W  		BRA L109
0000025B                         L72:	; bb53
0000025B F80600                  		MOV.L #00000000H, [R0]
0000025E 08                   S  		BRA L74
0000025F                         L73:	; bb54
0000025F F80601                  		MOV.L #00000001H, [R0]
00000262                         L74:	; bb55
00000262 EC01                    		MOV.L [R0], R1
00000264 6101                    		CMP #00H, R1
00000266 21rr                    		BNE L71
00000268                         L75:	; bb59
                                 ;     431     }
                                 ;     432     #endif
                                 ;     433 
                                 ;     434     #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     435     /* Attempt to acquire lock for this RSPI channel. Prevents reentrancy conflict. */
                                 ;     436     lock_result = R_BSP_HardwareLock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",436
00000268 B489                    		MOVU.B 13H[R0], R1
0000026A 71113B                  		ADD #3BH, R1
0000026D 05rrrrrr             A  		BSR _R_BSP_HardwareLock
00000271 8689                    		MOV.B R1, 1BH[R0]
00000273                         L76:	; bb59.split
                                 ;     437 
                                 ;     438     if(false == lock_result)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",438
00000273 B689                    		MOVU.B 1BH[R0], R1
00000275 6101                    		CMP #00H, R1
00000277 18                   S  		BNE L78
00000278                         L77:	; bb65
                                 ;     439     {
                                 ;     440         return RSPI_ERR_LOCK; /* The control function is currently locked. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",440
00000278 3E0108                  		MOV.L #00000008H, 04H[R0]
0000027B 38rrrr               W  		BRA L109
0000027E                         L78:	; bb72
                                 ;     441     }
                                 ;     442     #endif
                                 ;     443 
                                 ;     444     switch(cmd)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",444
0000027E AA09                    		MOV.L 24H[R0], R1
00000280 6131                    		CMP #03H, R1
00000282 3Arrrr               W  		BEQ L98
00000285                         L79:	; bb72
00000285 6121                    		CMP #02H, R1
00000287 20rr                    		BEQ L88
00000289                         L80:	; bb72
00000289 6111                    		CMP #01H, R1
0000028B 3Brrrr               W  		BNE L105
0000028E                         L81:	; bb74
                                 ;     445     {
                                 ;     446         case RSPI_CMD_SET_BAUD:
                                 ;     447         {
                                 ;     448             p_baud_struct = (rspi_cmd_baud_t *)pcmd_data;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",448
0000028E E5000802                		MOV.L 20H[R0], 08H[R0]
00000292                         L82:	; bb74.split
                                 ;     449 
                                 ;     450             reg_temp = (*g_rspi_channels[channel]).SPCR.BYTE; /* Temporarily save state of the SPCR register. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",450
00000292 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
00000298 B489                    		MOVU.B 13H[R0], R1
0000029A FE61EE                  		MOV.L [R1,R14], R14
0000029D C4E012                  		MOV.B [R14], 12H[R0]
000002A0                         L83:	; bb74.split4
                                 ;     451 
                                 ;     452             /* Temporarily disable the RSPI operation. */
                                 ;     453             /* SPE and SPTIE should be cleared simultaneously. */
                                 ;     454             (*g_rspi_channels[channel]).SPCR.BYTE = (uint8_t)(reg_temp & (~(RSPI_SPCR_SPTIE | RSPI_SPCR_SPE)));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",454
000002A0 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000002A6 B489                    		MOVU.B 13H[R0], R1
000002A8 FE61EE                  		MOV.L [R1,R14], R14
000002AB 754F9F                  		MOV.L #0000009FH, R15
000002AE 510F12                  		AND 12H[R0].UB, R15
000002B1 C3EF                    		MOV.B R15, [R14]
000002B3                         L84:	; bb74.split5
                                 ;     455 
                                 ;     456             /* Update the baud rate. */
                                 ;     457             /* Get the register settings for requested baud rate. */
                                 ;     458             if (0 == rspi_baud_set(channel, p_baud_struct->bps_target))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",458
000002B3 A881                    		MOV.L 08H[R0], R1
000002B5 EC12                    		MOV.L [R1], R2
000002B7 B489                    		MOVU.B 13H[R0], R1
000002B9 39rrrr               W  		BSR __$rspi_baud_set
000002BC 6101                    		CMP #00H, R1
000002BE B489                    		MOVU.B 13H[R0], R1
000002C0 21rr                    		BNE L87
000002C2                         L85:	; bb95
                                 ;     459             {
                                 ;     460                 #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     461                 /* Release lock for this channel. */
                                 ;     462                 R_BSP_HardwareUnlock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",462
000002C2 71113B                  		ADD #3BH, R1
000002C5 05rrrrrr             A  		BSR _R_BSP_HardwareUnlock
000002C9                         L86:	; bb95.split
                                 ;     463                 #endif
                                 ;     464                 return RSPI_ERR_ARG_RANGE; /* Could not calculate settings for the requested baud rate. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",464
000002C9 3E0106                  		MOV.L #00000006H, 04H[R0]
000002CC 38rrrr               W  		BRA L109
000002CF                         L87:	; bb109
                                 ;     465             }
                                 ;     466 
                                 ;     467             (*g_rspi_channels[channel]).SPCR.BYTE = reg_temp; /* Re-enable the RSPI operation. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",467
000002CF FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000002D5 FE61EE                  		MOV.L [R1,R14], R14
000002D8 C10E12                  		MOV.B 12H[R0], [R14]
000002DB 38rrrr               W  		BRA L107
000002DE                         L88:	; bb117
                                 ;     468         }
                                 ;     469         break;
                                 ;     470 
                                 ;     471         case RSPI_CMD_ABORT:
                                 ;     472         {
                                 ;     473              /* Perform immediate abort of the active RSPI transfer on this channel.
                                 ;     474              * Does not close the channel. */
                                 ;     475             rspi_interrupts_enable(channel, false); /* Disable interrupts in ICU. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",475
000002DE B489                    		MOVU.B 13H[R0], R1
000002E0 6602                    		MOV.L #00000000H, R2
000002E2 39rrrr               W  		BSR __$rspi_interrupts_enable
000002E5                         L89:	; bb117.split
                                 ;     476             (*g_rspi_channels[channel]).SPCR.BIT.SPE = 0;  /* Disable RSPI. Forces soft reset. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",476
000002E5 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000002EB B489                    		MOVU.B 13H[R0], R1
000002ED FE61EE                  		MOV.L [R1,R14], R14
000002F0 F0EE                    		BCLR #06H, [R14].B
000002F2                         L90:	; bb117.split6
                                 ;     477 
                                 ;     478             /* Transfer aborted. Call the user callback function passing pointer to the result structure. */
                                 ;     479             if((FIT_NO_FUNC != g_rspi_handles[channel].pcallback) && (NULL != g_rspi_handles[channel].pcallback))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",479
000002F2 B489                    		MOVU.B 13H[R0], R1
000002F4 6C31                    		SHLL #03H, R1
000002F6 FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
000002FC 4B12                    		ADD R1, R2
000002FE A829                    		MOV.L 04H[R2], R1
00000300 740100000010            		CMP #10000000H, R1
00000306 21rr                    		BNE L94
00000308 2Err                 B  		BRA L96
0000030A                         L91:	; bb132
                                 ;     480             {
                                 ;     481                 g_rspi_cb_data[channel].handle = &(g_rspi_handles[channel]);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",481
0000030A B489                    		MOVU.B 13H[R0], R1
0000030C 6C31                    		SHLL #03H, R1
0000030E FBE2rrrrrrrr            		MOV.L #__$g_rspi_cb_data, R14
00000314 4B1E                    		ADD R1, R14
00000316 FBF2rrrrrrrr            		MOV.L #__$g_rspi_handles, R15
0000031C 4B1F                    		ADD R1, R15
0000031E E3EF                    		MOV.L R15, [R14]
00000320                         L92:	; bb132.split
                                 ;     482                 g_rspi_cb_data[channel].event_code = RSPI_EVT_TRANSFER_ABORTED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",482
00000320 B489                    		MOVU.B 13H[R0], R1
00000322 6C31                    		SHLL #03H, R1
00000324 FB22rrrrrrrr            		MOV.L #__$g_rspi_cb_data, R2
0000032A 4B12                    		ADD R1, R2
0000032C 3E2101                  		MOV.L #00000001H, 04H[R2]
0000032F                         L93:	; bb132.split7
                                 ;     483                 g_rspi_handles[channel].pcallback((void*)&(g_rspi_cb_data[channel]));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",483
0000032F B48A                    		MOVU.B 13H[R0], R2
00000331 6C32                    		SHLL #03H, R2
00000333 FB12rrrrrrrr            		MOV.L #__$g_rspi_handles, R1
00000339 4B21                    		ADD R2, R1
0000033B A81B                    		MOV.L 04H[R1], R3
0000033D FB12rrrrrrrr            		MOV.L #__$g_rspi_cb_data, R1
00000343 4B21                    		ADD R2, R1
00000345 7F13                    		JSR R3
00000347 2Err                 B  		BRA L107
00000349                         L94:	; bb160
00000349 B489                    		MOVU.B 13H[R0], R1
0000034B 6C31                    		SHLL #03H, R1
0000034D FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
00000353 4B12                    		ADD R1, R2
00000355 A829                    		MOV.L 04H[R2], R1
00000357 6101                    		CMP #00H, R1
00000359 10                   S  		BEQ L96
0000035A                         L95:	; bb168
0000035A F80601                  		MOV.L #00000001H, [R0]
0000035D 08                   S  		BRA L97
0000035E                         L96:	; bb169
0000035E F80600                  		MOV.L #00000000H, [R0]
00000361                         L97:	; bb170
00000361 EC01                    		MOV.L [R0], R1
00000363 6101                    		CMP #00H, R1
00000365 21rr                    		BNE L91
00000367 2Err                 B  		BRA L107
00000369                         L98:	; bb176
                                 ;     484             }
                                 ;     485 
                                 ;     486         }
                                 ;     487         break;
                                 ;     488 
                                 ;     489         case RSPI_CMD_SETREGS:   // Expert use only! Set all user supported RSPI regs in one operation.
                                 ;     490         {
                                 ;     491             /* Overrides driver default settings.
                                 ;     492              * Copies user-specified register settings into driver's shadow copy.
                                 ;     493              * Settings do not take effect until the channel is closed and then reopened.
                                 ;     494              */
                                 ;     495             p_setregs_struct = (rspi_cmd_setregs_t *)pcmd_data;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",495
00000369 E5000803                		MOV.L 20H[R0], 0CH[R0]
0000036D                         L99:	; bb176.split
                                 ;     496             new_reg_settings->spckd_val = p_setregs_struct->spckd_val;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",496
0000036D A889                    		MOV.L 0CH[R0], R1
0000036F A90A                    		MOV.L 14H[R0], R2
00000371 C5120206                		MOV.B 02H[R1], 06H[R2]
00000375                         L100:	; bb176.split8
                                 ;     497             new_reg_settings->spcr2_val = p_setregs_struct->spcr2_val;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",497
00000375 A889                    		MOV.L 0CH[R0], R1
00000377 B119                    		MOVU.B 05H[R1], R1
00000379 A90A                    		MOV.L 14H[R0], R2
0000037B A0A9                    		MOV.L R1, 0CH[R2]
0000037D                         L101:	; bb176.split9
                                 ;     498             new_reg_settings->spnd_val  = p_setregs_struct->spnd_val;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",498
0000037D A889                    		MOV.L 0CH[R0], R1
0000037F A90A                    		MOV.L 14H[R0], R2
00000381 C5120408                		MOV.B 04H[R1], 08H[R2]
00000385                         L102:	; bb176.split10
                                 ;     499             new_reg_settings->sppcr_val = p_setregs_struct->sppcr_val;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",499
00000385 A889                    		MOV.L 0CH[R0], R1
00000387 A90A                    		MOV.L 14H[R0], R2
00000389 C5120102                		MOV.B 01H[R1], 02H[R2]
0000038D                         L103:	; bb176.split11
                                 ;     500             new_reg_settings->sslnd_val = p_setregs_struct->sslnd_val;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",500
0000038D A889                    		MOV.L 0CH[R0], R1
0000038F A90A                    		MOV.L 14H[R0], R2
00000391 C5120307                		MOV.B 03H[R1], 07H[R2]
00000395                         L104:	; bb176.split12
                                 ;     501             new_reg_settings->sslp_val  = p_setregs_struct->sslp_val;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",501
00000395 A889                    		MOV.L 0CH[R0], R1
00000397 A90A                    		MOV.L 14H[R0], R2
00000399 C41201                  		MOV.B [R1], 01H[R2]
0000039C 2Err                 B  		BRA L107
0000039E                         L105:	; bb210
                                 ;     502         }
                                 ;     503         break;
                                 ;     504 
                                 ;     505         default:
                                 ;     506         {
                                 ;     507             #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     508             /* Release lock for this channel. */
                                 ;     509             R_BSP_HardwareUnlock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",509
0000039E B489                    		MOVU.B 13H[R0], R1
000003A0 71113B                  		ADD #3BH, R1
000003A3 05rrrrrr             A  		BSR _R_BSP_HardwareUnlock
000003A7                         L106:	; bb210.split
                                 ;     510             #endif
                                 ;     511             /* Error, command not recognized. */
                                 ;     512             return RSPI_ERR_UNKNOWN_CMD;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",512
000003A7 3E0104                  		MOV.L #00000004H, 04H[R0]
000003AA 2Err                 B  		BRA L109
000003AC                         L107:	; bb216
                                 ;     513         }
                                 ;     514     }
                                 ;     515 
                                 ;     516     #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     517     /* Release lock for this channel. */
                                 ;     518     R_BSP_HardwareUnlock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",518
000003AC B489                    		MOVU.B 13H[R0], R1
000003AE 71113B                  		ADD #3BH, R1
000003B1 05rrrrrr             A  		BSR _R_BSP_HardwareUnlock
000003B5                         L108:	; bb216.split
                                 ;     519     #endif
                                 ;     520 
                                 ;     521 	return RSPI_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",521
000003B5 3E0100                  		MOV.L #00000000H, 04H[R0]
000003B8                         L109:	; bb222
000003B8 A809                    		MOV.L 04H[R0], R1
000003BA A189                    		MOV.L R1, 1CH[R0]
                                 ;     522 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",522
000003BC 670B                    		RTSD #2CH
000003BE                         _R_RSPI_Read:
                                 		.STACK	_R_RSPI_Read=44
                                 ;     523 /* end of function R_RSPI_Control(). */
                                 ;     524 
                                 ;     525 
                                 ;     526 /***********************************************************************************************************************
                                 ;     527 * Function Name: R_RSPI_Read
                                 ;     528 * Description  : Receives data from a SPI device.
                                 ;     529 * Arguments    : handle-
                                 ;     530 *                   Handle for the channel
                                 ;     531 *                spcmd_command_word-
                                 ;     532 *                   bitfield data consisting of all the RSPI command register settings for SPCMD for this operation.
                                 ;     533 *                   This value will be placed directly into the SPCMD register by the function. Caller is required to
                                 ;     534 *                   provide correctly formatted data.
                                 ;     535 *                pdest-
                                 ;     536 *                   Pointer to destination buffer into which data will be copied that is received from a SPI .
                                 ;     537 *                   It is the responsibility of the caller to insure that adequate space is available to hold the
                                 ;     538 *                   requested data count.
                                 ;     539 *                length-
                                 ;     540 *                   Indicates the number of data words to be transferred. The size of the data word is determined from
                                 ;     541 *                   the channel configuration data structure referenced by the channel handle.
                                 ;     542 * Return Value : RSPI_SUCCESS-
                                 ;     543 *                   Read operation successfully completed.
                                 ;     544 *                RSPI_ERR_CH_NOT_OPEN-
                                 ;     545 *                   The channel has not been opened.  Perform R_RSPI_Open() first
                                 ;     546 *                RSPI_ERR_BAD_CHAN-
                                 ;     547 *                   Channel number is invalid for part
                                 ;     548 *                RSPI_ERR_NULL_PTR-
                                 ;     549 *                   A required pointer argument is NULL
                                 ;     550 *                RSPI_ERR_LOCK-
                                 ;     551 *                      The lock could not be acquired. The channel is busy.
                                 ;     552 ***********************************************************************************************************************/
                                 ;     553 rspi_err_t  R_RSPI_Read(rspi_handle_t        handle,
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",553
000003BE 7100E0                  		ADD #0FFFFFFE0H, R0
000003C1 A18A                    		MOV.L R2, 1CH[R0]
000003C3 A181                    		MOV.L R1, 18H[R0]
000003C5 A10B                    		MOV.L R3, 14H[R0]
000003C7 920C                    		MOV.W R4, 12H[R0]
                                 ;     554                         rspi_command_word_t  spcmd_command_word,
                                 ;     555                         void                *pdest,
                                 ;     556                         uint16_t             length)
                                 ;     557 {
                                 ;     558     rspi_err_t  result;
                                 ;     559 
                                 ;     560     #if RSPI_CFG_PARAM_CHECKING_ENABLE == 1
                                 ;     561     if ((NULL == handle) || (NULL == pdest))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",561
000003C9 A981                    		MOV.L 18H[R0], R1
000003CB 6101                    		CMP #00H, R1
000003CD 20rr                    		BEQ L113
000003CF 08                   S  		BRA L112
000003D0                         L111:	; bb6
                                 ;     562     {
                                 ;     563         return RSPI_ERR_NULL_PTR;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",563
000003D0 3E0107                  		MOV.L #00000007H, 04H[R0]
000003D3 2Err                 B  		BRA L118
000003D5                         L112:	; bb11
000003D5 A909                    		MOV.L 14H[R0], R1
000003D7 6101                    		CMP #00H, R1
000003D9 18                   S  		BNE L114
000003DA                         L113:	; bb15
000003DA F80601                  		MOV.L #00000001H, [R0]
000003DD 08                   S  		BRA L115
000003DE                         L114:	; bb16
000003DE F80600                  		MOV.L #00000000H, [R0]
000003E1                         L115:	; bb17
000003E1 EC01                    		MOV.L [R0], R1
000003E3 6101                    		CMP #00H, R1
000003E5 21rr                    		BNE L111
000003E7                         L116:	; bb21
                                 ;     564     }
                                 ;     565     #endif
                                 ;     566 
                                 ;     567     result = rspi_write_read_common(handle, spcmd_command_word, NULL, pdest, length, RSPI_DO_RX);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",567
000003E7 A98A                    		MOV.L 1CH[R0], R2
000003E9 9A0B                    		MOV.W 12H[R0], R3
000003EB A90C                    		MOV.L 14H[R0], R4
000003ED A981                    		MOV.L 18H[R0], R1
000003EF 6080                    		SUB #08H, R0
000003F1 D303                    		MOV.W R3, [R0]
000003F3 3E0102                  		MOV.L #00000002H, 04H[R0]
000003F6 6603                    		MOV.L #00000000H, R3
000003F8 39rrrr               W  		BSR __$rspi_write_read_common
000003FB 6280                    		ADD #08H, R0
000003FD A081                    		MOV.L R1, 08H[R0]
000003FF                         L117:	; bb21.split
                                 ;     568 
                                 ;     569     return result;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",569
000003FF E5000201                		MOV.L 08H[R0], 04H[R0]
00000403                         L118:	; bb28
00000403 A809                    		MOV.L 04H[R0], R1
00000405 A089                    		MOV.L R1, 0CH[R0]
                                 ;     570 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",570
00000407 6708                    		RTSD #20H
00000409                         _R_RSPI_Write:
                                 		.STACK	_R_RSPI_Write=44
                                 ;     571 /* end of function R_RSPI_Read(). */
                                 ;     572 
                                 ;     573 
                                 ;     574 /***********************************************************************************************************************
                                 ;     575 * Function Name: R_RSPI_Write
                                 ;     576 * Description  : Transmits data to a SPI  device.  The operation differs slightly depending on whether it is using
                                 ;     577 *                SPI mode or Clock-Synchronous mode.
                                 ;     578 * Arguments    : handle-
                                 ;     579 *                   Handle for the channel
                                 ;     580 *                spcmd_command_word-
                                 ;     581 *                   bitfield data consisting of all the RSPI command register settings for SPCMD for this operation.
                                 ;     582 *                   This value will be placed directly into the SPCMD register by the function. Caller is required to
                                 ;     583 *                   provide correctly formatted data.
                                 ;     584 *                psrc-
                                 ;     585 *                   Pointer to a source data buffer from which data will be transmitted to a SPI device.
                                 ;     586 *                   The argument must not be NULL.
                                 ;     587 *                length-
                                 ;     588 *                   Indicates the number of data words to be transferred. The size of the data word is determined from
                                 ;     589 *                   the channel configuration data structure referenced by the channel handle.
                                 ;     590 * Return Value : RSPI_SUCCESS-
                                 ;     591 *                   Write operation successfully completed.
                                 ;     592 *                RSPI_ERR_CH_NOT_OPEN-
                                 ;     593 *                   The channel has not been opened.  Perform R_RSPI_Open() first
                                 ;     594 *                RSPI_ERR_BAD_CHAN-
                                 ;     595 *                   Channel number is invalid for part
                                 ;     596 *                RSPI_ERR_NULL_PTR-
                                 ;     597 *                   A required pointer argument is NULL
                                 ;     598 ***********************************************************************************************************************/
                                 ;     599 rspi_err_t  R_RSPI_Write(rspi_handle_t        handle,
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",599
00000409 7100E0                  		ADD #0FFFFFFE0H, R0
0000040C A18A                    		MOV.L R2, 1CH[R0]
0000040E A181                    		MOV.L R1, 18H[R0]
00000410 A10B                    		MOV.L R3, 14H[R0]
00000412 920C                    		MOV.W R4, 12H[R0]
                                 ;     600                          rspi_command_word_t  spcmd_command_word,
                                 ;     601                          void                *psrc,
                                 ;     602                          uint16_t             length)
                                 ;     603 {
                                 ;     604     rspi_err_t  result;
                                 ;     605 
                                 ;     606     #if RSPI_CFG_PARAM_CHECKING_ENABLE == 1
                                 ;     607     if ((NULL == handle) || (NULL == psrc))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",607
00000414 A981                    		MOV.L 18H[R0], R1
00000416 6101                    		CMP #00H, R1
00000418 20rr                    		BEQ L122
0000041A 08                   S  		BRA L121
0000041B                         L120:	; bb6
                                 ;     608     {
                                 ;     609         return RSPI_ERR_NULL_PTR;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",609
0000041B 3E0107                  		MOV.L #00000007H, 04H[R0]
0000041E 2Err                 B  		BRA L127
00000420                         L121:	; bb11
00000420 A909                    		MOV.L 14H[R0], R1
00000422 6101                    		CMP #00H, R1
00000424 18                   S  		BNE L123
00000425                         L122:	; bb15
00000425 F80601                  		MOV.L #00000001H, [R0]
00000428 08                   S  		BRA L124
00000429                         L123:	; bb16
00000429 F80600                  		MOV.L #00000000H, [R0]
0000042C                         L124:	; bb17
0000042C EC01                    		MOV.L [R0], R1
0000042E 6101                    		CMP #00H, R1
00000430 21rr                    		BNE L120
00000432                         L125:	; bb21
                                 ;     610     }
                                 ;     611     #endif
                                 ;     612 
                                 ;     613     result = rspi_write_read_common(handle, spcmd_command_word, psrc, NULL, length, RSPI_DO_TX);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",613
00000432 A98A                    		MOV.L 1CH[R0], R2
00000434 9A0C                    		MOV.W 12H[R0], R4
00000436 A90B                    		MOV.L 14H[R0], R3
00000438 A981                    		MOV.L 18H[R0], R1
0000043A 6080                    		SUB #08H, R0
0000043C D304                    		MOV.W R4, [R0]
0000043E 3E0101                  		MOV.L #00000001H, 04H[R0]
00000441 6604                    		MOV.L #00000000H, R4
00000443 39rrrr               W  		BSR __$rspi_write_read_common
00000446 6280                    		ADD #08H, R0
00000448 A081                    		MOV.L R1, 08H[R0]
0000044A                         L126:	; bb21.split
                                 ;     614 
                                 ;     615     return result;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",615
0000044A E5000201                		MOV.L 08H[R0], 04H[R0]
0000044E                         L127:	; bb28
0000044E A809                    		MOV.L 04H[R0], R1
00000450 A089                    		MOV.L R1, 0CH[R0]
                                 ;     616 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",616
00000452 6708                    		RTSD #20H
00000454                         _R_RSPI_WriteRead:
                                 		.STACK	_R_RSPI_WriteRead=48
                                 ;     617 /* end of function R_RSPI_Write(). */
                                 ;     618 
                                 ;     619 
                                 ;     620 /***********************************************************************************************************************
                                 ;     621 * Function Name: R_RSPI_WriteRead
                                 ;     622 * Description  : Simultaneously transmits data to SPI device while receiving data from SPI device
                                 ;     623 *                (full duplex).
                                 ;     624 *                The operation differs slightly depending on whether it is using SPI mode or Clock-Synchronous mode.
                                 ;     625 * Arguments    : handle-
                                 ;     626 *                   Handle for the channel
                                 ;     627 *                spcmd_command_word-
                                 ;     628 *                   bitfield data consisting of all the RSPI command register settings for SPCMD for this operation.
                                 ;     629 *                   This value will be placed directly into the SPCMD0 register by the function. Caller is required to
                                 ;     630 *                   provide correctly formatted data.
                                 ;     631 *                psrc-
                                 ;     632 *                   Pointer to a source data buffer from which data will be transmitted to a SPI device.
                                 ;     633 *                   The argument must not be NULL.
                                 ;     634 *                pdest-
                                 ;     635 *                   Pointer to destination buffer into which data will be copied that has been received from SPI slave.
                                 ;     636 *                   Caller must insure that adequate space is available to hold the requested data count.
                                 ;     637 *                   Argument must not be NULL.
                                 ;     638 *                length-
                                 ;     639 *                   Indicates the number of data words to be transferred. The size of the data word is determined from
                                 ;     640 *                   the channel configuration data structure referenced by the channel handle.
                                 ;     641 * Return Value : RSPI_SUCCESS
                                 ;     642 *                RSPI_ERR_CH_NOT_OPEN-
                                 ;     643 *                   The channel has not been opened.  Perform R_RSPI_Open() first
                                 ;     644 *                RSPI_ERR_BAD_CHAN-
                                 ;     645 *                   Channel number is invalid for part
                                 ;     646 *                RSPI_ERR_NULL_PTR-
                                 ;     647 *                   A required pointer argument is NULL
                                 ;     648 *                RSPI_ERR_LOCK-
                                 ;     649 *                      The lock could not be acquired. The channel is busy.
                                 ;     650 ***********************************************************************************************************************/
                                 ;     651 rspi_err_t  R_RSPI_WriteRead(rspi_handle_t        handle,
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",651
00000454 7100DC                  		ADD #0FFFFFFDCH, R0
00000457 A202                    		MOV.L R2, 20H[R0]
00000459 A189                    		MOV.L R1, 1CH[R0]
0000045B A183                    		MOV.L R3, 18H[R0]
0000045D A10C                    		MOV.L R4, 14H[R0]
0000045F D5001409                		MOV.W 28H[R0], 12H[R0]
                                 ;     652                              rspi_command_word_t  spcmd_command_word,
                                 ;     653                              void                *psrc,
                                 ;     654                              void                *pdest,
                                 ;     655                              uint16_t             length)
                                 ;     656 {
                                 ;     657     rspi_err_t  result;
                                 ;     658 
                                 ;     659     #if RSPI_CFG_PARAM_CHECKING_ENABLE == 1
                                 ;     660     if ((NULL == handle) || (NULL == psrc) || (NULL == pdest))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",660
00000463 A989                    		MOV.L 1CH[R0], R1
00000465 6101                    		CMP #00H, R1
00000467 20rr                    		BEQ L131
00000469 08                   S  		BRA L130
0000046A                         L129:	; bb7
                                 ;     661     {
                                 ;     662         return RSPI_ERR_NULL_PTR;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",662
0000046A 3E0107                  		MOV.L #00000007H, 04H[R0]
0000046D 2Err                 B  		BRA L140
0000046F                         L130:	; bb12
0000046F A981                    		MOV.L 18H[R0], R1
00000471 6101                    		CMP #00H, R1
00000473 18                   S  		BNE L132
00000474                         L131:	; bb16
00000474 F80601                  		MOV.L #00000001H, [R0]
00000477 08                   S  		BRA L133
00000478                         L132:	; bb17
00000478 F80600                  		MOV.L #00000000H, [R0]
0000047B                         L133:	; bb18
0000047B EC01                    		MOV.L [R0], R1
0000047D 6101                    		CMP #00H, R1
0000047F 18                   S  		BNE L135
00000480                         L134:	; bb21
00000480 A909                    		MOV.L 14H[R0], R1
00000482 6101                    		CMP #00H, R1
00000484 18                   S  		BNE L136
00000485                         L135:	; bb25
00000485 F80601                  		MOV.L #00000001H, [R0]
00000488 08                   S  		BRA L137
00000489                         L136:	; bb26
00000489 F80600                  		MOV.L #00000000H, [R0]
0000048C                         L137:	; bb27
0000048C EC01                    		MOV.L [R0], R1
0000048E 6101                    		CMP #00H, R1
00000490 21rr                    		BNE L129
00000492                         L138:	; bb32
                                 ;     663     }
                                 ;     664     #endif
                                 ;     665 
                                 ;     666     result = rspi_write_read_common(handle, spcmd_command_word, psrc, pdest, length, RSPI_DO_TX_RX);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",666
00000492 AA02                    		MOV.L 20H[R0], R2
00000494 9A0D                    		MOV.W 12H[R0], R5
00000496 A90C                    		MOV.L 14H[R0], R4
00000498 A983                    		MOV.L 18H[R0], R3
0000049A A989                    		MOV.L 1CH[R0], R1
0000049C 6080                    		SUB #08H, R0
0000049E D305                    		MOV.W R5, [R0]
000004A0 3E0103                  		MOV.L #00000003H, 04H[R0]
000004A3 39rrrr               W  		BSR __$rspi_write_read_common
000004A6 6280                    		ADD #08H, R0
000004A8 A081                    		MOV.L R1, 08H[R0]
000004AA                         L139:	; bb32.split
                                 ;     667 
                                 ;     668     return result;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",668
000004AA E5000201                		MOV.L 08H[R0], 04H[R0]
000004AE                         L140:	; bb40
000004AE A809                    		MOV.L 04H[R0], R1
000004B0 A089                    		MOV.L R1, 0CH[R0]
                                 ;     669 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",669
000004B2 6709                    		RTSD #24H
000004B4                         __$rspi_write_read_common:
                                 		.STACK	__$rspi_write_read_common=48
                                 ;     670 /* end of function R_RSPI_WriteRead(). */
                                 ;     671 
                                 ;     672 /***********************************************************************************************************************
                                 ;     673 * Function Name: rspi_write_read_common
                                 ;     674 * Description  : Initiates write or read process. Common routine used by RSPI API write or read functions.
                                 ;     675 * Arguments    : handle-
                                 ;     676 *                   Handle for the channel
                                 ;     677 *                command_word-
                                 ;     678 *                   bitfield data consisting of all the RSPI command register settings for SPCMD for this operation.
                                 ;     679 *                   This value will be placed directly into the SPCMD0 register by the function. Caller is required to
                                 ;     680 *                   provide correctly formatted data.
                                 ;     681 *                psrc-
                                 ;     682 *                   For write operations, pointer to the source buffer of the data to be sent.
                                 ;     683 *                pdest-
                                 ;     684 *                   For read operations, pointer to destination buffer into which receuved data will be copied.
                                 ;     685 *                length-
                                 ;     686 *                   The number of data words to be transferred.
                                 ;     687 * Return Value : RSPI_SUCCESS
                                 ;     688 *                RSPI_ERR_CH_NOT_OPEN-
                                 ;     689 *                   The channel has not been opened.  Perform R_RSPI_Open() first
                                 ;     690 *                RSPI_ERR_LOCK-
                                 ;     691 *                      The lock could not be acquired. The channel is busy.
                                 ;     692 ***********************************************************************************************************************/
                                 ;     693 static rspi_err_t  rspi_write_read_common(rspi_handle_t handle,
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",693
000004B4 7EA6                    		PUSH.L R6
000004B6 7100D8                  		ADD #0FFFFFFD8H, R0
000004B9 A20A                    		MOV.L R2, 24H[R0]
000004BB A201                    		MOV.L R1, 20H[R0]
000004BD A18B                    		MOV.L R3, 1CH[R0]
000004BF A184                    		MOV.L R4, 18H[R0]
000004C1 D500180B                		MOV.W 30H[R0], 16H[R0]
000004C5 E5000D04                		MOV.L 34H[R0], 10H[R0]
                                 ;     694                                           rspi_command_word_t command_word,
                                 ;     695                                           void          *psrc,
                                 ;     696                                           void          *pdest,
                                 ;     697                                           uint16_t      length,
                                 ;     698                                           rspi_operation_t   tx_rx_mode)
                                 ;     699 {
                                 ;     700     uint8_t  channel = handle->channel;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",700
000004C9 AA01                    		MOV.L 20H[R0], R1
000004CB C4100A                  		MOV.B [R1], 0AH[R0]
000004CE                         L142:	; entry.split
                                 ;     701 
                                 ;     702     #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     703     bool     lock_result = false;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",703
000004CE 3C0B00                  		MOV.B #00H, 0BH[R0]
000004D1                         L143:	; entry.split3
                                 ;     704     #endif
                                 ;     705 
                                 ;     706     if (!g_rspi_handles[channel].rspi_chnl_opened)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",706
000004D1 B281                    		MOVU.B 0AH[R0], R1
000004D3 6C31                    		SHLL #03H, R1
000004D5 FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
000004DB 4B12                    		ADD R1, R2
000004DD B0A1                    		MOVU.B 02H[R2], R1
000004DF 6101                    		CMP #00H, R1
000004E1 18                   S  		BNE L145
000004E2 2Err                 B  		BRA L146
000004E4                         L144:	; bb12
                                 ;     707     {
                                 ;     708         return RSPI_ERR_CH_NOT_OPENED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",708
000004E4 3E0102                  		MOV.L #00000002H, 04H[R0]
000004E7 38rrrr               W  		BRA L174
000004EA                         L145:	; bb22
000004EA F80600                  		MOV.L #00000000H, [R0]
000004ED 08                   S  		BRA L147
000004EE                         L146:	; bb23
000004EE F80601                  		MOV.L #00000001H, [R0]
000004F1                         L147:	; bb24
000004F1 EC01                    		MOV.L [R0], R1
000004F3 6101                    		CMP #00H, R1
000004F5 21rr                    		BNE L144
000004F7                         L148:	; bb27
                                 ;     709     }
                                 ;     710 
                                 ;     711     #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;     712     /* Attempt to acquire lock for this RSPI channel. Prevents reentrancy conflict. */
                                 ;     713     lock_result = R_BSP_HardwareLock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",713
000004F7 B281                    		MOVU.B 0AH[R0], R1
000004F9 71113B                  		ADD #3BH, R1
000004FC 05rrrrrr             A  		BSR _R_BSP_HardwareLock
00000500 8289                    		MOV.B R1, 0BH[R0]
00000502                         L149:	; bb27.split
                                 ;     714 
                                 ;     715     if(false == lock_result)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",715
00000502 B289                    		MOVU.B 0BH[R0], R1
00000504 6101                    		CMP #00H, R1
00000506 18                   S  		BNE L151
00000507                         L150:	; bb33
                                 ;     716     {
                                 ;     717         return RSPI_ERR_LOCK; /* The control function is currently locked. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",717
00000507 3E0108                  		MOV.L #00000008H, 04H[R0]
0000050A 38rrrr               W  		BRA L174
0000050D                         L151:	; bb40
                                 ;     718     }
                                 ;     719     #endif
                                 ;     720 
                                 ;     721     rspi_interrupts_enable(channel, false);     /* Disable interrupts in ICU. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",721
0000050D B281                    		MOVU.B 0AH[R0], R1
0000050F 6602                    		MOV.L #00000000H, R2
00000511 39rrrr               W  		BSR __$rspi_interrupts_enable
00000514                         L152:	; bb40.split
                                 ;     722 
                                 ;     723     g_rspi_tcb[channel].xfr_length = length;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",723
00000514 B281                    		MOVU.B 0AH[R0], R1
00000516 751118                  		MUL #18H, R1
00000519 FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
0000051F 4B12                    		ADD R1, R2
00000521 D5020B06                		MOV.W 16H[R0], 0CH[R2]
00000525                         L153:	; bb40.split4
                                 ;     724     g_rspi_tcb[channel].tx_count = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",724
00000525 B281                    		MOVU.B 0AH[R0], R1
00000527 751118                  		MUL #18H, R1
0000052A FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
00000530 4B12                    		ADD R1, R2
00000532 3D2400                  		MOV.W #0000H, 08H[R2]
00000535                         L154:	; bb40.split5
                                 ;     725     g_rspi_tcb[channel].rx_count = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",725
00000535 B281                    		MOVU.B 0AH[R0], R1
00000537 751118                  		MUL #18H, R1
0000053A FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
00000540 4B12                    		ADD R1, R2
00000542 3D2500                  		MOV.W #0000H, 0AH[R2]
00000545                         L155:	; bb40.split6
                                 ;     726     g_rspi_tcb[channel].bytes_per_transfer = rspi_get_data_type(command_word);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",726
00000545 AA09                    		MOV.L 24H[R0], R1
00000547 B286                    		MOVU.B 0AH[R0], R6
00000549 39rrrr               W  		BSR _rspi_get_data_type
0000054C 751618                  		MUL #18H, R6
0000054F FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
00000555 4B62                    		ADD R6, R2
00000557 83A1                    		MOV.B R1, 0EH[R2]
00000559                         L156:	; bb40.split7
                                 ;     727     g_rspi_tcb[channel].psrc = psrc;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",727
00000559 B281                    		MOVU.B 0AH[R0], R1
0000055B 751118                  		MUL #18H, R1
0000055E FBE2rrrrrrrr            		MOV.L #__$g_rspi_tcb, R14
00000564 4B1E                    		ADD R1, R14
00000566 E10E07                  		MOV.L 1CH[R0], [R14]
00000569                         L157:	; bb40.split8
                                 ;     728     g_rspi_tcb[channel].pdest = pdest;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",728
00000569 B281                    		MOVU.B 0AH[R0], R1
0000056B 751118                  		MUL #18H, R1
0000056E FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
00000574 4B12                    		ADD R1, R2
00000576 E5020601                		MOV.L 18H[R0], 04H[R2]
0000057A                         L158:	; bb40.split9
                                 ;     729     g_rspi_tcb[channel].transfer_mode = tx_rx_mode;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",729
0000057A B281                    		MOVU.B 0AH[R0], R1
0000057C 751118                  		MUL #18H, R1
0000057F FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
00000585 4B12                    		ADD R1, R2
00000587 E5020405                		MOV.L 10H[R0], 14H[R2]
0000058B                         L159:	; bb40.split10
                                 ;     730 
                                 ;     731     if (tx_rx_mode & RSPI_DO_TX)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",731
0000058B B281                    		MOVU.B 0AH[R0], R1
0000058D 751118                  		MUL #18H, R1
00000590 FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
00000596 4B12                    		ADD R1, R2
00000598 A901                    		MOV.L 10H[R0], R1
0000059A 7C01                    		BTST #00H, R1
0000059C 10                   S  		BEQ L161
0000059D                         L160:	; bb76
                                 ;     732     {
                                 ;     733         g_rspi_tcb[channel].do_tx = true;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",733
0000059D 3CA001                  		MOV.B #01H, 10H[R2]
000005A0 08                   S  		BRA L162
000005A1                         L161:	; bb81
                                 ;     734     }
                                 ;     735     else
                                 ;     736     {
                                 ;     737         g_rspi_tcb[channel].do_tx = false;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",737
000005A1 3CA000                  		MOV.B #00H, 10H[R2]
000005A4                         L162:	; bb91
                                 ;     738     }
                                 ;     739 
                                 ;     740     g_rspi_tcb[channel].do_rx_now = false;  // Initialize receive state flag.
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",740
000005A4 B281                    		MOVU.B 0AH[R0], R1
000005A6 751118                  		MUL #18H, R1
000005A9 FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
000005AF 4B12                    		ADD R1, R2
000005B1 3C2F00                  		MOV.B #00H, 0FH[R2]
000005B4                         L163:	; bb97
                                 ;     741 
                                 ;     742     #if RSPI_CFG_MASK_UNUSED_BITS == (1)
                                 ;     743     /* Get the data frame bit mask. */
                                 ;     744     g_rspi_tcb[channel].unused_bits_mask = g_unused_bits_masks[command_word.bit_length];
                                 ;     745     #endif
                                 ;     746 
                                 ;     747     /* Wait for channel to be idle before making changes to registers. */
                                 ;     748     while ((*g_rspi_channels[channel]).SPSR.BIT.IDLNF)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",748
000005B4 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000005BA B281                    		MOVU.B 0AH[R0], R1
000005BC FE61E1                  		MOV.L [R1,R14], R1
000005BF B099                    		MOVU.B 03H[R1], R1
000005C1 6811                    		SHLR #01H, R1
000005C3 7C01                    		BTST #00H, R1
000005C5 21rr                    		BNE L163
000005C7                         L164:	; bb114
                                 ;     749     {
                                 ;     750     }
                                 ;     751 
                                 ;     752     /* Update the SPCMD0 command register with the settings for this transfer. */
                                 ;     753     (*g_rspi_channels[channel]).SPCMD0.WORD = command_word.word;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",753
000005C7 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000005CD B281                    		MOVU.B 0AH[R0], R1
000005CF FE61E1                  		MOV.L [R1,R14], R1
000005D2 D5011208                		MOV.W 24H[R0], 10H[R1]
000005D6                         L165:	; bb114.split
                                 ;     754 
                                 ;     755     /* If slave mode, force CPHA bit in command register to 1 to properly support 'burst' operation. */
                                 ;     756     if (0 == ((*g_rspi_channels[channel]).SPCR.BIT.MSTR))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",756
000005D6 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000005DC B281                    		MOVU.B 0AH[R0], R1
000005DE FE61EE                  		MOV.L [R1,R14], R14
000005E1 58EE                    		MOVU.B [R14], R14
000005E3 683E                    		SHLR #03H, R14
000005E5 7C0E                    		BTST #00H, R14
000005E7 21rr                    		BNE L168
000005E9                         L166:	; bb126
                                 ;     757     {
                                 ;     758         (*g_rspi_channels[channel]).SPCMD0.BIT.CPHA = 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",758
000005E9 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000005EF B281                    		MOVU.B 0AH[R0], R1
000005F1 FE61E1                  		MOV.L [R1,R14], R1
000005F4 9A12                    		MOV.W 10H[R1], R2
000005F6 7802                    		BSET #00H, R2
000005F8 9212                    		MOV.W R2, 10H[R1]
000005FA 08                   S  		BRA L168
000005FB                         L167:	; bb157
                                 ;     759     }
                                 ;     760 
                                 ;     761     /* Clear error sources: the SPSR.MODF, OVRF, and PERF flags. */
                                 ;     762     while((*g_rspi_channels[channel]).SPSR.BYTE & (RSPI_SPSR_OVRF | RSPI_SPSR_MODF | RSPI_SPSR_PERF))
                                 ;     763     {
                                 ;     764         (*g_rspi_channels[channel]).SPSR.BYTE = RSPI_SPSR_MASK;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",764
000005FB 3C13A0                  		MOV.B #0A0H, 03H[R1]
000005FE                         L168:	; bb164
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",762
000005FE FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
00000604 B281                    		MOVU.B 0AH[R0], R1
00000606 FE61EF                  		MOV.L [R1,R14], R15
00000609 66D5                    		MOV.L #0000000DH, R5
0000060B FC31F503                		TST 03H[R15].UB, R5
0000060F B281                    		MOVU.B 0AH[R0], R1
00000611 FE61E1                  		MOV.L [R1,R14], R1
00000614 21rr                    		BNE L167
00000616                         L169:	; bb177
                                 ;     765     }
                                 ;     766 
                                 ;     767     (*g_rspi_channels[channel]).SPCR2.BIT.SPIIE = 0; /* Disable idle interrrupt. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",767
00000616 F11A0F                  		BCLR #02H, 0FH[R1].B
00000619                         L170:	; bb177.split
                                 ;     768     rspi_interrupts_clear(channel);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",768
00000619 B281                    		MOVU.B 0AH[R0], R1
0000061B 39rrrr               W  		BSR __$rspi_interrupts_clear
0000061E                         L171:	; bb177.split11
                                 ;     769     rspi_interrupts_enable(channel, true);           /* Enable interrupts in ICU. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",769
0000061E B281                    		MOVU.B 0AH[R0], R1
00000620 6612                    		MOV.L #00000001H, R2
00000622 39rrrr               W  		BSR __$rspi_interrupts_enable
00000625                         L172:	; bb177.split12
                                 ;     770 
                                 ;     771     /* Enable transmit buffer empty interrupt, Receive buffer full interrupt,
                                 ;     772      * and enable RSPI simultaneously. This will generate an SPTI interrupt,
                                 ;     773      * and data transfer will proceed in the ISRs. */
                                 ;     774     (*g_rspi_channels[channel]).SPCR.BYTE |= (RSPI_SPCR_SPTIE | RSPI_SPCR_SPRIE | RSPI_SPCR_SPEIE | RSPI_SPCR_SPE);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",774
00000625 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
0000062B B281                    		MOVU.B 0AH[R0], R1
0000062D FE61EE                  		MOV.L [R1,R14], R14
00000630 754FF0                  		MOV.L #000000F0H, R15
00000633 54EF                    		OR [R14].UB, R15
00000635 C3EF                    		MOV.B R15, [R14]
00000637                         L173:	; bb177.split13
                                 ;     775 
                                 ;     776     return RSPI_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",776
00000637 3E0100                  		MOV.L #00000000H, 04H[R0]
0000063A                         L174:	; bb203
0000063A A809                    		MOV.L 04H[R0], R1
0000063C A089                    		MOV.L R1, 0CH[R0]
                                 ;     777 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",777
0000063E 3F660B                  		RTSD #2CH, R6-R6
00000641                         _R_RSPI_Close:
                                 		.STACK	_R_RSPI_Close=20
                                 ;     778 /* end of function R_RSPI_WriteRead(). */
                                 ;     779 
                                 ;     780 
                                 ;     781 /***********************************************************************************************************************
                                 ;     782 * Function Name: R_RSPI_Close
                                 ;     783 * Description  : Removes power to the RSPI channel designated by the handle and disables the associated interrupts.
                                 ;     784 * Arguments    : handle-
                                 ;     785 *                    Handle for the channel
                                 ;     786 * Return Value : RSPI_SUCCESS-
                                 ;     787 *                    Successful; channel closed
                                 ;     788 *                RSPI_ERR_CH_NOT_OPEN-
                                 ;     789 *                    The channel has not been opened so closing has no effect.
                                 ;     790 *                RSPI_ERR_BAD_CHAN-
                                 ;     791 *                    Channel number is invalid for part
                                 ;     792 *                RSPI_ERR_NULL_PTR-
                                 ;     793 *                    A required pointer argument is NULL
                                 ;     794 ***********************************************************************************************************************/
                                 ;     795 rspi_err_t  R_RSPI_Close(rspi_handle_t handle)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",795
00000641 7100F0                  		ADD #0FFFFFFF0H, R0
00000644 A089                    		MOV.L R1, 0CH[R0]
                                 ;     796 {
                                 ;     797     uint8_t channel;
                                 ;     798 
                                 ;     799     #if RSPI_CFG_PARAM_CHECKING_ENABLE == 1
                                 ;     800     if (NULL == handle)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",800
00000646 6101                    		CMP #00H, R1
00000648 18                   S  		BNE L177
00000649                         L176:	; bb3
                                 ;     801     {
                                 ;     802         return RSPI_ERR_NULL_PTR;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",802
00000649 F80607                  		MOV.L #00000007H, [R0]
0000064C 2Err                 B  		BRA L185
0000064E                         L177:	; bb8
                                 ;     803     }
                                 ;     804     #endif
                                 ;     805 
                                 ;     806     channel = handle->channel;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",806
0000064E A889                    		MOV.L 0CH[R0], R1
00000650 C41007                  		MOV.B [R1], 07H[R0]
00000653                         L178:	; bb8.split
                                 ;     807 
                                 ;     808     /* Check to see if the channel is currently initialized. */
                                 ;     809     if (false == g_rspi_handles[channel].rspi_chnl_opened)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",809
00000653 B189                    		MOVU.B 07H[R0], R1
00000655 6C31                    		SHLL #03H, R1
00000657 FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
0000065D 4B12                    		ADD R1, R2
0000065F B0A1                    		MOVU.B 02H[R2], R1
00000661 6101                    		CMP #00H, R1
00000663 18                   S  		BNE L180
00000664                         L179:	; bb13
                                 ;     810     {
                                 ;     811         /* This channel is not open so need not be closed. */
                                 ;     812         return RSPI_ERR_CH_NOT_OPENED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",812
00000664 F80602                  		MOV.L #00000002H, [R0]
00000667 2Err                 B  		BRA L185
00000669                         L180:	; bb24
                                 ;     813     }
                                 ;     814 
                                 ;     815     /* Disable the RSPI operation. */
                                 ;     816     /* SPE and SPTIE should be cleared simultaneously. */
                                 ;     817     (*g_rspi_channels[channel]).SPCR.BYTE &= (uint8_t)(~(RSPI_SPCR_SPTIE | RSPI_SPCR_SPE));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",817
00000669 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
0000066F B189                    		MOVU.B 07H[R0], R1
00000671 FE61EE                  		MOV.L [R1,R14], R14
00000674 754F9F                  		MOV.L #0000009FH, R15
00000677 50EF                    		AND [R14].UB, R15
00000679 C3EF                    		MOV.B R15, [R14]
0000067B                         L181:	; bb24.split
                                 ;     818 
                                 ;     819     power_on_off(channel, RSPI_POWER_OFF);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",819
0000067B B189                    		MOVU.B 07H[R0], R1
0000067D 6612                    		MOV.L #00000001H, R2
0000067F 39rrrr               W  		BSR __$power_on_off
00000682                         L182:	; bb24.split1
                                 ;     820 
                                 ;     821     rspi_interrupts_enable(channel, false); /* Disable interrupts. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",821
00000682 B189                    		MOVU.B 07H[R0], R1
00000684 6602                    		MOV.L #00000000H, R2
00000686 39rrrr               W  		BSR __$rspi_interrupts_enable
00000689                         L183:	; bb24.split2
                                 ;     822 
                                 ;     823     g_rspi_handles[channel].rspi_chnl_opened = false;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",823
00000689 B189                    		MOVU.B 07H[R0], R1
0000068B 6C31                    		SHLL #03H, R1
0000068D FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
00000693 4B12                    		ADD R1, R2
00000695 3C2200                  		MOV.B #00H, 02H[R2]
00000698                         L184:	; bb24.split3
                                 ;     824 
                                 ;     825     return RSPI_SUCCESS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",825
00000698 F80600                  		MOV.L #00000000H, [R0]
0000069B                         L185:	; bb42
0000069B EC01                    		MOV.L [R0], R1
0000069D A081                    		MOV.L R1, 08H[R0]
                                 ;     826 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",826
0000069F 6704                    		RTSD #10H
000006A1                         __$rspi_baud_set:
                                 		.STACK	__$rspi_baud_set=44
                                 ;     827 /* end of function R_RSPI_Close(). */
                                 ;     828 
                                 ;     829 
                                 ;     830 /***********************************************************************************************************************
                                 ;     831 * Function Name: rspi_baud_set
                                 ;     832 * Description  : Determines the RSPI channel SPBR register setting for the requested baud rate.
                                 ;     833 *                Returns the actual bit rate that the setting will achieve which may differ from requested.
                                 ;     834 *                If the requested bit rate cannot be exactly achieved, the next lower bit rate setting will be applied.
                                 ;     835 *                If successful, applies the calculated setting to the SPBR register.
                                 ;     836 * Arguments    :
                                 ;     837 * Return Value :
                                 ;     838 * Note: Target baud must be >= PCLK/4 to get anything out.
                                 ;     839 * Limitations   : Does not track dynamically changing PCLK. Relies on constant BSP_PCLKB_HZ
                                 ;     840 ***********************************************************************************************************************/
                                 ;     841 static uint32_t rspi_baud_set(uint8_t channel, uint32_t bps_target)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",841
000006A1 7100D8                  		ADD #0FFFFFFD8H, R0
000006A4 C70127                  		MOV.B R1, 27H[R0]
000006A7 A202                    		MOV.L R2, 20H[R0]
                                 ;     842 {
                                 ;     843     uint8_t     spbr_result = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",843
000006A9 3C0B00                  		MOV.B #00H, 0BH[R0]
000006AC                         L187:	; entry.split
                                 ;     844     uint32_t    bps_calc = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",844
000006AC 3E0300                  		MOV.L #00000000H, 0CH[R0]
000006AF                         L188:	; entry.split1
                                 ;     845     int32_t     f;  //Frequency
                                 ;     846     int32_t     n;  //n term in equation
                                 ;     847     int32_t     N;  //N term in equation
                                 ;     848 
                                 ;     849     /* Starting with RX63x MCUs and later, there are 2 peripheral clocks: PCLKA and PCLKB.
                                 ;     850      * PCLKB matches the functionality of PCLK in RX62x devices as far as the RSPI is concerned. */
                                 ;     851     #if defined(BSP_MCU_RX62_ALL)
                                 ;     852         f = BSP_PCLK_HZ;
                                 ;     853     #else
                                 ;     854         f = BSP_PCLKB_HZ;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",854
000006AF F90204006CDC02          		MOV.L #02DC6C00H, 10H[R0]
000006B6                         L189:	; entry.split2
                                 ;     855     #endif
                                 ;     856 
                                 ;     857     /* Get the register settings for requested baud rate. */
                                 ;     858     if ((f / bps_target) < 2)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",858
000006B6 A901                    		MOV.L 10H[R0], R1
000006B8 06A1090108              		DIVU 20H[R0].L, R1
000006BD 6111                    		CMP #01H, R1
000006BF 24rr                    		BGTU L191
000006C1                         L190:	; bb8
                                 ;     859     {
                                 ;     860         return 0;   /* baud_bps_target too high for the PCLK. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",860
000006C1 3E0100                  		MOV.L #00000000H, 04H[R0]
000006C4 38rrrr               W  		BRA L208
000006C7                         L191:	; bb15
                                 ;     861     }
                                 ;     862     /*
                                 ;     863      * From Hardware manual: Bit rate = f / (2(n + 1)(2^N))
                                 ;     864      * where:
                                 ;     865      *      f = PCLK, n = SPBR setting, N = BRDV bits
                                 ;     866      * Solving for n:
                                 ;     867      *      n = (((f/(2^N))/2) / bps) - 1
                                 ;     868      *
                                 ;     869      */
                                 ;     870 
                                 ;     871     /* Only calculate for BRDV value of 0 (div/1) to get SPBR setting for the board PCLK.
                                 ;     872      * BRDV setting will be done during write/read operations. */
                                 ;     873     N = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",873
000006C7 3E0600                  		MOV.L #00000000H, 18H[R0]
000006CA                         L192:	; bb15.split
                                 ;     874     n = ((f >> (N+1)) / (int32_t)bps_target) - 1;  /* Solve for SPBR setting. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",874
000006CA A981                    		MOV.L 18H[R0], R1
000006CC 6211                    		ADD #01H, R1
000006CE A902                    		MOV.L 10H[R0], R2
000006D0 FD6112                  		SHAR R1, R2
000006D3 06A1080208              		DIV 20H[R0].L, R2
000006D8 6012                    		SUB #01H, R2
000006DA A10A                    		MOV.L R2, 14H[R0]
000006DC                         L193:	; bb15.split3
                                 ;     875 
                                 ;     876     if ((n >= 0) && (n <= 0xff))   /* Must be <= SPBR register max value. Must not be negative*/
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",876
000006DC A909                    		MOV.L 14H[R0], R1
000006DE 6101                    		CMP #00H, R1
000006E0 28rr                    		BGE L203
000006E2 2Err                 B  		BRA L205
000006E4                         L194:	; bb24
                                 ;     877     {
                                 ;     878         /* Now plug n back into the formula for BPS and check it. */
                                 ;     879         bps_calc = (uint32_t)(f / (2 *((n + 1) << N)));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",879
000006E4 A909                    		MOV.L 14H[R0], R1
000006E6 6211                    		ADD #01H, R1
000006E8 A982                    		MOV.L 18H[R0], R2
000006EA FD6221                  		SHLL R2, R1
000006ED 6C11                    		SHLL #01H, R1
000006EF A902                    		MOV.L 10H[R0], R2
000006F1 FC2312                  		DIV R1, R2
000006F4 A08A                    		MOV.L R2, 0CH[R0]
000006F6                         L195:	; bb24.split
                                 ;     880 
                                 ;     881         if(bps_calc > bps_target)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",881
000006F6 A889                    		MOV.L 0CH[R0], R1
000006F8 06850108                		CMP 20H[R0].L, R1
000006FC 25rr                    		BLEU L199
000006FE                         L196:	; bb33
                                 ;     882         {
                                 ;     883             n += 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",883
000006FE A909                    		MOV.L 14H[R0], R1
00000700 6211                    		ADD #01H, R1
00000702 A109                    		MOV.L R1, 14H[R0]
00000704                         L197:	; bb33.split
                                 ;     884             if (n > 0xff)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",884
00000704 A909                    		MOV.L 14H[R0], R1
00000706 76010001                		CMP #0100H, R1
0000070A 29rr                    		BLT L199
0000070C                         L198:	; bb37
                                 ;     885             {
                                 ;     886                 return 0; /* result out of range for the PCLK. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",886
0000070C 3E0100                  		MOV.L #00000000H, 04H[R0]
0000070F 2Err                 B  		BRA L208
00000711                         L199:	; bb49
                                 ;     887             }
                                 ;     888         }
                                 ;     889         spbr_result = n;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",889
00000711 A909                    		MOV.L 14H[R0], R1
00000713 8289                    		MOV.B R1, 0BH[R0]
00000715                         L200:	; bb49.split
                                 ;     890 
                                 ;     891         (*g_rspi_channels[channel]).SPBR = spbr_result;    /* Apply the SPBR register value. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",891
00000715 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
0000071B 590127                  		MOVU.B 27H[R0], R1
0000071E FE61E1                  		MOV.L [R1,R14], R1
00000721 C5010B0A                		MOV.B 0BH[R0], 0AH[R1]
00000725                         L201:	; bb49.split4
                                 ;     892         g_ctrl_reg_values[channel].spbr_val = spbr_result; /* Update the channel settings record. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",892
00000725 590127                  		MOVU.B 27H[R0], R1
00000728 6C41                    		SHLL #04H, R1
0000072A FB22rrrrrrrr            		MOV.L #__$g_ctrl_reg_values, R2
00000730 4B12                    		ADD R1, R2
00000732 C5020B04                		MOV.B 0BH[R0], 04H[R2]
00000736 2Err                 B  		BRA L207
00000738                         L202:	; bb63
                                 ;     893     }
                                 ;     894     else
                                 ;     895     {
                                 ;     896         bps_calc = 0;  /* result out of range for the PCLK. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",896
00000738 3E0300                  		MOV.L #00000000H, 0CH[R0]
0000073B 2Err                 B  		BRA L207
0000073D                         L203:	; bb67
0000073D A909                    		MOV.L 14H[R0], R1
0000073F 7551FF                  		CMP #0FFH, R1
00000742 2Arr                    		BGT L205
00000744                         L204:	; bb71
00000744 F80601                  		MOV.L #00000001H, [R0]
00000747 08                   S  		BRA L206
00000748                         L205:	; bb72
00000748 F80600                  		MOV.L #00000000H, [R0]
0000074B                         L206:	; bb73
0000074B EC01                    		MOV.L [R0], R1
0000074D 6101                    		CMP #00H, R1
0000074F 21rr                    		BNE L194
00000751 2Err                 B  		BRA L202
00000753                         L207:	; bb78
                                 ;     897     }
                                 ;     898 
                                 ;     899     return bps_calc;    /* Return the actual BPS rate achieved. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",899
00000753 E5000301                		MOV.L 0CH[R0], 04H[R0]
00000757                         L208:	; bb81
00000757 A809                    		MOV.L 04H[R0], R1
00000759 A189                    		MOV.L R1, 1CH[R0]
                                 ;     900 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",900
0000075B 670A                    		RTSD #28H
0000075D                         _rspi_get_data_type:
                                 		.STACK	_rspi_get_data_type=12
                                 ;     901 /* end of function rspi_baud_set(). */
                                 ;     902 
                                 ;     903 /***********************************************************************************************************************
                                 ;     904 * Function Name: rspi_get_data_type
                                 ;     905 * Description  : Identifies whether the data must be type-cast as 8-bit, 16-bit, or 32-bit for purposes of accessing the
                                 ;     906 *                source or destination buffers with the right type and index.
                                 ;     907 * Arguments    : frame_length_bits-
                                 ;     908 *                   16-bit word containing the bits that define the bits per frame in th SPCMD register.
                                 ;     909 *                   Only the bits corresponding to "SPB[3:0] RSPI Data Length Setting" of the SPCMDn register are
                                 ;     910 *                   checked in this argument.
                                 ;     911 * Return Value : RSPI_BYTE_DATA-
                                 ;     912 *                   Data is 8-bit.
                                 ;     913 *                RSPI_WORD_DATA-
                                 ;     914 *                   Data is > 8-bit and <= 16-bit.
                                 ;     915 *                RSPI_LONG_DATA-
                                 ;     916 *                   Data is > 16-bit.
                                 ;     917 ***********************************************************************************************************************/
                                 ;     918 uint8_t rspi_get_data_type(rspi_command_word_t command_word)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",918
0000075D 6080                    		SUB #08H, R0
0000075F A009                    		MOV.L R1, 04H[R0]
                                 ;     919 {
                                 ;     920     uint8_t data_type;
                                 ;     921     uint8_t frame_length_bits;
                                 ;     922 
                                 ;     923     frame_length_bits = (uint8_t)((command_word.word & RSPI_SPCMD_SPB) >> 8);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",923
00000761 B881                    		MOVU.W 04H[R0], R1
00000763 7621000F                		AND #0F00H, R1
00000767 6881                    		SHLR #08H, R1
00000769 8081                    		MOV.B R1, 02H[R0]
0000076B                         L210:	; entry.split
                                 ;     924 
                                 ;     925     switch (frame_length_bits)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",925
0000076B B081                    		MOVU.B 02H[R0], R1
0000076D 6141                    		CMP #04H, R1
0000076F 23rr                    		BLTU L215
00000771                         L211:	; entry.split
00000771 711EF8                  		ADD #0FFFFFFF8H, R1, R14
00000774 618E                    		CMP #08H, R14
00000776 23rr                    		BLTU L214
00000778                         L212:	; entry.split
00000778 6171                    		CMP #07H, R1
0000077A 21rr                    		BNE L216
0000077C                         L213:	; bb
                                 ;     926     {
                                 ;     927         case RSPI_SPCMD_BIT_LENGTH_8: /* (0x07) 0100 to 0111 = 8 bits data length */
                                 ;     928         {
                                 ;     929             data_type = RSPI_BYTE_DATA;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",929
0000077C 3C0101                  		MOV.B #01H, 01H[R0]
0000077F 2Err                 B  		BRA L217
00000781                         L214:	; bb14
                                 ;     930         }
                                 ;     931         break;
                                 ;     932 
                                 ;     933         case RSPI_SPCMD_BIT_LENGTH_9:   /* (0x08)  1000 = 9 bits data length  */
                                 ;     934         case RSPI_SPCMD_BIT_LENGTH_10:  /* (0x09)  1001 = 10 bits data length */
                                 ;     935         case RSPI_SPCMD_BIT_LENGTH_11:  /* (0x0A)  1010 = 11 bits data length */
                                 ;     936         case RSPI_SPCMD_BIT_LENGTH_12:  /* (0x0B)  1011 = 12 bits data length */
                                 ;     937         case RSPI_SPCMD_BIT_LENGTH_13:  /* (0x0C)  1100 = 13 bits data length */
                                 ;     938         case RSPI_SPCMD_BIT_LENGTH_14:  /* (0x0D)  1101 = 14 bits data length */
                                 ;     939         case RSPI_SPCMD_BIT_LENGTH_15:  /* (0x0E)  1110 = 15 bits data length */
                                 ;     940         case RSPI_SPCMD_BIT_LENGTH_16:  /* (0x0F)  1111 = 16 bits data length */
                                 ;     941         {
                                 ;     942             data_type = RSPI_WORD_DATA;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",942
00000781 3C0102                  		MOV.B #02H, 01H[R0]
00000784 08                   S  		BRA L217
00000785                         L215:	; bb15
                                 ;     943         }
                                 ;     944         break;
                                 ;     945 
                                 ;     946         case RSPI_SPCMD_BIT_LENGTH_20:  /* (0x00)  0000 = 20 bits data length */
                                 ;     947         case RSPI_SPCMD_BIT_LENGTH_24:  /* (0x01)  0001 = 24 bits data length */
                                 ;     948         case RSPI_SPCMD_BIT_LENGTH_32:  /* (0x03)  0011 = 32 bits data length */
                                 ;     949         case 0x0002:            /* Alternate setting for 32 bit. */
                                 ;     950         {
                                 ;     951             data_type = RSPI_LONG_DATA;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",951
00000785 3C0104                  		MOV.B #04H, 01H[R0]
00000788 08                   S  		BRA L217
00000789                         L216:	; bb16
                                 ;     952         }
                                 ;     953         break;
                                 ;     954 
                                 ;     955         default:
                                 ;     956         {
                                 ;     957             data_type = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",957
00000789 3C0100                  		MOV.B #00H, 01H[R0]
0000078C                         L217:	; bb17
                                 ;     958         }
                                 ;     959     }
                                 ;     960     return data_type;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",960
0000078C C5000103                		MOV.B 01H[R0], 03H[R0]
00000790 B089                    		MOVU.B 03H[R0], R1
00000792                         L218:	; bb17.split
                                 ;     961 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",961
00000792 5B11                    		MOVU.B R1, R1
00000794 6702                    		RTSD #08H
00000796                         __$power_on_off:
                                 		.STACK	__$power_on_off=8
                                 ;     962 /* End of function rspi_get_data_access(). */
                                 ;     963 
                                 ;     964 
                                 ;     965 /***********************************************************************************************************************
                                 ;     966 * Function Name: power_on_off
                                 ;     967 * Description : Switches power to an RSPI channel.  Required by FIT spec.
                                 ;     968 * Arguments : channel -
                                 ;     969 *                   Which channel to use.
                                 ;     970 *             on_or_off -
                                 ;     971 *                   What it says.
                                 ;     972 * Return Value : none
                                 ;     973 ***********************************************************************************************************************/
                                 ;     974 static void power_on_off (uint8_t channel, uint8_t on_or_off)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",974
00000796 6040                    		SUB #04H, R0
00000798 8089                    		MOV.B R1, 03H[R0]
0000079A 8082                    		MOV.B R2, 02H[R0]
0000079C 6611                    		MOV.L #00000001H, R1
                                 ;     975 {
                                 ;     976     R_BSP_RegisterProtectDisable(BSP_REG_PROTECT_LPC_CGC_SWR);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",976
0000079E 05rrrrrr             A  		BSR _R_BSP_RegisterProtectDisable
000007A2                         L220:	; entry.split
                                 ;     977 
                                 ;     978     switch (channel)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",978
000007A2 B089                    		MOVU.B 03H[R0], R1
000007A4 6111                    		CMP #01H, R1
000007A6 20rr                    		BEQ L223
000007A8                         L221:	; entry.split
000007A8 6101                    		CMP #00H, R1
000007AA 21rr                    		BNE L224
000007AC                         L222:	; bb
000007AC FBEE140008              		MOV.L #00080014H, R14
                                 ;     979     {
                                 ;     980         #if RSPI_CFG_USE_CH0 == 1
                                 ;     981         case 0:
                                 ;     982             MSTP(RSPI0) = on_or_off;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",982
000007B1 B081                    		MOVU.B 02H[R0], R1
000007B3 ECEF                    		MOV.L [R14], R15
000007B5 7B1F                    		BCLR #11H, R15
000007B7 6D11                    		SHLL #11H, R1
000007B9 7721000002              		AND #00020000H, R1
000007BE 571F                    		OR R1, R15
000007C0 E3EF                    		MOV.L R15, [R14]
000007C2 2Err                 B  		BRA L224
000007C4                         L223:	; bb11
000007C4 FBEE140008              		MOV.L #00080014H, R14
                                 ;     983         break;
                                 ;     984         #endif
                                 ;     985 
                                 ;     986         #if RSPI_CFG_USE_CH1 == 1
                                 ;     987         case 1:
                                 ;     988             MSTP(RSPI1) = on_or_off;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",988
000007C9 B081                    		MOVU.B 02H[R0], R1
000007CB ECEF                    		MOV.L [R14], R15
000007CD 7B0F                    		BCLR #10H, R15
000007CF 6D01                    		SHLL #10H, R1
000007D1 7721000001              		AND #00010000H, R1
000007D6 571F                    		OR R1, R15
000007D8 E3EF                    		MOV.L R15, [R14]
000007DA                         L224:	; bb20
000007DA 6611                    		MOV.L #00000001H, R1
                                 ;     989         break;
                                 ;     990         #endif
                                 ;     991 
                                 ;     992         #if RSPI_CFG_USE_CH2 == 1
                                 ;     993         case 2:
                                 ;     994             MSTP(RSPI2) = on_or_off;
                                 ;     995         break;
                                 ;     996         #endif
                                 ;     997 
                                 ;     998         default:
                                 ;     999         break;
                                 ;    1000     }
                                 ;    1001 
                                 ;    1002     R_BSP_RegisterProtectEnable(BSP_REG_PROTECT_LPC_CGC_SWR);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1002
000007DC 05rrrrrr             A  		BSR _R_BSP_RegisterProtectEnable
000007E0 6701                    		RTSD #04H
000007E2                         __$rspi_ir_priority_set:
                                 		.STACK	__$rspi_ir_priority_set=8
                                 ;    1003 }
                                 ;    1004 /* End of function power_on(). */
                                 ;    1005 
                                 ;    1006 
                                 ;    1007 /***********************************************************************************************************************
                                 ;    1008 * Function Name: rspi_ir_priority_set
                                 ;    1009 * Description  : sets the shared interrupt priority level for a channel.
                                 ;    1010 * Arguments : channel -
                                 ;    1011 *                 Which channel to use.
                                 ;    1012 *             rspi_priority-
                                 ;    1013 *                 0-15 priority value. 15 = highest priority.
                                 ;    1014 * Return Value : none
                                 ;    1015 ***********************************************************************************************************************/
                                 ;    1016 static void rspi_ir_priority_set(uint8_t channel, uint8_t rspi_priority)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1016
000007E2 6040                    		SUB #04H, R0
000007E4 8089                    		MOV.B R1, 03H[R0]
000007E6 8082                    		MOV.B R2, 02H[R0]
                                 ;    1017 {
                                 ;    1018     switch (channel)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1018
000007E8 B089                    		MOVU.B 03H[R0], R1
000007EA 6111                    		CMP #01H, R1
000007EC 20rr                    		BEQ L228
000007EE                         L226:	; entry
000007EE 6101                    		CMP #00H, R1
000007F0 21rr                    		BNE L229
000007F2                         L227:	; bb
                                 ;    1019     {
                                 ;    1020         #if RSPI_CFG_USE_CH0 == 1
                                 ;    1021         case 0:
                                 ;    1022             /* Set shared IPL for RSPI0 */
                                 ;    1023             IPR(RSPI0, SPRI0) = rspi_priority;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1023
000007F2 FBEE277308              		MOV.L #00087327H, R14
000007F7 B081                    		MOVU.B 02H[R0], R1
000007F9 754FF0                  		MOV.L #000000F0H, R15
000007FC 50EF                    		AND [R14].UB, R15
000007FE 64F1                    		AND #0FH, R1
00000800 571F                    		OR R1, R15
00000802 C3EF                    		MOV.B R15, [R14]
00000804 6701                    		RTSD #04H
00000806                         L228:	; bb9
                                 ;    1024         break;
                                 ;    1025         #endif
                                 ;    1026 
                                 ;    1027         #if RSPI_CFG_USE_CH1 == 1
                                 ;    1028         case 1:
                                 ;    1029             /* Set shared IPL for RSPI1 */
                                 ;    1030             IPR(RSPI1, SPRI1) = rspi_priority;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1030
00000806 FB1E277308              		MOV.L #00087327H, R1
0000080B B082                    		MOVU.B 02H[R0], R2
0000080D 7543F0                  		MOV.L #000000F0H, R3
00000810 511303                  		AND 03H[R1].UB, R3
00000813 64F2                    		AND #0FH, R2
00000815 5723                    		OR R2, R3
00000817 809B                    		MOV.B R3, 03H[R1]
00000819 6701                    		RTSD #04H
0000081B                         L229:	; return
                                 ;    1031         break;
                                 ;    1032         #endif
                                 ;    1033 
                                 ;    1034         #if RSPI_CFG_USE_CH2 == 1
                                 ;    1035         case 2:
                                 ;    1036             /* Set shared IPL for RSPI2 */
                                 ;    1037             IPR(RSPI2, SPRI2) = rspi_priority;
                                 ;    1038         break;
                                 ;    1039         #endif
                                 ;    1040 
                                 ;    1041         default:
                                 ;    1042         break;
                                 ;    1043     }
                                 ;    1044 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1044
0000081B 6701                    		RTSD #04H
0000081D                         __$rspi_interrupts_clear:
                                 		.STACK	__$rspi_interrupts_clear=8
                                 ;    1045 /* End of function rspi_ir_priority_set(). */
                                 ;    1046 
                                 ;    1047 /***********************************************************************************************************************
                                 ;    1048 * Function Name: rspi_interrupts_clear
                                 ;    1049 * Description  : Clear RSPI interrupts.
                                 ;    1050 * Arguments : channel -
                                 ;    1051 *                 Which channel to use.
                                 ;    1052 * Return Value : none
                                 ;    1053 ***********************************************************************************************************************/
                                 ;    1054 static void rspi_interrupts_clear(uint8_t channel)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1054
0000081D 6040                    		SUB #04H, R0
0000081F 8089                    		MOV.B R1, 03H[R0]
                                 ;    1055 {
                                 ;    1056     switch (channel)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1056
00000821 B089                    		MOVU.B 03H[R0], R1
00000823 6111                    		CMP #01H, R1
00000825 20rr                    		BEQ L234
00000827                         L231:	; entry
00000827 6101                    		CMP #00H, R1
00000829 21rr                    		BNE L236
0000082B                         L232:	; bb
                                 ;    1057     {
                                 ;    1058         #if RSPI_CFG_USE_CH0 == 1
                                 ;    1059         case 0:
                                 ;    1060 
                                 ;    1061             /* Clear any pending receive buffer full interrupts */
                                 ;    1062             IR(RSPI0, SPRI0) = 0 ;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1062
0000082B FBEE277008              		MOV.L #00087027H, R14
00000830 F0E8                    		BCLR #00H, [R14].B
00000832                         L233:	; bb.split
                                 ;    1063             /* Clear any pending transmit buffer empty interrupts */
                                 ;    1064             IR(RSPI0, SPTI0) = 0 ;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1064
00000832 FBEE277008              		MOV.L #00087027H, R14
00000837 F1E801                  		BCLR #00H, 01H[R14].B
0000083A 6701                    		RTSD #04H
0000083C                         L234:	; bb9
                                 ;    1065             #ifndef BSP_MCU_RX63_ALL
                                 ;    1066             /* Clear any pending error interrupt */
                                 ;    1067             IR(RSPI0, SPEI0) = 0;
                                 ;    1068             #endif
                                 ;    1069         break;
                                 ;    1070         #endif
                                 ;    1071 
                                 ;    1072         #if RSPI_CFG_USE_CH1 == 1
                                 ;    1073         case 1:
                                 ;    1074             IR(RSPI1, SPRI1) = 0 ;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1074
0000083C FBEE277008              		MOV.L #00087027H, R14
00000841 F1E803                  		BCLR #00H, 03H[R14].B
00000844                         L235:	; bb9.split
                                 ;    1075             IR(RSPI1, SPTI1) = 0 ;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1075
00000844 FBEE277008              		MOV.L #00087027H, R14
00000849 F1E804                  		BCLR #00H, 04H[R14].B
0000084C 6701                    		RTSD #04H
0000084E                         L236:	; return
                                 ;    1076             #ifndef BSP_MCU_RX63_ALL
                                 ;    1077             IR(RSPI1, SPEI1) = 0;
                                 ;    1078             #endif
                                 ;    1079         break;
                                 ;    1080 
                                 ;    1081         #endif
                                 ;    1082 
                                 ;    1083         #if RSPI_CFG_USE_CH2 == 1
                                 ;    1084         case 2:
                                 ;    1085             IR(RSPI2, SPRI2) = 0 ;
                                 ;    1086             IR(RSPI2, SPTI2) = 0 ;
                                 ;    1087             #ifndef BSP_MCU_RX63_ALL
                                 ;    1088             IR(RSPI2, SPEI2) = 0;
                                 ;    1089             #endif
                                 ;    1090         break;
                                 ;    1091         #endif
                                 ;    1092 
                                 ;    1093         default:
                                 ;    1094         break;
                                 ;    1095     }
                                 ;    1096     #ifdef BSP_MCU_RX63_ALL
                                 ;    1097         #if RSPI_CFG_USE_RX63_ERROR_INTERRUPT == 1
                                 ;    1098         IR(ICU, GROUP12) = 0;
                                 ;    1099         #endif
                                 ;    1100     #endif
                                 ;    1101 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1101
0000084E 6701                    		RTSD #04H
00000850                         __$rspi_interrupts_enable:
                                 		.STACK	__$rspi_interrupts_enable=8
                                 ;    1102 /* End of function rspi_interrupts_enable(). */
                                 ;    1103 
                                 ;    1104 /***********************************************************************************************************************
                                 ;    1105 * Function Name: rspi_interrupts_enable
                                 ;    1106 * Description  : Disable or enable RSPI interrupts.
                                 ;    1107 * Arguments : channel -
                                 ;    1108 *                 Which channel to use.
                                 ;    1109 *             enabled-
                                 ;    1110 *                 true = enable, false = disable.
                                 ;    1111 * Return Value : none
                                 ;    1112 ***********************************************************************************************************************/
                                 ;    1113 static void rspi_interrupts_enable(uint8_t channel, bool enabled)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1113
00000850 6040                    		SUB #04H, R0
00000852 8089                    		MOV.B R1, 03H[R0]
00000854 8082                    		MOV.B R2, 02H[R0]
                                 ;    1114 {
                                 ;    1115     switch (channel)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1115
00000856 B089                    		MOVU.B 03H[R0], R1
00000858 6111                    		CMP #01H, R1
0000085A 20rr                    		BEQ L241
0000085C                         L238:	; entry
0000085C 6101                    		CMP #00H, R1
0000085E 21rr                    		BNE L243
00000860                         L239:	; bb
                                 ;    1116     {
                                 ;    1117         #if RSPI_CFG_USE_CH0 == 1
                                 ;    1118         case 0:
                                 ;    1119             /* Disable or enable receive buffer full interrupt */
                                 ;    1120             IEN(RSPI0, SPRI0) = enabled;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1120
00000860 B081                    		MOVU.B 02H[R0], R1
00000862 6C71                    		SHLL #07H, R1
00000864 FBEE047208              		MOV.L #00087204H, R14
00000869 58EF                    		MOVU.B [R14], R15
0000086B 752F7F                  		AND #7FH, R15
0000086E 571F                    		OR R1, R15
00000870 C3EF                    		MOV.B R15, [R14]
00000872                         L240:	; bb.split
00000872 FBEE057208              		MOV.L #00087205H, R14
                                 ;    1121             /* Disable  or enable transmit buffer empty interrupt */
                                 ;    1122             IEN(RSPI0, SPTI0) = enabled;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1122
00000877 B081                    		MOVU.B 02H[R0], R1
00000879 754FFE                  		MOV.L #000000FEH, R15
0000087C 50EF                    		AND [R14].UB, R15
0000087E 6411                    		AND #01H, R1
00000880 571F                    		OR R1, R15
00000882 C3EF                    		MOV.B R15, [R14]
00000884 6701                    		RTSD #04H
00000886                         L241:	; bb15
00000886 FBEE057208              		MOV.L #00087205H, R14
                                 ;    1123             #ifndef BSP_MCU_RX63_ALL
                                 ;    1124             /* Disable or enable error interrupt */
                                 ;    1125             IEN(RSPI0, SPEI0) = enabled;
                                 ;    1126             #endif
                                 ;    1127         break;
                                 ;    1128         #endif
                                 ;    1129 
                                 ;    1130         #if RSPI_CFG_USE_CH1 == 1
                                 ;    1131         case 1:
                                 ;    1132             IEN(RSPI1, SPRI1) = enabled;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1132
0000088B B081                    		MOVU.B 02H[R0], R1
0000088D 754FFB                  		MOV.L #000000FBH, R15
00000890 50EF                    		AND [R14].UB, R15
00000892 6C21                    		SHLL #02H, R1
00000894 6441                    		AND #04H, R1
00000896 571F                    		OR R1, R15
00000898 C3EF                    		MOV.B R15, [R14]
0000089A                         L242:	; bb15.split
0000089A FBEE057208              		MOV.L #00087205H, R14
                                 ;    1133             IEN(RSPI1, SPTI1) = enabled;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1133
0000089F B081                    		MOVU.B 02H[R0], R1
000008A1 754FF7                  		MOV.L #000000F7H, R15
000008A4 50EF                    		AND [R14].UB, R15
000008A6 6C31                    		SHLL #03H, R1
000008A8 6481                    		AND #08H, R1
000008AA 571F                    		OR R1, R15
000008AC C3EF                    		MOV.B R15, [R14]
000008AE 6701                    		RTSD #04H
000008B0                         L243:	; return
                                 ;    1134             #ifndef BSP_MCU_RX63_ALL
                                 ;    1135             IEN(RSPI0, SPEI0) = enabled;
                                 ;    1136             #endif
                                 ;    1137         break;
                                 ;    1138         #endif
                                 ;    1139 
                                 ;    1140         #if RSPI_CFG_USE_CH2 == 1
                                 ;    1141         case 2:
                                 ;    1142             IEN(RSPI2, SPRI2) = enabled;
                                 ;    1143             IEN(RSPI2, SPTI2) = enabled;
                                 ;    1144             #ifndef BSP_MCU_RX63_ALL
                                 ;    1145             IEN(RSPI0, SPEI0) = enabled;
                                 ;    1146             #endif
                                 ;    1147         break;
                                 ;    1148         #endif
                                 ;    1149 
                                 ;    1150         default:
                                 ;    1151         break;
                                 ;    1152     }
                                 ;    1153 
                                 ;    1154     #ifdef BSP_MCU_RX63_ALL
                                 ;    1155         #if RSPI_CFG_USE_RX63_ERROR_INTERRUPT == 1
                                 ;    1156         IEN(ICU, GROUP12) = enabled;
                                 ;    1157         #endif
                                 ;    1158     #endif
                                 ;    1159 
                                 ;    1160 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1160
000008B0 6701                    		RTSD #04H
000008B2                         _R_RSPI_GetVersion:
                                 		.STACK	_R_RSPI_GetVersion=12
                                 ;    1161 /* End of function rspi_interrupts_enable(). */
                                 ;    1162 
                                 ;    1163 
                                 ;    1164 /***********************************************************************************************************************
                                 ;    1165 * Function Name: R_RSPI_GetVersion
                                 ;    1166 * Description : Returns the version of this module. The version number is
                                 ;    1167 * encoded where the top 2 bytes are the major version number and
                                 ;    1168 * the bottom 2 bytes are the minor version number.
                                 ;    1169 * For example, Rev 4.25 would be 0x00040019.
                                 ;    1170 * NOTE: This function is inlined using #pragma inline directive.
                                 ;    1171 * Arguments : none
                                 ;    1172 * Return Value : Version Number
                                 ;    1173 ***********************************************************************************************************************/
                                 ;    1174 #pragma inline(R_RSPI_GetVersion)
                                 ;    1175 uint32_t R_RSPI_GetVersion(void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1175
000008B2 6080                    		SUB #08H, R0
                                 ;    1176 {
                                 ;    1177     uint32_t version_number = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1177
000008B4 F80600                  		MOV.L #00000000H, [R0]
000008B7                         L245:	; entry.split
                                 ;    1178     /* Bring in major version number. */
                                 ;    1179     version_number = ((uint16_t)RSPI_RX_VERSION_MAJOR) << 16;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1179
000008B7 F80E000001              		MOV.L #00010000H, [R0]
000008BC                         L246:	; entry.split1
                                 ;    1180     /* Bring in minor version number. */
                                 ;    1181     version_number |= (uint16_t)RSPI_RX_VERSION_MINOR;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1181
000008BC EC01                    		MOV.L [R0], R1
000008BE 753114                  		OR #14H, R1
000008C1 E301                    		MOV.L R1, [R0]
000008C3                         L247:	; entry.split2
                                 ;    1182     return version_number;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1182
000008C3 EC01                    		MOV.L [R0], R1
000008C5 A009                    		MOV.L R1, 04H[R0]
000008C7                         L248:	; entry.split3
                                 ;    1183 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1183
000008C7 6702                    		RTSD #08H
000008C9                         __$rspi_tx_rx_common:
                                 		.STACK	__$rspi_tx_rx_common=32
                                 ;    1184 
                                 ;    1185 
                                 ;    1186 /******************************************************************************
                                 ;    1187 * Function Name:    rspi_tx_rx_common
                                 ;    1188 * Description  :    common ISR handler for SPTI and SPRI
                                 ;    1189 * Arguments    :    RSPI channel
                                 ;    1190 * Return Value :    N/A
                                 ;    1191 ******************************************************************************/
                                 ;    1192 static void rspi_tx_rx_common(uint8_t channel)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1192
000008C9 7100E4                  		ADD #0FFFFFFE4H, R0
000008CC 8689                    		MOV.B R1, 1BH[R0]
                                 ;    1193 {
                                 ;    1194     void*       psrc      = g_rspi_tcb[channel].psrc;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1194
000008CE B689                    		MOVU.B 1BH[R0], R1
000008D0 751118                  		MUL #18H, R1
000008D3 FBE2rrrrrrrr            		MOV.L #__$g_rspi_tcb, R14
000008D9 4B1E                    		ADD R1, R14
000008DB E4E001                  		MOV.L [R14], 04H[R0]
000008DE                         L250:	; entry.split
                                 ;    1195     void*       pdest     = g_rspi_tcb[channel].pdest;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1195
000008DE B689                    		MOVU.B 1BH[R0], R1
000008E0 751118                  		MUL #18H, R1
000008E3 FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
000008E9 4B12                    		ADD R1, R2
000008EB E5200102                		MOV.L 04H[R2], 08H[R0]
000008EF                         L251:	; entry.split1
                                 ;    1196     uint16_t    tx_count  = g_rspi_tcb[channel].tx_count;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1196
000008EF B689                    		MOVU.B 1BH[R0], R1
000008F1 751118                  		MUL #18H, R1
000008F4 FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
000008FA 4B12                    		ADD R1, R2
000008FC D5200407                		MOV.W 08H[R2], 0EH[R0]
00000900                         L252:	; entry.split2
                                 ;    1197     uint16_t    rx_count  = g_rspi_tcb[channel].rx_count;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1197
00000900 B689                    		MOVU.B 1BH[R0], R1
00000902 751118                  		MUL #18H, R1
00000905 FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
0000090B 4B12                    		ADD R1, R2
0000090D D5200508                		MOV.W 0AH[R2], 10H[R0]
00000911                         L253:	; entry.split3
                                 ;    1198     uint8_t     data_size = g_rspi_tcb[channel].bytes_per_transfer;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1198
00000911 B689                    		MOVU.B 1BH[R0], R1
00000913 751118                  		MUL #18H, R1
00000916 FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
0000091C 4B12                    		ADD R1, R2
0000091E C5200E13                		MOV.B 0EH[R2], 13H[R0]
00000922                         L254:	; entry.split4
                                 ;    1199     uint32_t    rx_data   = g_rxdata[channel];
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1199
00000922 B689                    		MOVU.B 1BH[R0], R1
00000924 6C21                    		SHLL #02H, R1
00000926 FBE2rrrrrrrr            		MOV.L #__$g_rxdata, R14
0000092C 4B1E                    		ADD R1, R14
0000092E E4E005                  		MOV.L [R14], 14H[R0]
00000931                         L255:	; entry.split5
                                 ;    1200 
                                 ;    1201     /* Service the hardware first to keep it busy. */
                                 ;    1202     /* Feed the TX. */
                                 ;    1203     if(tx_count < g_rspi_tcb[channel].xfr_length)   /* Don't write transmit buffer more than length. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1203
00000931 B689                    		MOVU.B 1BH[R0], R1
00000933 751118                  		MUL #18H, R1
00000936 FBE2rrrrrrrr            		MOV.L #__$g_rspi_tcb, R14
0000093C 4B1E                    		ADD R1, R14
0000093E B989                    		MOVU.W 0EH[R0], R1
00000940 06C5E106                		CMP 0CH[R14].UW, R1
00000944 28rr                    		BGE L264
00000946                         L256:	; bb37
                                 ;    1204     {
                                 ;    1205         if (g_rspi_tcb[channel].do_tx)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1205
00000946 B689                    		MOVU.B 1BH[R0], R1
00000948 751118                  		MUL #18H, R1
0000094B FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
00000951 4B12                    		ADD R1, R2
00000953 B421                    		MOVU.B 10H[R2], R1
00000955 6101                    		CMP #00H, R1
00000957 20rr                    		BEQ L262
00000959                         L257:	; bb39
                                 ;    1206         {
                                 ;    1207             /* Transmit the data. TX data register accessed in long words. */
                                 ;    1208             if (RSPI_BYTE_DATA == data_size)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1208
00000959 B489                    		MOVU.B 13H[R0], R1
0000095B 6111                    		CMP #01H, R1
0000095D 21rr                    		BNE L259
0000095F                         L258:	; bb40
                                 ;    1209             {
                                 ;    1210                 (*g_rspi_channels[channel]).SPDR.LONG = ((uint8_t *)psrc)[tx_count];
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1210
0000095F B989                    		MOVU.W 0EH[R0], R1
00000961 A80A                    		MOV.L 04H[R0], R2
00000963 FEC211                  		MOVU.B [R2,R1], R1
00000966 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
0000096C B68A                    		MOVU.B 1BH[R0], R2
0000096E FE62E2                  		MOV.L [R2,R14], R2
00000971 A029                    		MOV.L R1, 04H[R2]
00000973 2Err                 B  		BRA L263
00000975                         L259:	; bb54
                                 ;    1211             }
                                 ;    1212             else if(RSPI_WORD_DATA == data_size)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1212
00000975 FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
0000097B B689                    		MOVU.B 1BH[R0], R1
0000097D FE61EE                  		MOV.L [R1,R14], R14
00000980 624E                    		ADD #04H, R14
00000982 B489                    		MOVU.B 13H[R0], R1
00000984 6121                    		CMP #02H, R1
00000986 A809                    		MOV.L 04H[R0], R1
00000988 18                   S  		BNE L261
00000989                         L260:	; bb55
                                 ;    1213             {
                                 ;    1214                 (*g_rspi_channels[channel]).SPDR.LONG = ((uint16_t *)psrc)[tx_count];
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1214
00000989 B98A                    		MOVU.W 0EH[R0], R2
0000098B FED21F                  		MOVU.W [R2,R1], R15
0000098E E3EF                    		MOV.L R15, [R14]
00000990 2Err                 B  		BRA L263
00000992                         L261:	; bb69
                                 ;    1215             }
                                 ;    1216             else // Must be long data. if(RSPI_LONG_DATA == data_size)
                                 ;    1217             {
                                 ;    1218                 (*g_rspi_channels[channel]).SPDR.LONG = ((uint32_t *)psrc)[tx_count];
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1218
00000992 B98A                    		MOVU.W 0EH[R0], R2
00000994 FE621F                  		MOV.L [R2,R1], R15
00000997 E3EF                    		MOV.L R15, [R14]
00000999 2Err                 B  		BRA L263
0000099B                         L262:	; bb93
                                 ;    1219             }
                                 ;    1220         }
                                 ;    1221         else /* Must be RX only mode, so transmit dummy data for clocking.*/
                                 ;    1222         {
                                 ;    1223             /* TX data register accessed in long words. */
                                 ;    1224             (*g_rspi_channels[channel]).SPDR.LONG = RSPI_DUMMY_TXDATA;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1224
0000099B FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
000009A1 B689                    		MOVU.B 1BH[R0], R1
000009A3 FE61EE                  		MOV.L [R1,R14], R14
000009A6 F9E601FF                		MOV.L #0FFFFFFFFH, 04H[R14]
000009AA                         L263:	; bb109
                                 ;    1225         }
                                 ;    1226         g_rspi_tcb[channel].tx_count++;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1226
000009AA B689                    		MOVU.B 1BH[R0], R1
000009AC 751118                  		MUL #18H, R1
000009AF FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
000009B5 4B12                    		ADD R1, R2
000009B7 9921                    		MOV.W 08H[R2], R1
000009B9 6211                    		ADD #01H, R1
000009BB 9121                    		MOV.W R1, 08H[R2]
000009BD                         L264:	; bb128
                                 ;    1227     }
                                 ;    1228 
                                 ;    1229     /* Store the received data in user buffer.
                                 ;    1230      * Receive data not valid until after first transmission is complete. */
                                 ;    1231     if (g_rspi_tcb[channel].do_rx_now)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1231
000009BD B689                    		MOVU.B 1BH[R0], R1
000009BF 751118                  		MUL #18H, R1
000009C2 FB22rrrrrrrr            		MOV.L #__$g_rspi_tcb, R2
000009C8 4B12                    		ADD R1, R2
000009CA B3A9                    		MOVU.B 0FH[R2], R1
000009CC 6101                    		CMP #00H, R1
000009CE 20rr                    		BEQ L270
000009D0                         L265:	; bb130
                                 ;    1232     {
                                 ;    1233         if (RSPI_BYTE_DATA == data_size)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1233
000009D0 B489                    		MOVU.B 13H[R0], R1
000009D2 6111                    		CMP #01H, R1
000009D4 21rr                    		BNE L267
000009D6                         L266:	; bb131
                                 ;    1234         {
                                 ;    1235             ((uint8_t *)pdest)[rx_count-1] = (uint8_t)rx_data;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1235
000009D6 BA01                    		MOVU.W 10H[R0], R1
000009D8 06890102                		ADD 08H[R0].L, R1
000009DC FBE6FF                  		MOV.L #0FFFFFFFFH, R14
000009DF A90A                    		MOV.L 14H[R0], R2
000009E1 FE01E2                  		MOV.B R2, [R1,R14]
000009E4 2Err                 B  		BRA L270
000009E6                         L267:	; bb140
                                 ;    1236         }
                                 ;    1237         else if(RSPI_WORD_DATA == data_size)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1237
000009E6 B489                    		MOVU.B 13H[R0], R1
000009E8 6121                    		CMP #02H, R1
000009EA A881                    		MOV.L 08H[R0], R1
000009EC 21rr                    		BNE L269
000009EE                         L268:	; bb141
                                 ;    1238         {
                                 ;    1239             #if RSPI_CFG_MASK_UNUSED_BITS == (1)
                                 ;    1240             /* Clear unused upper bits of non-standard bit length data transfers. */
                                 ;    1241             (uint16_t)rx_data = (uint16_t)(rx_data & g_rspi_tcb[channel].unused_bits_mask); /* cast as uint16_t to handle endian. */
                                 ;    1242             #endif
                                 ;    1243             ((uint16_t *)pdest)[rx_count-1] = (uint16_t)rx_data;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1243
000009EE BA02                    		MOVU.W 10H[R0], R2
000009F0 6C12                    		SHLL #01H, R2
000009F2 4B12                    		ADD R1, R2
000009F4 6022                    		SUB #02H, R2
000009F6 A909                    		MOV.L 14H[R0], R1
000009F8 D321                    		MOV.W R1, [R2]
000009FA 2Err                 B  		BRA L270
000009FC                         L269:	; bb150
                                 ;    1244         }
                                 ;    1245         else  // Must be long data. if(RSPI_LONG_DATA == data_size)
                                 ;    1246         {
                                 ;    1247             #if RSPI_CFG_MASK_UNUSED_BITS == (1)
                                 ;    1248             /* Clear unused upper bits of non-standard bit length data transfers. */
                                 ;    1249             rx_data &= g_rspi_tcb[channel].unused_bits_mask;
                                 ;    1250             #endif
                                 ;    1251             ((uint32_t *)pdest)[rx_count-1] = rx_data;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1251
000009FC BA02                    		MOVU.W 10H[R0], R2
000009FE 6C22                    		SHLL #02H, R2
00000A00 4B12                    		ADD R1, R2
00000A02 6042                    		SUB #04H, R2
00000A04 E10205                  		MOV.L 14H[R0], [R2]
00000A07                         L270:	; bb180
                                 ;    1252         }
                                 ;    1253     }
                                 ;    1254 
                                 ;    1255     /* Check for last data.  */
                                 ;    1256      if(rx_count == g_rspi_tcb[channel].xfr_length)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1256
00000A07 B689                    		MOVU.B 1BH[R0], R1
00000A09 751118                  		MUL #18H, R1
00000A0C FBE2rrrrrrrr            		MOV.L #__$g_rspi_tcb, R14
00000A12 4B1E                    		ADD R1, R14
00000A14 BA01                    		MOVU.W 10H[R0], R1
00000A16 06C5E106                		CMP 0CH[R14].UW, R1
00000A1A 3Brrrr               W  		BNE L282
00000A1D                         L271:	; bb181
                                 ;    1257      {   /* Last data was transferred. */
                                 ;    1258          (*g_rspi_channels[channel]).SPCR.BIT.SPRIE = 0;  /* Disable SPRI interrupt. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1258
00000A1D FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
00000A23 B689                    		MOVU.B 1BH[R0], R1
00000A25 FE61EE                  		MOV.L [R1,R14], R14
00000A28 F0EF                    		BCLR #07H, [R14].B
00000A2A                         L272:	; bb181.split
                                 ;    1259          (*g_rspi_channels[channel]).SPCR.BIT.SPE   = 0;  /* Disable RSPI. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1259
00000A2A FBE2rrrrrrrr            		MOV.L #_g_rspi_channels, R14
00000A30 B689                    		MOVU.B 1BH[R0], R1
00000A32 FE61EE                  		MOV.L [R1,R14], R14
00000A35 F0EE                    		BCLR #06H, [R14].B
00000A37                         L273:	; bb181.split6
                                 ;    1260 
                                 ;    1261          #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;    1262          /* Release lock for this channel. */
                                 ;    1263          R_BSP_HardwareUnlock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1263
00000A37 B689                    		MOVU.B 1BH[R0], R1
00000A39 71113B                  		ADD #3BH, R1
00000A3C 05rrrrrr             A  		BSR _R_BSP_HardwareUnlock
00000A40                         L274:	; bb181.split7
                                 ;    1264          #endif
                                 ;    1265 
                                 ;    1266          /* Tranfer complete. Call the user callback function passing pointer to the result structure. */
                                 ;    1267          if((FIT_NO_FUNC != g_rspi_handles[channel].pcallback) && (NULL != g_rspi_handles[channel].pcallback))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1267
00000A40 B689                    		MOVU.B 1BH[R0], R1
00000A42 6C31                    		SHLL #03H, R1
00000A44 FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
00000A4A 4B12                    		ADD R1, R2
00000A4C A829                    		MOV.L 04H[R2], R1
00000A4E 740100000010            		CMP #10000000H, R1
00000A54 21rr                    		BNE L278
00000A56 2Err                 B  		BRA L280
00000A58                         L275:	; bb211
                                 ;    1268          {
                                 ;    1269              g_rspi_cb_data[channel].handle = &(g_rspi_handles[channel]);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1269
00000A58 B689                    		MOVU.B 1BH[R0], R1
00000A5A 6C31                    		SHLL #03H, R1
00000A5C FBE2rrrrrrrr            		MOV.L #__$g_rspi_cb_data, R14
00000A62 4B1E                    		ADD R1, R14
00000A64 FBF2rrrrrrrr            		MOV.L #__$g_rspi_handles, R15
00000A6A 4B1F                    		ADD R1, R15
00000A6C E3EF                    		MOV.L R15, [R14]
00000A6E                         L276:	; bb211.split
                                 ;    1270              g_rspi_cb_data[channel].event_code = RSPI_EVT_TRANSFER_COMPLETE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1270
00000A6E B689                    		MOVU.B 1BH[R0], R1
00000A70 6C31                    		SHLL #03H, R1
00000A72 FB22rrrrrrrr            		MOV.L #__$g_rspi_cb_data, R2
00000A78 4B12                    		ADD R1, R2
00000A7A 3E2100                  		MOV.L #00000000H, 04H[R2]
00000A7D                         L277:	; bb211.split8
                                 ;    1271              g_rspi_handles[channel].pcallback((void*)&(g_rspi_cb_data[channel]));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1271
00000A7D B68A                    		MOVU.B 1BH[R0], R2
00000A7F 6C32                    		SHLL #03H, R2
00000A81 FB12rrrrrrrr            		MOV.L #__$g_rspi_handles, R1
00000A87 4B21                    		ADD R2, R1
00000A89 A81B                    		MOV.L 04H[R1], R3
00000A8B FB12rrrrrrrr            		MOV.L #__$g_rspi_cb_data, R1
00000A91 4B21                    		ADD R2, R1
00000A93 7F13                    		JSR R3
00000A95 6707                    		RTSD #1CH
00000A97                         L278:	; bb239
00000A97 B689                    		MOVU.B 1BH[R0], R1
00000A99 6C31                    		SHLL #03H, R1
00000A9B FB22rrrrrrrr            		MOV.L #__$g_rspi_handles, R2
00000AA1 4B12                    		ADD R1, R2
00000AA3 A829                    		MOV.L 04H[R2], R1
00000AA5 6101                    		CMP #00H, R1
00000AA7 10                   S  		BEQ L280
00000AA8                         L279:	; bb247
00000AA8 F80601                  		MOV.L #00000001H, [R0]
00000AAB 08                   S  		BRA L281
00000AAC                         L280:	; bb248
00000AAC F80600                  		MOV.L #00000000H, [R0]
00000AAF                         L281:	; bb249
00000AAF EC01                    		MOV.L [R0], R1
00000AB1 6101                    		CMP #00H, R1
00000AB3 21rr                    		BNE L275
00000AB5                         L282:	; return.split
                                 ;    1272          }
                                 ;    1273     }
                                 ;    1274 
                                 ;    1275      return;
                                 ;    1276 } /* end rspi_transmit_common() */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1276
00000AB5 6707                    		RTSD #1CH
00000AB7                         __$rspi_spri0_isr:
                                 		.STACK	__$rspi_spri0_isr=36
                                 		.RVECTOR	39,__$rspi_spri0_isr
                                 ;    1277 
                                 ;    1278 
                                 ;    1279 /******************************************************************************
                                 ;    1280 * Function Name:    rspi_spri0_isr, rspi_spri1_isr, rspi_spri2_isr
                                 ;    1281 * Description  :    RSPI SPRI receive buffer full ISR.
                                 ;    1282 *                   Each ISR calls a common function but passes its channel number.
                                 ;    1283 * Arguments    :    N/A
                                 ;    1284 * Return Value :    N/A
                                 ;    1285 ******************************************************************************/
                                 ;    1286 #if RSPI_CFG_USE_CH0 == 1
                                 ;    1287 #pragma interrupt (rspi_spri0_isr(vect = VECT(RSPI0, SPRI0)))
                                 ;    1288 static void rspi_spri0_isr(void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1288
00000AB7 6EEF                    		PUSHM R14-R15
00000AB9 6E15                    		PUSHM R1-R5
                                 ;    1289 {
                                 ;    1290     g_rxdata[0] = (*g_rspi_channels[0]).SPDR.LONG; // Need to read RX data reg ASAP.
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1290
00000ABB FB12rrrrrrrr            		MOV.L #_g_rspi_channels, R1
00000AC1 EC11                    		MOV.L [R1], R1
00000AC3 FB22rrrrrrrr            		MOV.L #__$g_rxdata, R2
00000AC9 E11201                  		MOV.L 04H[R1], [R2]
00000ACC                         L284:	; entry.split
                                 ;    1291     g_rspi_tcb[0].rx_count++;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1291
00000ACC FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000AD2 991A                    		MOV.W 0AH[R1], R2
00000AD4 6212                    		ADD #01H, R2
00000AD6 911A                    		MOV.W R2, 0AH[R1]
00000AD8                         L285:	; entry.split1
00000AD8 6601                    		MOV.L #00000000H, R1
                                 ;    1292     rspi_tx_rx_common(0);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1292
00000ADA 39rrrr               W  		BSR __$rspi_tx_rx_common
00000ADD 6F15                    		POPM R1-R5
00000ADF 6FEF                    		POPM R14-R15
00000AE1 7F95                    		RTE
00000AE3                         __$rspi_spri1_isr:
                                 		.STACK	__$rspi_spri1_isr=36
                                 		.RVECTOR	42,__$rspi_spri1_isr
                                 ;    1293 } /* end rspi_spri0_isr */
                                 ;    1294 #endif
                                 ;    1295 
                                 ;    1296 #if RSPI_CFG_USE_CH1 == 1
                                 ;    1297 #pragma interrupt (rspi_spri1_isr(vect=VECT(RSPI1, SPRI1)))
                                 ;    1298 static void rspi_spri1_isr(void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1298
00000AE3 6EEF                    		PUSHM R14-R15
00000AE5 6E15                    		PUSHM R1-R5
                                 ;    1299 {
                                 ;    1300     g_rxdata[1] = (*g_rspi_channels[1]).SPDR.LONG;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1300
00000AE7 FB12rrrrrrrr            		MOV.L #_g_rspi_channels, R1
00000AED A819                    		MOV.L 04H[R1], R1
00000AEF FB22rrrrrrrr            		MOV.L #__$g_rxdata, R2
00000AF5 E5120101                		MOV.L 04H[R1], 04H[R2]
00000AF9                         L287:	; entry.split
                                 ;    1301     g_rspi_tcb[1].rx_count++;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1301
00000AF9 FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000AFF 9C1A                    		MOV.W 22H[R1], R2
00000B01 6212                    		ADD #01H, R2
00000B03 941A                    		MOV.W R2, 22H[R1]
00000B05                         L288:	; entry.split1
00000B05 6611                    		MOV.L #00000001H, R1
                                 ;    1302     rspi_tx_rx_common(1);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1302
00000B07 39rrrr               W  		BSR __$rspi_tx_rx_common
00000B0A 6F15                    		POPM R1-R5
00000B0C 6FEF                    		POPM R14-R15
00000B0E 7F95                    		RTE
00000B10                         __$rspi_spti0_isr:
                                 		.STACK	__$rspi_spti0_isr=40
                                 		.RVECTOR	40,__$rspi_spti0_isr
                                 ;    1303 } /* end rspi_spri1_isr */
                                 ;    1304 #endif
                                 ;    1305 
                                 ;    1306 #if RSPI_CFG_USE_CH2 == 1
                                 ;    1307     #pragma interrupt (rspi_spri2_isr(vect=VECT(RSPI2, SPRI2)))
                                 ;    1308     static void rspi_spri2_isr(void)
                                 ;    1309     {
                                 ;    1310         g_rxdata[2] = (*g_rspi_channels[2]).SPDR.LONG;
                                 ;    1311         g_rspi_tcb[2].rx_count++;
                                 ;    1312         rspi_tx_rx_common(2);
                                 ;    1313     } /* end rspi_spri2_isr */
                                 ;    1314 #endif
                                 ;    1315 /* end SPRI  */
                                 ;    1316 
                                 ;    1317 /******************************************************************************
                                 ;    1318 * Function Name:    rspi_spti0_isr, rspi_spti1_isr, rspi_spti2_isr
                                 ;    1319 * Description  :    RSPI SPTI transmit buffer empty ISR.
                                 ;    1320 *                   Each ISR calls a common function but passes its channel number.
                                 ;    1321 * Arguments    :    N/A
                                 ;    1322 * Return Value :    N/A
                                 ;    1323 ******************************************************************************/
                                 ;    1324 #if RSPI_CFG_USE_CH0 == 1
                                 ;    1325 #pragma interrupt (rspi_spti0_isr(vect=VECT(RSPI0, SPTI0)))
                                 ;    1326 static void rspi_spti0_isr(void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1326
00000B10 6EEF                    		PUSHM R14-R15
00000B12 6E15                    		PUSHM R1-R5
00000B14 6040                    		SUB #04H, R0
                                 ;    1327 {
                                 ;    1328     g_rxdata[0] = RSPI0.SPDR.LONG; // Read rx-data register into temp buffer.
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1328
00000B16 FB12rrrrrrrr            		MOV.L #__$g_rxdata, R1
00000B1C FB2E808308              		MOV.L #00088380H, R2
00000B21 E12101                  		MOV.L 04H[R2], [R1]
00000B24                         L290:	; entry.split
                                 ;    1329 
                                 ;    1330     /* If master mode then disable further spti interrupts on first transmit.
                                 ;    1331        If slave mode then we do two transmits to fill the double buffer,
                                 ;    1332        then disable spti interrupts.
                                 ;    1333        The receive interrupt will handle any remaining data. */
                                 ;    1334     if ((RSPI0.SPCR.BIT.MSTR) || (g_rspi_tcb[0].tx_count > 0))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1334
00000B24 FB1E808308              		MOV.L #00088380H, R1
00000B29 5811                    		MOVU.B [R1], R1
00000B2B 6831                    		SHLR #03H, R1
00000B2D 7C01                    		BTST #00H, R1
00000B2F 21rr                    		BNE L293
00000B31 08                   S  		BRA L292
00000B32                         L291:	; bb1
                                 ;    1335     {
                                 ;    1336         RSPI0.SPCR.BIT.SPTIE = 0;  /* Disable SPTI interrupt. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1336
00000B32 FB1E808308              		MOV.L #00088380H, R1
00000B37 F01D                    		BCLR #05H, [R1].B
00000B39 2Err                 B  		BRA L296
00000B3B                         L292:	; bb11
00000B3B FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000B41 B911                    		MOVU.W 08H[R1], R1
00000B43 6101                    		CMP #00H, R1
00000B45 2Brr                    		BLE L294
00000B47                         L293:	; bb16
00000B47 F80601                  		MOV.L #00000001H, [R0]
00000B4A 08                   S  		BRA L295
00000B4B                         L294:	; bb17
00000B4B F80600                  		MOV.L #00000000H, [R0]
00000B4E                         L295:	; bb18
00000B4E EC01                    		MOV.L [R0], R1
00000B50 6101                    		CMP #00H, R1
00000B52 21rr                    		BNE L291
00000B54                         L296:	; bb22
00000B54 6601                    		MOV.L #00000000H, R1
                                 ;    1337     }
                                 ;    1338 
                                 ;    1339     rspi_tx_rx_common(0);         // Process the data in the common handler.
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1339
00000B56 39rrrr               W  		BSR __$rspi_tx_rx_common
00000B59                         L297:	; bb22.split
                                 ;    1340 
                                 ;    1341     if (g_rspi_tcb[0].transfer_mode & RSPI_DO_RX)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1341
00000B59 FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000B5F A919                    		MOV.L 14H[R1], R1
00000B61 7C11                    		BTST #01H, R1
00000B63 20rr                    		BEQ L304
00000B65                         L298:	; bb25
                                 ;    1342     {    /* Count was incremented in the call to rspi_tx_rx_common. */
                                 ;    1343         if ((RSPI0.SPCR.BIT.MSTR) || (g_rspi_tcb[0].tx_count > 1))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1343
00000B65 FB1E808308              		MOV.L #00088380H, R1
00000B6A 5811                    		MOVU.B [R1], R1
00000B6C 6831                    		SHLR #03H, R1
00000B6E 7C01                    		BTST #00H, R1
00000B70 21rr                    		BNE L301
00000B72 2Err                 B  		BRA L300
00000B74                         L299:	; bb26
                                 ;    1344         {
                                 ;    1345             g_rspi_tcb[0].do_rx_now = true; /* Enables saving of receive data on next receive interrupt. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1345
00000B74 FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000B7A 3C1F01                  		MOV.B #01H, 0FH[R1]
00000B7D 6240                    		ADD #04H, R0
00000B7F 6F15                    		POPM R1-R5
00000B81 6FEF                    		POPM R14-R15
00000B83 7F95                    		RTE
00000B85                         L300:	; bb33
00000B85 FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000B8B B911                    		MOVU.W 08H[R1], R1
00000B8D 6121                    		CMP #02H, R1
00000B8F 29rr                    		BLT L302
00000B91                         L301:	; bb38
00000B91 F80601                  		MOV.L #00000001H, [R0]
00000B94 08                   S  		BRA L303
00000B95                         L302:	; bb39
00000B95 F80600                  		MOV.L #00000000H, [R0]
00000B98                         L303:	; bb40
00000B98 EC01                    		MOV.L [R0], R1
00000B9A 6101                    		CMP #00H, R1
00000B9C 21rr                    		BNE L299
00000B9E                         L304:	; return
                                 ;    1346         }
                                 ;    1347     }
                                 ;    1348 } /* end rspi_spti0_isr */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1348
00000B9E 6240                    		ADD #04H, R0
00000BA0 6F15                    		POPM R1-R5
00000BA2 6FEF                    		POPM R14-R15
00000BA4 7F95                    		RTE
00000BA6                         __$rspi_spti1_isr:
                                 		.STACK	__$rspi_spti1_isr=40
                                 		.RVECTOR	43,__$rspi_spti1_isr
                                 ;    1349 #endif
                                 ;    1350 
                                 ;    1351 #if RSPI_CFG_USE_CH1 == 1
                                 ;    1352 #pragma interrupt (rspi_spti1_isr(vect=VECT(RSPI1, SPTI1)))
                                 ;    1353 static void rspi_spti1_isr(void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1353
00000BA6 6EEF                    		PUSHM R14-R15
00000BA8 6E15                    		PUSHM R1-R5
00000BAA 6040                    		SUB #04H, R0
                                 ;    1354 {
                                 ;    1355     g_rxdata[1] = RSPI1.SPDR.LONG; // Read rx-data register into temp buffer.
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1355
00000BAC FB12rrrrrrrr            		MOV.L #__$g_rxdata, R1
00000BB2 FB2EA08308              		MOV.L #000883A0H, R2
00000BB7 E5210101                		MOV.L 04H[R2], 04H[R1]
00000BBB                         L306:	; entry.split
                                 ;    1356 
                                 ;    1357     if ((RSPI1.SPCR.BIT.MSTR) || (g_rspi_tcb[1].tx_count > 0))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1357
00000BBB FB1EA08308              		MOV.L #000883A0H, R1
00000BC0 5811                    		MOVU.B [R1], R1
00000BC2 6831                    		SHLR #03H, R1
00000BC4 7C01                    		BTST #00H, R1
00000BC6 21rr                    		BNE L309
00000BC8 08                   S  		BRA L308
00000BC9                         L307:	; bb1
                                 ;    1358     {
                                 ;    1359         RSPI1.SPCR.BIT.SPTIE = 0;  /* Disable SPTI interrupt. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1359
00000BC9 FB1EA08308              		MOV.L #000883A0H, R1
00000BCE F01D                    		BCLR #05H, [R1].B
00000BD0 2Err                 B  		BRA L312
00000BD2                         L308:	; bb11
00000BD2 FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000BD8 BC11                    		MOVU.W 20H[R1], R1
00000BDA 6101                    		CMP #00H, R1
00000BDC 2Brr                    		BLE L310
00000BDE                         L309:	; bb16
00000BDE F80601                  		MOV.L #00000001H, [R0]
00000BE1 08                   S  		BRA L311
00000BE2                         L310:	; bb17
00000BE2 F80600                  		MOV.L #00000000H, [R0]
00000BE5                         L311:	; bb18
00000BE5 EC01                    		MOV.L [R0], R1
00000BE7 6101                    		CMP #00H, R1
00000BE9 21rr                    		BNE L307
00000BEB                         L312:	; bb22
00000BEB 6611                    		MOV.L #00000001H, R1
                                 ;    1360     }
                                 ;    1361 
                                 ;    1362     rspi_tx_rx_common(1);         // Process the data in the common handler.
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1362
00000BED 39rrrr               W  		BSR __$rspi_tx_rx_common
00000BF0                         L313:	; bb22.split
                                 ;    1363 
                                 ;    1364     if (g_rspi_tcb[1].transfer_mode & RSPI_DO_RX)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1364
00000BF0 FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000BF6 AA99                    		MOV.L 2CH[R1], R1
00000BF8 7C11                    		BTST #01H, R1
00000BFA 20rr                    		BEQ L320
00000BFC                         L314:	; bb25
                                 ;    1365     {    /* Count was incremented in the call to rspi_tx_rx_common. */
                                 ;    1366         if ((RSPI1.SPCR.BIT.MSTR) || (g_rspi_tcb[1].tx_count > 1))
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1366
00000BFC FB1EA08308              		MOV.L #000883A0H, R1
00000C01 5811                    		MOVU.B [R1], R1
00000C03 6831                    		SHLR #03H, R1
00000C05 7C01                    		BTST #00H, R1
00000C07 21rr                    		BNE L317
00000C09 2Err                 B  		BRA L316
00000C0B                         L315:	; bb26
                                 ;    1367         {
                                 ;    1368             g_rspi_tcb[1].do_rx_now = true; /* Enables saving of receive data on next receive interrupt. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1368
00000C0B FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000C11 F9142701                		MOV.B #01H, 27H[R1]
00000C15 6240                    		ADD #04H, R0
00000C17 6F15                    		POPM R1-R5
00000C19 6FEF                    		POPM R14-R15
00000C1B 7F95                    		RTE
00000C1D                         L316:	; bb33
00000C1D FB12rrrrrrrr            		MOV.L #__$g_rspi_tcb, R1
00000C23 BC11                    		MOVU.W 20H[R1], R1
00000C25 6121                    		CMP #02H, R1
00000C27 29rr                    		BLT L318
00000C29                         L317:	; bb38
00000C29 F80601                  		MOV.L #00000001H, [R0]
00000C2C 08                   S  		BRA L319
00000C2D                         L318:	; bb39
00000C2D F80600                  		MOV.L #00000000H, [R0]
00000C30                         L319:	; bb40
00000C30 EC01                    		MOV.L [R0], R1
00000C32 6101                    		CMP #00H, R1
00000C34 21rr                    		BNE L315
00000C36                         L320:	; return
                                 ;    1369         }
                                 ;    1370     }
                                 ;    1371 } /* end rspi_spti1_isr */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\r_rspi_rx\src\r_rspi_rx.c",1371
00000C36 6240                    		ADD #04H, R0
00000C38 6F15                    		POPM R1-R5
00000C3A 6FEF                    		POPM R14-R15
00000C3C 7F95                    		RTE
                                 ;    1372 #endif
                                 ;    1373 
                                 ;    1374 #if RSPI_CFG_USE_CH2 == 1
                                 ;    1375 #pragma interrupt (rspi_spti2_isr(vect=VECT(RSPI2, SPTI2)))
                                 ;    1376 static void rspi_spti2_isr(void)
                                 ;    1377 {
                                 ;    1378     g_rxdata[2] = RSPI2.SPDR.LONG; // Read rx-data register into temp buffer.
                                 ;    1379 
                                 ;    1380     if ((RSPI2.SPCR.BIT.MSTR) || (g_rspi_tcb[2].tx_count > 0))
                                 ;    1381     {
                                 ;    1382         RSPI2.SPCR.BIT.SPTIE = 0;  /* Disable SPTI interrupt. */
                                 ;    1383     }
                                 ;    1384 
                                 ;    1385     rspi_tx_rx_common(2);         // Process the data in the common handler.
                                 ;    1386 
                                 ;    1387     if (g_rspi_tcb[2].transfer_mode & RSPI_DO_RX)
                                 ;    1388     {    /* Count was incremented in the call to rspi_tx_rx_common. */
                                 ;    1389         if ((RSPI2.SPCR.BIT.MSTR) || (g_rspi_tcb[2].tx_count > 1))
                                 ;    1390         {
                                 ;    1391             g_rspi_tcb[2].do_rx_now = true; /* Enables saving of receive data on next receive interrupt. */
                                 ;    1392         }
                                 ;    1393     }
                                 ;    1394 } /* end rspi_spti2_isr */
                                 ;    1395 #endif
                                 ;    1396 /* end SPTI  */
                                 ;    1397 
                                 ;    1398 /******************************************************************************
                                 ;    1399 * Function Name:    rspi_spei_isr_common
                                 ;    1400 * Description  :    common ISR handler for SPEI RSPI-error
                                 ;    1401 * Arguments    :    RSPI channel
                                 ;    1402 * Return Value :    N/A
                                 ;    1403 ******************************************************************************/
                                 ;    1404 static void rspi_spei_isr_common(uint8_t channel)
                                 ;    1405 {
                                 ;    1406     uint8_t status_flags = (*g_rspi_channels[channel]).SPSR.BYTE;
                                 ;    1407 
                                 ;    1408     /* Identify and clear error condition. */
                                 ;    1409     if(status_flags & RSPI_SPSR_OVRF) // Overrun error.
                                 ;    1410     {
                                 ;    1411         g_rspi_cb_data[channel].event_code = RSPI_EVT_ERR_READ_OVF;
                                 ;    1412         /* Clear error source: OVRF flag. */
                                 ;    1413         (*g_rspi_channels[channel]).SPSR.BIT.OVRF = 0;
                                 ;    1414     }
                                 ;    1415     else if (status_flags & RSPI_SPSR_MODF)
                                 ;    1416     {
                                 ;    1417         g_rspi_cb_data[channel].event_code = RSPI_EVT_ERR_MODE_FAULT;
                                 ;    1418         /* Clear error source: MODF flag. */
                                 ;    1419         (*g_rspi_channels[channel]).SPSR.BIT.MODF = 0;
                                 ;    1420     }
                                 ;    1421     else if (status_flags & RSPI_SPSR_PERF)
                                 ;    1422     {
                                 ;    1423         g_rspi_cb_data[channel].event_code = RSPI_EVT_ERR_PARITY;
                                 ;    1424         /* Clear error source: PERF flag. */
                                 ;    1425         (*g_rspi_channels[channel]).SPSR.BIT.PERF = 0;
                                 ;    1426     }
                                 ;    1427     else
                                 ;    1428     {
                                 ;    1429         g_rspi_cb_data[channel].event_code = RSPI_EVT_ERR_UNDEF;
                                 ;    1430     }
                                 ;    1431 
                                 ;    1432     /* Disable the RSPI channel (terminates the transfer operation). */
                                 ;    1433     (*g_rspi_channels[channel]).SPCR.BIT.SPRIE = 0;  /* Disable SPRI interrupt. */
                                 ;    1434     (*g_rspi_channels[channel]).SPCR.BIT.SPE   = 0;  /* Disable RSPI. */
                                 ;    1435 
                                 ;    1436     #if RSPI_CFG_REQUIRE_LOCK == 1
                                 ;    1437     /* Release lock for this channel. */
                                 ;    1438     R_BSP_HardwareUnlock((mcu_lock_t)(BSP_LOCK_RSPI0 + channel));
                                 ;    1439     #endif
                                 ;    1440 
                                 ;    1441     /* Call the user callback function passing pointer to the result structure. */
                                 ;    1442     if((FIT_NO_FUNC != g_rspi_handles[channel].pcallback) && (NULL != g_rspi_handles[channel].pcallback))
                                 ;    1443     {
                                 ;    1444         g_rspi_cb_data[channel].handle = &(g_rspi_handles[channel]);
                                 ;    1445         g_rspi_handles[channel].pcallback((void*)&(g_rspi_cb_data[channel]));
                                 ;    1446     }
                                 ;    1447 } /* end rspi_spei_isr_common() */
                                 ;    1448 
                                 ;    1449 
                                 ;    1450 /******************************************************************************
                                 ;    1451 * Function Name:    rspi_spei0_isr, rspi_spei1_isr, rspi_spei2_isr
                                 ;    1452 * Description  :    RSPI SPEI RSPI-error ISR.
                                 ;    1453 *                   Each ISR calls a common function but passes its channel number.
                                 ;    1454 * Arguments    :    N/A
                                 ;    1455 * Return Value :    N/A
                                 ;    1456 ******************************************************************************/
                                 ;    1457 #ifndef BSP_MCU_RX63_ALL  // This interrupt for RX63 series not supported by this code.
                                 ;    1458 	#if RSPI_CFG_USE_CH0 == 1
                                 ;    1459 	#pragma interrupt (rspi_spei0_isr(vect=VECT(RSPI0, SPEI0)))
                                 ;    1460 	static void rspi_spei0_isr(void)
                                 ;    1461 	{
                                 ;    1462 		rspi_spei_isr_common(0);
                                 ;    1463 	} /* end rspi_spei0_isr */
                                 ;    1464 	#endif
                                 ;    1465 
                                 ;    1466 	#if RSPI_CFG_USE_CH1 == 1
                                 ;    1467 	#pragma interrupt (rspi_spei1_isr(vect=VECT(RSPI1, SPEI1)))
                                 ;    1468 	static void rspi_spei1_isr(void)
                                 ;    1469 	{
                                 ;    1470 		rspi_spei_isr_common(1);
                                 ;    1471 	} /* end rspi_spei1_isr */
                                 ;    1472 	#endif
                                 ;    1473 
                                 ;    1474 	#if RSPI_CFG_USE_CH2 == 1
                                 ;    1475 		#pragma interrupt (rspi_spei2_isr(vect=VECT(RSPI2, SPEI2)))
                                 ;    1476 		static void rspi_spei2_isr(void)
                                 ;    1477 		{
                                 ;    1478 			rspi_spei_isr_common(2);
                                 ;    1479 		} /* end rspi_spei2_isr */
                                 ;    1480 	#endif
                                 ;    1481 #else
                                 ;    1482     #if RSPI_CFG_USE_RX63_ERROR_INTERRUPT == 1
                                 ;    1483     #pragma interrupt (rspi_spei_63_isr(vect=VECT(ICU, GROUP12)))
                                 ;    1484     static void rspi_spei_63_isr(void)
                                 ;    1485     {
                                 ;    1486         /* Get the interrupt source from the group interrupt source register. */
                                 ;    1487         #if RSPI_CFG_USE_CH0 == 1
                                 ;    1488         if (IS(RSPI0, SPEI0))
                                 ;    1489         {
                                 ;    1490             rspi_spei_isr_common(0);
                                 ;    1491         }
                                 ;    1492         #endif
                                 ;    1493 
                                 ;    1494         #if RSPI_CFG_USE_CH1 == 1
                                 ;    1495         if (IS(RSPI1, SPEI1))
                                 ;    1496         {
                                 ;    1497             rspi_spei_isr_common(1);
                                 ;    1498         }
                                 ;    1499         #endif
                                 ;    1500 
                                 ;    1501         #if RSPI_CFG_USE_CH2 == 1
                                 ;    1502         if (IS(RSPI2, SPEI2))
                                 ;    1503         {
                                 ;    1504             rspi_spei_isr_common(2);
                                 ;    1505         }
                                 ;    1506         #endif
                                 ;    1507     } /* end rspi_spei_63_isr */
                                 ;    1508     #endif
                                 ;    1509 #endif
                                 ;    1510 /* end SPRI  */
                                 		.SECTION	D,ROMDATA,ALIGN=4
00000000                         _g_rspi_channels:
00000000 80830800                		.lword	00088380H
00000004 A0830800                		.lword	000883A0H
00000008                         __$g_rspi_tcb:
00000008 00                      		.byte	0
00000009 00                      		.byte	0
0000000A 00                      		.byte	0
0000000B 00                      		.byte	0
0000000C 00                      		.byte	0
0000000D 00                      		.byte	0
0000000E 00                      		.byte	0
0000000F 00                      		.byte	0
00000010 00                      		.byte	0
00000011 00                      		.byte	0
00000012 00                      		.byte	0
00000013 00                      		.byte	0
00000014 00                      		.byte	0
00000015 00                      		.byte	0
00000016 00                      		.byte	0
00000017 00                      		.byte	0
00000018 00                      		.byte	0
00000019 00                      		.byte	0
0000001A 00                      		.byte	0
0000001B 00                      		.byte	0
0000001C 00                      		.byte	0
0000001D 00                      		.byte	0
0000001E 00                      		.byte	0
0000001F 00                      		.byte	0
00000020 00                      		.byte	0
00000021 00                      		.byte	0
00000022 00                      		.byte	0
00000023 00                      		.byte	0
00000024 00                      		.byte	0
00000025 00                      		.byte	0
00000026 00                      		.byte	0
00000027 00                      		.byte	0
00000028 00                      		.byte	0
00000029 00                      		.byte	0
0000002A 00                      		.byte	0
0000002B 00                      		.byte	0
0000002C 00                      		.byte	0
0000002D 00                      		.byte	0
0000002E 00                      		.byte	0
0000002F 00                      		.byte	0
00000030 00                      		.byte	0
00000031 00                      		.byte	0
00000032 00                      		.byte	0
00000033 00                      		.byte	0
00000034 00                      		.byte	0
00000035 00                      		.byte	0
00000036 00                      		.byte	0
00000037 00                      		.byte	0
00000038                         __$g_rspi_cb_data:
00000038 00                      		.byte	0
00000039 00                      		.byte	0
0000003A 00                      		.byte	0
0000003B 00                      		.byte	0
0000003C 00                      		.byte	0
0000003D 00                      		.byte	0
0000003E 00                      		.byte	0
0000003F 00                      		.byte	0
00000040 00                      		.byte	0
00000041 00                      		.byte	0
00000042 00                      		.byte	0
00000043 00                      		.byte	0
00000044 00                      		.byte	0
00000045 00                      		.byte	0
00000046 00                      		.byte	0
00000047 00                      		.byte	0
00000048                         __$g_ctrl_reg_values:
00000048 08                      		.byte	08H
00000049 00                      		.byte	00H
0000004A 00                      		.byte	00H
0000004B 00                      		.byte	00H
0000004C 01                      		.byte	01H
0000004D 20                      		.byte	20H
0000004E 00                      		.byte	00H
0000004F 00                      		.byte	00H
00000050 00                      		.byte	00H
00000051 00                      		.byte	0
00000052 00                      		.byte	0
00000053 00                      		.byte	0
00000054 00000000                		.lword	00000000H
00000058 08                      		.byte	08H
00000059 00                      		.byte	00H
0000005A 00                      		.byte	00H
0000005B 00                      		.byte	00H
0000005C 01                      		.byte	01H
0000005D 20                      		.byte	20H
0000005E 00                      		.byte	00H
0000005F 00                      		.byte	00H
00000060 00                      		.byte	00H
00000061 00                      		.byte	0
00000062 00                      		.byte	0
00000063 00                      		.byte	0
00000064 00000000                		.lword	00000000H
                                 		.SECTION	B,DATA,ALIGN=4
00000000                         __$g_rspi_handles:
00000000(00000010H)              		.blkl	4
00000010                         __$g_rxdata:
00000010(00000008H)              		.blkl	2
                                 		.END

Information List

TOTAL ERROR(S)    00000
TOTAL WARNING(S)  00000
TOTAL LINE(S)     03441   LINES

Section List

Attr         Size               Name
CODE     0000003134(00000C3EH)  P
ROMDATA  0000000104(00000068H)  D
DATA     0000000024(00000018H)  B

Cpu Type

-ISA=RXV1 -FPU

Command Parameter

-subcommand=C:\Users\LAFONS~1\AppData\Local\Temp\$ccrx4D06\$ccrx\r_rspi_rx.src.cmd
    -nologo
    -isa=rxv1
    -fpu
    -show=conditionals,definitions,expansions
    -define=__RXV1=1
    -fint_register=0
    -debug
    -endian=little
-listfile=C:\Workspace\e2studio\git\MT01_master\CompactaXP_build\r_rspi_rx.lst
-output=C:\Workspace\e2studio\git\MT01_master\CompactaXP_build\r_rspi_rx\src\r_rspi_rx.obj
