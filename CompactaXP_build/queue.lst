* RX FAMILY ASSEMBLER V2.03.00.01 [24 Oct 2014] *  SOURCE LIST  Thu Mar 09 14:19:20 2017

LOC.     OBJ.              0XMDA SOURCE STATEMENT

                                 ;RX Family C/C++ Compiler (V2.03.00.03 [04 Dec 2014])  09-Mar-2017 14:19:20
                                 
                                 ;*** CPU TYPE ***
                                 
                                 ;-ISA=RXV1
                                 
                                 ;*** COMMAND PARAMETER ***
                                 
                                 ;-output=src=queue.src
                                 ;-lang=c99
                                 ;-include=C:\PROGRA~2\Renesas\RX\2_3_0/include,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx,C:\Workspace\e2studio\git\MT01_master\r_lvd_rx\src,C:/Workspace/e2studio/
                                 ;-debug
                                 ;-show=source,conditionals,definitions,expansions
                                 ;-listfile=queue.lst
                                 ;-isa=rxv1
                                 ;-optimize=0
                                 ;-fpu
                                 ;-alias=noansi
                                 ;-nologo
                                 ;-nomessage
                                 ;-define=__RX,COMPACTAXP=1,EASYMAK=0,MOBILE=0,FREE_RTOS_PP
                                 ;queue.c
                                 
                                 		.glb	_xQueueGenericReset
                                 		.glb	_vAssertCalled
                                 		.glb	_vTaskEnterCritical
                                 		.glb	_xTaskRemoveFromEventList
                                 		.glb	_vListInitialise
                                 		.glb	_vTaskExitCritical
                                 		.glb	_xQueueGenericCreate
                                 		.glb	_pvPortMalloc
                                 		.glb	_xQueueCreateMutex
                                 		.glb	_xQueueGiveMutexRecursive
                                 		.glb	_xTaskGetCurrentTaskHandle
                                 		.glb	_xQueueTakeMutexRecursive
                                 		.glb	_xQueueCreateCountingSemaphore
                                 		.glb	_xQueueGenericSend
                                 		.glb	_xTaskGetSchedulerState
                                 		.glb	_vTaskSetTimeOutState
                                 		.glb	_vTaskSuspendAll
                                 		.glb	_vTaskPlaceOnEventList
                                 		.glb	_xTaskResumeAll
                                 		.glb	_xTaskCheckForTimeOut
                                 		.glb	_xQueueGenericSendFromISR
                                 		.glb	_xQueueGiveFromISR
                                 		.glb	_xQueueGenericReceive
                                 		.glb	_pvTaskIncrementMutexHeldCount
                                 		.glb	_vTaskPriorityInherit
                                 		.glb	_xQueueReceiveFromISR
                                 		.glb	_xQueuePeekFromISR
                                 		.glb	_uxQueueMessagesWaiting
                                 		.glb	_uxQueueSpacesAvailable
                                 		.glb	_uxQueueMessagesWaitingFromISR
                                 		.glb	_vQueueDelete
                                 		.glb	_vPortFree
                                 		.glb	_uxQueueGetQueueNumber
                                 		.glb	_vQueueSetQueueNumber
                                 		.glb	_ucQueueGetQueueType
                                 		.glb	_xTaskPriorityDisinherit
                                 		.glb	_vTaskMissedYield
                                 		.glb	_xQueueIsQueueEmptyFromISR
                                 		.glb	_xQueueIsQueueFullFromISR
                                 		.glb	_vQueueWaitForMessageRestricted
                                 		.glb	_vTaskPlaceOnEventListRestricted
                                 		.glb	_xQueueCreateSet
                                 		.glb	_xQueueAddToSet
                                 		.glb	_xQueueRemoveFromSet
                                 		.glb	_xQueueSelectFromSet
                                 		.glb	_xQueueSelectFromSetFromISR
                                 ;LineNo. C-SOURCE STATEMENT
                                 
                                 		.SECTION	P,CODE
00000000                         _xQueueGenericReset:
                                 		.STACK	_xQueueGenericReset=20
                                 ;       1 /*
                                 ;       2     FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
                                 ;       3     All rights reserved
                                 ;       4 
                                 ;       5     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
                                 ;       6 
                                 ;       7     This file is part of the FreeRTOS distribution.
                                 ;       8 
                                 ;       9     FreeRTOS is free software; you can redistribute it and/or modify it under
                                 ;      10     the terms of the GNU General Public License (version 2) as published by the
                                 ;      11     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
                                 ;      12 
                                 ;      13     ***************************************************************************
                                 ;      14     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
                                 ;      15     >>!   distribute a combined work that includes FreeRTOS without being   !<<
                                 ;      16     >>!   obliged to provide the source code for proprietary components     !<<
                                 ;      17     >>!   outside of the FreeRTOS kernel.                                   !<<
                                 ;      18     ***************************************************************************
                                 ;      19 
                                 ;      20     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
                                 ;      21     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
                                 ;      22     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
                                 ;      23     link: http://www.freertos.org/a00114.html
                                 ;      24 
                                 ;      25     ***************************************************************************
                                 ;      26      *                                                                       *
                                 ;      27      *    FreeRTOS provides completely free yet professionally developed,    *
                                 ;      28      *    robust, strictly quality controlled, supported, and cross          *
                                 ;      29      *    platform software that is more than just the market leader, it     *
                                 ;      30      *    is the industry's de facto standard.                               *
                                 ;      31      *                                                                       *
                                 ;      32      *    Help yourself get started quickly while simultaneously helping     *
                                 ;      33      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
                                 ;      34      *    tutorial book, reference manual, or both:                          *
                                 ;      35      *    http://www.FreeRTOS.org/Documentation                              *
                                 ;      36      *                                                                       *
                                 ;      37     ***************************************************************************
                                 ;      38 
                                 ;      39     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
                                 ;      40     the FAQ page "My application does not run, what could be wrong?".  Have you
                                 ;      41     defined configASSERT()?
                                 ;      42 
                                 ;      43     http://www.FreeRTOS.org/support - In return for receiving this top quality
                                 ;      44     embedded software for free we request you assist our global community by
                                 ;      45     participating in the support forum.
                                 ;      46 
                                 ;      47     http://www.FreeRTOS.org/training - Investing in training allows your team to
                                 ;      48     be as productive as possible as early as possible.  Now you can receive
                                 ;      49     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
                                 ;      50     Ltd, and the world's leading authority on the world's leading RTOS.
                                 ;      51 
                                 ;      52     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
                                 ;      53     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
                                 ;      54     compatible FAT file system, and our tiny thread aware UDP/IP stack.
                                 ;      55 
                                 ;      56     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
                                 ;      57     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
                                 ;      58 
                                 ;      59     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
                                 ;      60     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
                                 ;      61     licenses offer ticketed support, indemnification and commercial middleware.
                                 ;      62 
                                 ;      63     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
                                 ;      64     engineered and independently SIL3 certified version for use in safety and
                                 ;      65     mission critical applications that require provable dependability.
                                 ;      66 
                                 ;      67     1 tab == 4 spaces!
                                 ;      68 */
                                 ;      69 
                                 ;      70 #include <stdlib.h>
                                 ;      71 #include <string.h>
                                 ;      72 
                                 ;      73 /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
                                 ;      74 all the API functions to use the MPU wrappers.  That should only be done when
                                 ;      75 task.h is included from an application file. */
                                 ;      76 #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
                                 ;      77 
                                 ;      78 #include "FreeRTOS.h"
                                 ;      79 #include "task.h"
                                 ;      80 #include "queue.h"
                                 ;      81 
                                 ;      82 #if ( configUSE_CO_ROUTINES == 1 )
                                 ;      83 	#include "croutine.h"
                                 ;      84 #endif
                                 ;      85 
                                 ;      86 /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
                                 ;      87 MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
                                 ;      88 header files above, but not in this file, in order to generate the correct
                                 ;      89 privileged Vs unprivileged linkage and placement. */
                                 ;      90 #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
                                 ;      91 
                                 ;      92 
                                 ;      93 /* Constants used with the xRxLock and xTxLock structure members. */
                                 ;      94 #define queueUNLOCKED					( ( BaseType_t ) -1 )
                                 ;      95 #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
                                 ;      96 
                                 ;      97 /* When the Queue_t structure is used to represent a base queue its pcHead and
                                 ;      98 pcTail members are used as pointers into the queue storage area.  When the
                                 ;      99 Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
                                 ;     100 not necessary, and the pcHead pointer is set to NULL to indicate that the
                                 ;     101 pcTail pointer actually points to the mutex holder (if any).  Map alternative
                                 ;     102 names to the pcHead and pcTail structure members to ensure the readability of
                                 ;     103 the code is maintained despite this dual use of two structure members.  An
                                 ;     104 alternative implementation would be to use a union, but use of a union is
                                 ;     105 against the coding standard (although an exception to the standard has been
                                 ;     106 permitted where the dual use also significantly changes the type of the
                                 ;     107 structure member). */
                                 ;     108 #define pxMutexHolder					pcTail
                                 ;     109 #define uxQueueType						pcHead
                                 ;     110 #define queueQUEUE_IS_MUTEX				NULL
                                 ;     111 
                                 ;     112 /* Semaphores do not actually store or copy data, so have an item size of
                                 ;     113 zero. */
                                 ;     114 #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
                                 ;     115 #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
                                 ;     116 
                                 ;     117 #if( configUSE_PREEMPTION == 0 )
                                 ;     118 	/* If the cooperative scheduler is being used then a yield should not be
                                 ;     119 	performed just because a higher priority task has been woken. */
                                 ;     120 	#define queueYIELD_IF_USING_PREEMPTION()
                                 ;     121 #else
                                 ;     122 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
                                 ;     123 #endif
                                 ;     124 
                                 ;     125 /*
                                 ;     126  * Definition of the queue used by the scheduler.
                                 ;     127  * Items are queued by copy, not reference.  See the following link for the
                                 ;     128  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
                                 ;     129  */
                                 ;     130 typedef struct QueueDefinition
                                 ;     131 {
                                 ;     132 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
                                 ;     133 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary
                                 ;     134 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
                                 ;     135 
                                 ;     136 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive struct
                                 ;     137 	{
                                 ;     138 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
                                 ;     139 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure 
                                 ;     140 	} u;
                                 ;     141 
                                 ;     142 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
                                 ;     143 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
                                 ;     144 
                                 ;     145 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
                                 ;     146 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
                                 ;     147 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
                                 ;     148 
                                 ;     149 	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queu
                                 ;     150 	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUN
                                 ;     151 
                                 ;     152 	#if ( configUSE_TRACE_FACILITY == 1 )
                                 ;     153 		UBaseType_t uxQueueNumber;
                                 ;     154 		uint8_t ucQueueType;
                                 ;     155 	#endif
                                 ;     156 
                                 ;     157 	#if ( configUSE_QUEUE_SETS == 1 )
                                 ;     158 		struct QueueDefinition *pxQueueSetContainer;
                                 ;     159 	#endif
                                 ;     160 
                                 ;     161 } xQUEUE;
                                 ;     162 
                                 ;     163 /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
                                 ;     164 name below to enable the use of older kernel aware debuggers. */
                                 ;     165 typedef xQUEUE Queue_t;
                                 ;     166 
                                 ;     167 /*-----------------------------------------------------------*/
                                 ;     168 
                                 ;     169 /*
                                 ;     170  * The queue registry is just a means for kernel aware debuggers to locate
                                 ;     171  * queue structures.  It has no other purpose so is an optional component.
                                 ;     172  */
                                 ;     173 #if ( configQUEUE_REGISTRY_SIZE > 0 )
                                 ;     174 
                                 ;     175 	/* The type stored within the queue registry array.  This allows a name
                                 ;     176 	to be assigned to each queue making kernel aware debugging a little
                                 ;     177 	more user friendly. */
                                 ;     178 	typedef struct QUEUE_REGISTRY_ITEM
                                 ;     179 	{
                                 ;     180 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                 ;     181 		QueueHandle_t xHandle;
                                 ;     182 	} xQueueRegistryItem;
                                 ;     183 
                                 ;     184 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
                                 ;     185 	new xQueueRegistryItem name below to enable the use of older kernel aware
                                 ;     186 	debuggers. */
                                 ;     187 	typedef xQueueRegistryItem QueueRegistryItem_t;
                                 ;     188 
                                 ;     189 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
                                 ;     190 	The pcQueueName member of a structure being NULL is indicative of the
                                 ;     191 	array position being vacant. */
                                 ;     192 	QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
                                 ;     193 
                                 ;     194 #endif /* configQUEUE_REGISTRY_SIZE */
                                 ;     195 
                                 ;     196 /*
                                 ;     197  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
                                 ;     198  * prevent an ISR from adding or removing items to the queue, but does prevent
                                 ;     199  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
                                 ;     200  * queue is locked it will instead increment the appropriate queue lock count
                                 ;     201  * to indicate that a task may require unblocking.  When the queue in unlocked
                                 ;     202  * these lock counts are inspected, and the appropriate action taken.
                                 ;     203  */
                                 ;     204 static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
                                 ;     205 
                                 ;     206 /*
                                 ;     207  * Uses a critical section to determine if there is any data in a queue.
                                 ;     208  *
                                 ;     209  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
                                 ;     210  */
                                 ;     211 static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
                                 ;     212 
                                 ;     213 /*
                                 ;     214  * Uses a critical section to determine if there is any space in a queue.
                                 ;     215  *
                                 ;     216  * @return pdTRUE if there is no space, otherwise pdFALSE;
                                 ;     217  */
                                 ;     218 static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
                                 ;     219 
                                 ;     220 /*
                                 ;     221  * Copies an item into the queue, either at the front of the queue or the
                                 ;     222  * back of the queue.
                                 ;     223  */
                                 ;     224 static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
                                 ;     225 
                                 ;     226 /*
                                 ;     227  * Copies an item out of a queue.
                                 ;     228  */
                                 ;     229 static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
                                 ;     230 
                                 ;     231 #if ( configUSE_QUEUE_SETS == 1 )
                                 ;     232 	/*
                                 ;     233 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
                                 ;     234 	 * the queue set that the queue contains data.
                                 ;     235 	 */
                                 ;     236 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
                                 ;     237 #endif
                                 ;     238 
                                 ;     239 /*-----------------------------------------------------------*/
                                 ;     240 
                                 ;     241 /*
                                 ;     242  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
                                 ;     243  * accessing the queue event lists.
                                 ;     244  */
                                 ;     245 #define prvLockQueue( pxQueue )								\
                                 ;     246 	taskENTER_CRITICAL();									\
                                 ;     247 	{														\
                                 ;     248 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
                                 ;     249 		{													\
                                 ;     250 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
                                 ;     251 		}													\
                                 ;     252 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
                                 ;     253 		{													\
                                 ;     254 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
                                 ;     255 		}													\
                                 ;     256 	}														\
                                 ;     257 	taskEXIT_CRITICAL()
                                 ;     258 /*-----------------------------------------------------------*/
                                 ;     259 
                                 ;     260 BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",260
00000000 7100F0                  		ADD #0FFFFFFF0H, R0
00000003 A089                    		MOV.L R1, 0CH[R0]
00000005 A082                    		MOV.L R2, 08H[R0]
                                 ;     261 {
                                 ;     262 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",262
00000007 E10003                  		MOV.L 0CH[R0], [R0]
0000000A                         L11:	; entry.split
                                 ;     263 
                                 ;     264 	configASSERT( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",264
0000000A EC01                    		MOV.L [R0], R1
0000000C 6101                    		CMP #00H, R1
0000000E 18                   S  		BNE L13
0000000F                         L12:	; bb6
0000000F 05rrrrrr             A  		BSR _vAssertCalled
00000013                         L13:	; bb10
                                 ;     265 
                                 ;     266 	taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",266
00000013 05rrrrrr             A  		BSR _vTaskEnterCritical
00000017                         L14:	; bb10.split
                                 ;     267 	{
                                 ;     268 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",268
00000017 EC01                    		MOV.L [R0], R1
00000019 AB9A                    		MOV.L 3CH[R1], R2
0000001B 068D1210                		MUL 40H[R1].L, R2
0000001F 068812                  		ADD [R1].L, R2
00000022 A01A                    		MOV.L R2, 04H[R1]
00000024                         L15:	; bb10.split1
                                 ;     269 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",269
00000024 EC01                    		MOV.L [R0], R1
00000026 3E1E00                  		MOV.L #00000000H, 38H[R1]
00000029                         L16:	; bb10.split2
                                 ;     270 		pxQueue->pcWriteTo = pxQueue->pcHead;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",270
00000029 EC01                    		MOV.L [R0], R1
0000002B E41102                  		MOV.L [R1], 08H[R1]
0000002E                         L17:	; bb10.split3
                                 ;     271 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",271
0000002E EC01                    		MOV.L [R0], R1
00000030 AB9A                    		MOV.L 3CH[R1], R2
00000032 6012                    		SUB #01H, R2
00000034 068D1210                		MUL 40H[R1].L, R2
00000038 068812                  		ADD [R1].L, R2
0000003B A09A                    		MOV.L R2, 0CH[R1]
0000003D                         L18:	; bb10.split4
                                 ;     272 		pxQueue->xRxLock = queueUNLOCKED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",272
0000003D EC01                    		MOV.L [R0], R1
0000003F F91611FF                		MOV.L #0FFFFFFFFH, 44H[R1]
00000043                         L19:	; bb10.split5
                                 ;     273 		pxQueue->xTxLock = queueUNLOCKED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",273
00000043 EC01                    		MOV.L [R0], R1
00000045 F91612FF                		MOV.L #0FFFFFFFFH, 48H[R1]
00000049                         L20:	; bb10.split6
                                 ;     274 
                                 ;     275 		if( xNewQueue == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",275
00000049 EC01                    		MOV.L [R0], R1
0000004B 711110                  		ADD #10H, R1
0000004E A882                    		MOV.L 08H[R0], R2
00000050 6102                    		CMP #00H, R2
00000052 21rr                    		BNE L24
00000054                         L21:	; bb53
                                 ;     276 		{
                                 ;     277 			/* If there are tasks blocked waiting to read from the queue, then
                                 ;     278 			the tasks will remain blocked as after this function exits the queue
                                 ;     279 			will still be empty.  If there are tasks blocked waiting to write to
                                 ;     280 			the queue, then one should be unblocked as after this function exits
                                 ;     281 			it will be possible to write to it. */
                                 ;     282 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",282
00000054 EC1E                    		MOV.L [R1], R14
00000056 610E                    		CMP #00H, R14
00000058 20rr                    		BEQ L26
0000005A                         L22:	; bb55
                                 ;     283 			{
                                 ;     284 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",284
0000005A EC01                    		MOV.L [R0], R1
0000005C 711110                  		ADD #10H, R1
0000005F 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
00000063 6111                    		CMP #01H, R1
00000065 21rr                    		BNE L26
00000067                         L23:	; bb56
                                 ;     285 				{
                                 ;     286 					queueYIELD_IF_USING_PREEMPTION();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",286
                                 		._LINE_TOP  inline_asm
                                  
00000067 7EA5                    	PUSH.L R5
                                 	 
00000069 FB5EE07208              	MOV.L #553696, R5
0000006E F85401                  	MOV.B #1, [R5]
                                 	 
00000071 EC55                    	MOV.L [R5], R5
                                 	 
00000073 7EB5                    	POP R5
                                 		._LINE_END  inline_asm
00000075 2Err                 B  		BRA L26
00000077                         L24:	; bb76
                                 ;     287 				}
                                 ;     288 				else
                                 ;     289 				{
                                 ;     290 					mtCOVERAGE_TEST_MARKER();
                                 ;     291 				}
                                 ;     292 			}
                                 ;     293 			else
                                 ;     294 			{
                                 ;     295 				mtCOVERAGE_TEST_MARKER();
                                 ;     296 			}
                                 ;     297 		}
                                 ;     298 		else
                                 ;     299 		{
                                 ;     300 			/* Ensure the event queues start in the correct state. */
                                 ;     301 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",301
00000077 05rrrrrr             A  		BSR _vListInitialise
0000007B                         L25:	; bb76.split
                                 ;     302 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",302
0000007B EC01                    		MOV.L [R0], R1
0000007D 711124                  		ADD #24H, R1
00000080 05rrrrrr             A  		BSR _vListInitialise
00000084                         L26:	; bb85
                                 ;     303 		}
                                 ;     304 	}
                                 ;     305 	taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",305
00000084 05rrrrrr             A  		BSR _vTaskExitCritical
00000088                         L27:	; bb85.split
                                 ;     306 
                                 ;     307 	/* A value is returned for calling semantic consistency with previous
                                 ;     308 	versions. */
                                 ;     309 	return pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",309
00000088 3E0101                  		MOV.L #00000001H, 04H[R0]
0000008B 6611                    		MOV.L #00000001H, R1
0000008D                         L28:	; bb85.split7
                                 ;     310 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",310
0000008D 6704                    		RTSD #10H
0000008F                         _xQueueGenericCreate:
                                 		.STACK	_xQueueGenericCreate=36
                                 ;     311 /*-----------------------------------------------------------*/
                                 ;     312 
                                 ;     313 QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",313
0000008F 7100E0                  		ADD #0FFFFFFE0H, R0
00000092 A189                    		MOV.L R1, 1CH[R0]
00000094 A182                    		MOV.L R2, 18H[R0]
00000096 858B                    		MOV.B R3, 17H[R0]
                                 ;     314 {
                                 ;     315 Queue_t *pxNewQueue;
                                 ;     316 size_t xQueueSizeInBytes;
                                 ;     317 QueueHandle_t xReturn = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",317
00000098 3E0200                  		MOV.L #00000000H, 08H[R0]
0000009B                         L30:	; entry.split1
                                 ;     318 int8_t *pcAllocatedBuffer;
                                 ;     319 
                                 ;     320 	/* Remove compiler warnings about unused parameters should
                                 ;     321 	configUSE_TRACE_FACILITY not be set to 1. */
                                 ;     322 	( void ) ucQueueType;
                                 ;     323 
                                 ;     324 	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",324
0000009B A989                    		MOV.L 1CH[R0], R1
0000009D 6101                    		CMP #00H, R1
0000009F 18                   S  		BNE L32
000000A0                         L31:	; bb9
000000A0 05rrrrrr             A  		BSR _vAssertCalled
000000A4                         L32:	; bb16
                                 ;     325 
                                 ;     326 	if( uxItemSize == ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",326
000000A4 A981                    		MOV.L 18H[R0], R1
000000A6 6101                    		CMP #00H, R1
000000A8 18                   S  		BNE L34
000000A9                         L33:	; bb17
                                 ;     327 	{
                                 ;     328 		/* There is not going to be a queue storage area. */
                                 ;     329 		xQueueSizeInBytes = ( size_t ) 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",329
000000A9 3E0100                  		MOV.L #00000000H, 04H[R0]
000000AC 2Err                 B  		BRA L35
000000AE                         L34:	; bb18
                                 ;     330 	}
                                 ;     331 	else
                                 ;     332 	{
                                 ;     333 		/* The queue is one byte longer than asked for to make wrap checking
                                 ;     334 		easier/faster. */
                                 ;     335 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for s
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",335
000000AE A989                    		MOV.L 1CH[R0], R1
000000B0 068D0106                		MUL 18H[R0].L, R1
000000B4 6211                    		ADD #01H, R1
000000B6 A009                    		MOV.L R1, 04H[R0]
000000B8                         L35:	; bb27
                                 ;     336 	}
                                 ;     337 
                                 ;     338 	/* Allocate the new queue structure and storage area. */
                                 ;     339 	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",339
000000B8 A809                    		MOV.L 04H[R0], R1
000000BA 711158                  		ADD #58H, R1
000000BD 05rrrrrr             A  		BSR _pvPortMalloc
000000C1 A089                    		MOV.L R1, 0CH[R0]
000000C3                         L36:	; bb27.split
                                 ;     340 
                                 ;     341 	if( pcAllocatedBuffer != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",341
000000C3 A889                    		MOV.L 0CH[R0], R1
000000C5 6101                    		CMP #00H, R1
000000C7 20rr                    		BEQ L47
000000C9                         L37:	; bb32
                                 ;     342 	{
                                 ;     343 		pxNewQueue = ( Queue_t * ) pcAllocatedBuffer; /*lint !e826 MISRA The buffer cannot be too small because it was dimensioned by sizeof( Queue_t ) 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",343
000000C9 E10003                  		MOV.L 0CH[R0], [R0]
000000CC                         L38:	; bb32.split
                                 ;     344 
                                 ;     345 		if( uxItemSize == ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",345
000000CC A981                    		MOV.L 18H[R0], R1
000000CE 6101                    		CMP #00H, R1
000000D0 EC01                    		MOV.L [R0], R1
000000D2 18                   S  		BNE L40
000000D3                         L39:	; bb36
                                 ;     346 		{
                                 ;     347 			/* No RAM was allocated for the queue storage area, but PC head
                                 ;     348 			cannot be set to NULL because NULL is used as a key to say the queue
                                 ;     349 			is used as a mutex.  Therefore just set pcHead to point to the queue
                                 ;     350 			as a benign value that is known to be within the memory map. */
                                 ;     351 			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",351
000000D3 E001                    		MOV.L [R0], [R1]
000000D5 08                   S  		BRA L41
000000D6                         L40:	; bb41
                                 ;     352 		}
                                 ;     353 		else
                                 ;     354 		{
                                 ;     355 			/* Jump past the queue structure to find the location of the queue
                                 ;     356 			storage area - adding the padding bytes to get a better alignment. */
                                 ;     357 			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",357
000000D6 A88A                    		MOV.L 0CH[R0], R2
000000D8 712258                  		ADD #58H, R2
000000DB E312                    		MOV.L R2, [R1]
000000DD                         L41:	; bb50
                                 ;     358 		}
                                 ;     359 
                                 ;     360 		/* Initialise the queue members as described above where the queue type
                                 ;     361 		is defined. */
                                 ;     362 		pxNewQueue->uxLength = uxQueueLength;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",362
000000DD A989                    		MOV.L 1CH[R0], R1
000000DF EC02                    		MOV.L [R0], R2
000000E1 A3A9                    		MOV.L R1, 3CH[R2]
000000E3                         L42:	; bb50.split
                                 ;     363 		pxNewQueue->uxItemSize = uxItemSize;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",363
000000E3 A981                    		MOV.L 18H[R0], R1
000000E5 EC02                    		MOV.L [R0], R2
000000E7 A421                    		MOV.L R1, 40H[R2]
000000E9                         L43:	; bb50.split2
                                 ;     364 		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",364
000000E9 EC01                    		MOV.L [R0], R1
000000EB 6612                    		MOV.L #00000001H, R2
000000ED 39rrrr               W  		BSR _xQueueGenericReset
000000F0                         L44:	; bb50.split3
                                 ;     365 
                                 ;     366 		#if ( configUSE_TRACE_FACILITY == 1 )
                                 ;     367 		{
                                 ;     368 			pxNewQueue->ucQueueType = ucQueueType;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",368
000000F0 B589                    		MOVU.B 17H[R0], R1
000000F2 EC02                    		MOV.L [R0], R2
000000F4 C72150                  		MOV.B R1, 50H[R2]
000000F7                         L45:	; bb50.split4
                                 ;     369 		}
                                 ;     370 		#endif /* configUSE_TRACE_FACILITY */
                                 ;     371 
                                 ;     372 		#if( configUSE_QUEUE_SETS == 1 )
                                 ;     373 		{
                                 ;     374 			pxNewQueue->pxQueueSetContainer = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",374
000000F7 EC01                    		MOV.L [R0], R1
000000F9 3E9500                  		MOV.L #00000000H, 54H[R1]
000000FC                         L46:	; bb50.split5
                                 ;     375 		}
                                 ;     376 		#endif /* configUSE_QUEUE_SETS */
                                 ;     377 
                                 ;     378 		traceQUEUE_CREATE( pxNewQueue );
                                 ;     379 		xReturn = pxNewQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",379
000000FC E40002                  		MOV.L [R0], 08H[R0]
000000FF                         L47:	; bb73
                                 ;     380 	}
                                 ;     381 	else
                                 ;     382 	{
                                 ;     383 		mtCOVERAGE_TEST_MARKER();
                                 ;     384 	}
                                 ;     385 
                                 ;     386 	configASSERT( xReturn );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",386
000000FF A881                    		MOV.L 08H[R0], R1
00000101 6101                    		CMP #00H, R1
00000103 18                   S  		BNE L49
00000104                         L48:	; bb74
00000104 05rrrrrr             A  		BSR _vAssertCalled
00000108                         L49:	; bb79
                                 ;     387 
                                 ;     388 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",388
00000108 A881                    		MOV.L 08H[R0], R1
0000010A A101                    		MOV.L R1, 10H[R0]
0000010C                         L50:	; bb79.split
                                 ;     389 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",389
0000010C 6708                    		RTSD #20H
0000010E                         _xQueueCreateMutex:
                                 		.STACK	_xQueueCreateMutex=16
                                 ;     390 /*-----------------------------------------------------------*/
                                 ;     391 
                                 ;     392 #if ( configUSE_MUTEXES == 1 )
                                 ;     393 
                                 ;     394 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",394
0000010E 60C0                    		SUB #0CH, R0
00000110 8289                    		MOV.B R1, 0BH[R0]
00000112                         L52:	; entry.split
00000112 754158                  		MOV.L #00000058H, R1
                                 ;     395 	{
                                 ;     396 	Queue_t *pxNewQueue;
                                 ;     397 
                                 ;     398 		/* Prevent compiler warnings about unused parameters if
                                 ;     399 		configUSE_TRACE_FACILITY does not equal 1. */
                                 ;     400 		( void ) ucQueueType;
                                 ;     401 
                                 ;     402 		/* Allocate the new queue structure. */
                                 ;     403 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",403
00000115 05rrrrrr             A  		BSR _pvPortMalloc
00000119 E301                    		MOV.L R1, [R0]
0000011B                         L53:	; entry.split1
                                 ;     404 		if( pxNewQueue != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",404
0000011B EC01                    		MOV.L [R0], R1
0000011D 6101                    		CMP #00H, R1
0000011F 20rr                    		BEQ L68
00000121                         L54:	; bb6
                                 ;     405 		{
                                 ;     406 			/* Information required for priority inheritance. */
                                 ;     407 			pxNewQueue->pxMutexHolder = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",407
00000121 EC01                    		MOV.L [R0], R1
00000123 3E1100                  		MOV.L #00000000H, 04H[R1]
00000126                         L55:	; bb6.split
                                 ;     408 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",408
00000126 EC01                    		MOV.L [R0], R1
00000128 F81600                  		MOV.L #00000000H, [R1]
0000012B                         L56:	; bb6.split2
                                 ;     409 
                                 ;     410 			/* Queues used as a mutex no data is actually copied into or out
                                 ;     411 			of the queue. */
                                 ;     412 			pxNewQueue->pcWriteTo = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",412
0000012B EC01                    		MOV.L [R0], R1
0000012D 3E1200                  		MOV.L #00000000H, 08H[R1]
00000130                         L57:	; bb6.split3
                                 ;     413 			pxNewQueue->u.pcReadFrom = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",413
00000130 EC01                    		MOV.L [R0], R1
00000132 3E1300                  		MOV.L #00000000H, 0CH[R1]
00000135                         L58:	; bb6.split4
                                 ;     414 
                                 ;     415 			/* Each mutex has a length of 1 (like a binary semaphore) and
                                 ;     416 			an item size of 0 as nothing is actually copied into or out
                                 ;     417 			of the mutex. */
                                 ;     418 			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",418
00000135 EC01                    		MOV.L [R0], R1
00000137 3E1E00                  		MOV.L #00000000H, 38H[R1]
0000013A                         L59:	; bb6.split5
                                 ;     419 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",419
0000013A EC01                    		MOV.L [R0], R1
0000013C 3E1F01                  		MOV.L #00000001H, 3CH[R1]
0000013F                         L60:	; bb6.split6
                                 ;     420 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",420
0000013F EC01                    		MOV.L [R0], R1
00000141 3E9000                  		MOV.L #00000000H, 40H[R1]
00000144                         L61:	; bb6.split7
                                 ;     421 			pxNewQueue->xRxLock = queueUNLOCKED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",421
00000144 EC01                    		MOV.L [R0], R1
00000146 F91611FF                		MOV.L #0FFFFFFFFH, 44H[R1]
0000014A                         L62:	; bb6.split8
                                 ;     422 			pxNewQueue->xTxLock = queueUNLOCKED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",422
0000014A EC01                    		MOV.L [R0], R1
0000014C F91612FF                		MOV.L #0FFFFFFFFH, 48H[R1]
00000150                         L63:	; bb6.split9
                                 ;     423 
                                 ;     424 			#if ( configUSE_TRACE_FACILITY == 1 )
                                 ;     425 			{
                                 ;     426 				pxNewQueue->ucQueueType = ucQueueType;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",426
00000150 B289                    		MOVU.B 0BH[R0], R1
00000152 EC02                    		MOV.L [R0], R2
00000154 C72150                  		MOV.B R1, 50H[R2]
00000157                         L64:	; bb6.split10
                                 ;     427 			}
                                 ;     428 			#endif
                                 ;     429 
                                 ;     430 			#if ( configUSE_QUEUE_SETS == 1 )
                                 ;     431 			{
                                 ;     432 				pxNewQueue->pxQueueSetContainer = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",432
00000157 EC01                    		MOV.L [R0], R1
00000159 3E9500                  		MOV.L #00000000H, 54H[R1]
0000015C                         L65:	; bb6.split11
                                 ;     433 			}
                                 ;     434 			#endif
                                 ;     435 
                                 ;     436 			/* Ensure the event queues start with the correct state. */
                                 ;     437 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",437
0000015C EC01                    		MOV.L [R0], R1
0000015E 711110                  		ADD #10H, R1
00000161 05rrrrrr             A  		BSR _vListInitialise
00000165                         L66:	; bb6.split12
                                 ;     438 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",438
00000165 EC01                    		MOV.L [R0], R1
00000167 711124                  		ADD #24H, R1
0000016A 05rrrrrr             A  		BSR _vListInitialise
0000016E                         L67:	; bb6.split13
                                 ;     439 
                                 ;     440 			traceCREATE_MUTEX( pxNewQueue );
                                 ;     441 
                                 ;     442 			/* Start with the semaphore in the expected state. */
                                 ;     443 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",443
0000016E EC01                    		MOV.L [R0], R1
00000170 6602                    		MOV.L #00000000H, R2
00000172 EF23                    		MOV.L R2, R3
00000174 EF24                    		MOV.L R2, R4
00000176 39rrrr               W  		BSR _xQueueGenericSend
00000179                         L68:	; bb43
                                 ;     444 		}
                                 ;     445 		else
                                 ;     446 		{
                                 ;     447 			traceCREATE_MUTEX_FAILED();
                                 ;     448 		}
                                 ;     449 
                                 ;     450 		configASSERT( pxNewQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",450
00000179 EC01                    		MOV.L [R0], R1
0000017B 6101                    		CMP #00H, R1
0000017D 18                   S  		BNE L70
0000017E                         L69:	; bb44
0000017E 05rrrrrr             A  		BSR _vAssertCalled
00000182                         L70:	; bb50
                                 ;     451 		return pxNewQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",451
00000182 EC01                    		MOV.L [R0], R1
00000184 A009                    		MOV.L R1, 04H[R0]
00000186                         L71:	; bb50.split
                                 ;     452 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",452
00000186 6703                    		RTSD #0CH
00000188                         _xQueueGiveMutexRecursive:
                                 		.STACK	_xQueueGiveMutexRecursive=24
                                 ;     453 
                                 ;     454 #endif /* configUSE_MUTEXES */
                                 ;     455 /*-----------------------------------------------------------*/
                                 ;     456 
                                 ;     457 #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
                                 ;     458 
                                 ;     459 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
                                 ;     460 	{
                                 ;     461 	void *pxReturn;
                                 ;     462 
                                 ;     463 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
                                 ;     464 		be called directly.  Note:  This is a good way of determining if the
                                 ;     465 		calling task is the mutex holder, but not a good way of determining the
                                 ;     466 		identity of the mutex holder, as the holder may change between the
                                 ;     467 		following critical section exiting and the function returning. */
                                 ;     468 		taskENTER_CRITICAL();
                                 ;     469 		{
                                 ;     470 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
                                 ;     471 			{
                                 ;     472 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
                                 ;     473 			}
                                 ;     474 			else
                                 ;     475 			{
                                 ;     476 				pxReturn = NULL;
                                 ;     477 			}
                                 ;     478 		}
                                 ;     479 		taskEXIT_CRITICAL();
                                 ;     480 
                                 ;     481 		return pxReturn;
                                 ;     482 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
                                 ;     483 
                                 ;     484 #endif
                                 ;     485 /*-----------------------------------------------------------*/
                                 ;     486 
                                 ;     487 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
                                 ;     488 
                                 ;     489 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",489
00000188 7EA6                    		PUSH.L R6
0000018A 7100F0                  		ADD #0FFFFFFF0H, R0
0000018D A089                    		MOV.L R1, 0CH[R0]
                                 ;     490 	{
                                 ;     491 	BaseType_t xReturn;
                                 ;     492 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",492
0000018F A009                    		MOV.L R1, 04H[R0]
00000191                         L73:	; entry.split
                                 ;     493 
                                 ;     494 		configASSERT( pxMutex );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",494
00000191 A809                    		MOV.L 04H[R0], R1
00000193 6101                    		CMP #00H, R1
00000195 18                   S  		BNE L75
00000196                         L74:	; bb6
00000196 05rrrrrr             A  		BSR _vAssertCalled
0000019A                         L75:	; bb11
                                 ;     495 
                                 ;     496 		/* If this is the task that holds the mutex then pxMutexHolder will not
                                 ;     497 		change outside of this task.  If this task does not hold the mutex then
                                 ;     498 		pxMutexHolder can never coincidentally equal the tasks handle, and as
                                 ;     499 		this is the only condition we are interested in it does not matter if
                                 ;     500 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
                                 ;     501 		mutual exclusion is required to test the pxMutexHolder variable. */
                                 ;     502 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",502
0000019A A809                    		MOV.L 04H[R0], R1
0000019C A81E                    		MOV.L 04H[R1], R6
0000019E 05rrrrrr             A  		BSR _xTaskGetCurrentTaskHandle
000001A2 4761                    		CMP R6, R1
000001A4 21rr                    		BNE L80
000001A6                         L76:	; bb12
                                 ;     503 		{
                                 ;     504 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
                                 ;     505 
                                 ;     506 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
                                 ;     507 			the task handle, therefore no underflow check is required.  Also,
                                 ;     508 			uxRecursiveCallCount is only modified by the mutex holder, and as
                                 ;     509 			there can only be one, no mutual exclusion is required to modify the
                                 ;     510 			uxRecursiveCallCount member. */
                                 ;     511 			( pxMutex->u.uxRecursiveCallCount )--;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",511
000001A6 A809                    		MOV.L 04H[R0], R1
000001A8 A89A                    		MOV.L 0CH[R1], R2
000001AA 6012                    		SUB #01H, R2
000001AC A09A                    		MOV.L R2, 0CH[R1]
000001AE                         L77:	; bb12.split
                                 ;     512 
                                 ;     513 			/* Have we unwound the call count? */
                                 ;     514 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",514
000001AE A809                    		MOV.L 04H[R0], R1
000001B0 A899                    		MOV.L 0CH[R1], R1
000001B2 6101                    		CMP #00H, R1
000001B4 21rr                    		BNE L79
000001B6                         L78:	; bb20
                                 ;     515 			{
                                 ;     516 				/* Return the mutex.  This will automatically unblock any other
                                 ;     517 				task that might be waiting to access the mutex. */
                                 ;     518 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",518
000001B6 A809                    		MOV.L 04H[R0], R1
000001B8 6602                    		MOV.L #00000000H, R2
000001BA EF23                    		MOV.L R2, R3
000001BC EF24                    		MOV.L R2, R4
000001BE 39rrrr               W  		BSR _xQueueGenericSend
000001C1                         L79:	; bb33
                                 ;     519 			}
                                 ;     520 			else
                                 ;     521 			{
                                 ;     522 				mtCOVERAGE_TEST_MARKER();
                                 ;     523 			}
                                 ;     524 
                                 ;     525 			xReturn = pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",525
000001C1 F80601                  		MOV.L #00000001H, [R0]
000001C4 08                   S  		BRA L81
000001C5                         L80:	; bb34
                                 ;     526 		}
                                 ;     527 		else
                                 ;     528 		{
                                 ;     529 			/* The mutex cannot be given because the calling task is not the
                                 ;     530 			holder. */
                                 ;     531 			xReturn = pdFAIL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",531
000001C5 F80600                  		MOV.L #00000000H, [R0]
000001C8                         L81:	; bb42
                                 ;     532 
                                 ;     533 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
                                 ;     534 		}
                                 ;     535 
                                 ;     536 		return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",536
000001C8 EC01                    		MOV.L [R0], R1
000001CA A081                    		MOV.L R1, 08H[R0]
000001CC                         L82:	; bb42.split
                                 ;     537 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",537
000001CC 3F6605                  		RTSD #14H, R6-R6
000001CF                         _xQueueTakeMutexRecursive:
                                 		.STACK	_xQueueTakeMutexRecursive=28
                                 ;     538 
                                 ;     539 #endif /* configUSE_RECURSIVE_MUTEXES */
                                 ;     540 /*-----------------------------------------------------------*/
                                 ;     541 
                                 ;     542 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
                                 ;     543 
                                 ;     544 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",544
000001CF 7EA6                    		PUSH.L R6
000001D1 7100EC                  		ADD #0FFFFFFECH, R0
000001D4 A101                    		MOV.L R1, 10H[R0]
000001D6 A08A                    		MOV.L R2, 0CH[R0]
                                 ;     545 	{
                                 ;     546 	BaseType_t xReturn;
                                 ;     547 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",547
000001D8 E5000401                		MOV.L 10H[R0], 04H[R0]
000001DC                         L84:	; entry.split
                                 ;     548 
                                 ;     549 		configASSERT( pxMutex );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",549
000001DC A809                    		MOV.L 04H[R0], R1
000001DE 6101                    		CMP #00H, R1
000001E0 18                   S  		BNE L86
000001E1                         L85:	; bb7
000001E1 05rrrrrr             A  		BSR _vAssertCalled
000001E5                         L86:	; bb12
                                 ;     550 
                                 ;     551 		/* Comments regarding mutual exclusion as per those within
                                 ;     552 		xQueueGiveMutexRecursive(). */
                                 ;     553 
                                 ;     554 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
                                 ;     555 
                                 ;     556 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",556
000001E5 A809                    		MOV.L 04H[R0], R1
000001E7 A81E                    		MOV.L 04H[R1], R6
000001E9 05rrrrrr             A  		BSR _xTaskGetCurrentTaskHandle
000001ED 4761                    		CMP R6, R1
000001EF A809                    		MOV.L 04H[R0], R1
000001F1 21rr                    		BNE L89
000001F3                         L87:	; bb13
                                 ;     557 		{
                                 ;     558 			( pxMutex->u.uxRecursiveCallCount )++;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",558
000001F3 A89A                    		MOV.L 0CH[R1], R2
000001F5 6212                    		ADD #01H, R2
000001F7 A09A                    		MOV.L R2, 0CH[R1]
000001F9                         L88:	; bb13.split
                                 ;     559 			xReturn = pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",559
000001F9 F80601                  		MOV.L #00000001H, [R0]
000001FC 2Err                 B  		BRA L92
000001FE                         L89:	; bb20
                                 ;     560 		}
                                 ;     561 		else
                                 ;     562 		{
                                 ;     563 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",563
000001FE A88B                    		MOV.L 0CH[R0], R3
00000200 6602                    		MOV.L #00000000H, R2
00000202 EF24                    		MOV.L R2, R4
00000204 39rrrr               W  		BSR _xQueueGenericReceive
00000207 E301                    		MOV.L R1, [R0]
00000209                         L90:	; bb20.split
                                 ;     564 
                                 ;     565 			/* pdPASS will only be returned if the mutex was successfully
                                 ;     566 			obtained.  The calling task may have entered the Blocked state
                                 ;     567 			before reaching here. */
                                 ;     568 			if( xReturn == pdPASS )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",568
00000209 EC01                    		MOV.L [R0], R1
0000020B 6111                    		CMP #01H, R1
0000020D 18                   S  		BNE L92
0000020E                         L91:	; bb26
                                 ;     569 			{
                                 ;     570 				( pxMutex->u.uxRecursiveCallCount )++;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",570
0000020E A809                    		MOV.L 04H[R0], R1
00000210 A89A                    		MOV.L 0CH[R1], R2
00000212 6212                    		ADD #01H, R2
00000214 A09A                    		MOV.L R2, 0CH[R1]
00000216                         L92:	; bb46
                                 ;     571 			}
                                 ;     572 			else
                                 ;     573 			{
                                 ;     574 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
                                 ;     575 			}
                                 ;     576 		}
                                 ;     577 
                                 ;     578 		return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",578
00000216 EC01                    		MOV.L [R0], R1
00000218 A081                    		MOV.L R1, 08H[R0]
0000021A                         L93:	; bb46.split
                                 ;     579 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",579
0000021A 3F6606                  		RTSD #18H, R6-R6
0000021D                         _xQueueCreateCountingSemaphore:
                                 		.STACK	_xQueueCreateCountingSemaphore=20
                                 ;     580 
                                 ;     581 #endif /* configUSE_RECURSIVE_MUTEXES */
                                 ;     582 /*-----------------------------------------------------------*/
                                 ;     583 
                                 ;     584 #if ( configUSE_COUNTING_SEMAPHORES == 1 )
                                 ;     585 
                                 ;     586 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",586
0000021D 7100F0                  		ADD #0FFFFFFF0H, R0
00000220 A089                    		MOV.L R1, 0CH[R0]
00000222 A082                    		MOV.L R2, 08H[R0]
                                 ;     587 	{
                                 ;     588 	QueueHandle_t xHandle;
                                 ;     589 
                                 ;     590 		configASSERT( uxMaxCount != 0 );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",590
00000224 A889                    		MOV.L 0CH[R0], R1
00000226 6101                    		CMP #00H, R1
00000228 18                   S  		BNE L96
00000229                         L95:	; bb4
00000229 05rrrrrr             A  		BSR _vAssertCalled
0000022D                         L96:	; bb11
                                 ;     591 		configASSERT( uxInitialCount <= uxMaxCount );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",591
0000022D A881                    		MOV.L 08H[R0], R1
0000022F 06850103                		CMP 0CH[R0].L, R1
00000233 25rr                    		BLEU L98
00000235                         L97:	; bb12
00000235 05rrrrrr             A  		BSR _vAssertCalled
00000239                         L98:	; bb20
                                 ;     592 
                                 ;     593 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",593
00000239 A889                    		MOV.L 0CH[R0], R1
0000023B 6623                    		MOV.L #00000002H, R3
0000023D 6602                    		MOV.L #00000000H, R2
0000023F 39rrrr               W  		BSR _xQueueGenericCreate
00000242 E301                    		MOV.L R1, [R0]
00000244                         L99:	; bb20.split
                                 ;     594 
                                 ;     595 		if( xHandle != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",595
00000244 EC01                    		MOV.L [R0], R1
00000246 6101                    		CMP #00H, R1
00000248 10                   S  		BEQ L101
00000249                         L100:	; bb24
                                 ;     596 		{
                                 ;     597 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",597
00000249 A881                    		MOV.L 08H[R0], R1
0000024B EC02                    		MOV.L [R0], R2
0000024D A3A1                    		MOV.L R1, 38H[R2]
0000024F                         L101:	; bb35
                                 ;     598 
                                 ;     599 			traceCREATE_COUNTING_SEMAPHORE();
                                 ;     600 		}
                                 ;     601 		else
                                 ;     602 		{
                                 ;     603 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
                                 ;     604 		}
                                 ;     605 
                                 ;     606 		configASSERT( xHandle );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",606
0000024F EC01                    		MOV.L [R0], R1
00000251 6101                    		CMP #00H, R1
00000253 18                   S  		BNE L103
00000254                         L102:	; bb36
00000254 05rrrrrr             A  		BSR _vAssertCalled
00000258                         L103:	; bb41
                                 ;     607 		return xHandle;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",607
00000258 EC01                    		MOV.L [R0], R1
0000025A A009                    		MOV.L R1, 04H[R0]
0000025C                         L104:	; bb41.split
                                 ;     608 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",608
0000025C 6704                    		RTSD #10H
0000025E                         _xQueueGenericSend:
                                 		.STACK	_xQueueGenericSend=52
                                 ;     609 
                                 ;     610 #endif /* configUSE_COUNTING_SEMAPHORES */
                                 ;     611 /*-----------------------------------------------------------*/
                                 ;     612 
                                 ;     613 BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",613
0000025E 7100D0                  		ADD #0FFFFFFD0H, R0
00000261 A289                    		MOV.L R1, 2CH[R0]
00000263 A282                    		MOV.L R2, 28H[R0]
00000265 A20B                    		MOV.L R3, 24H[R0]
00000267 A204                    		MOV.L R4, 20H[R0]
                                 ;     614 {
                                 ;     615 BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",615
00000269 3E0200                  		MOV.L #00000000H, 08H[R0]
0000026C                         L106:	; entry.split
                                 ;     616 TimeOut_t xTimeOut;
                                 ;     617 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",617
0000026C E5000B06                		MOV.L 2CH[R0], 18H[R0]
00000270                         L107:	; entry.split1
                                 ;     618 
                                 ;     619 	configASSERT( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",619
00000270 A981                    		MOV.L 18H[R0], R1
00000272 6101                    		CMP #00H, R1
00000274 18                   S  		BNE L109
00000275                         L108:	; bb11
00000275 05rrrrrr             A  		BSR _vAssertCalled
00000279                         L109:	; bb16
                                 ;     620 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",620
00000279 AA81                    		MOV.L 28H[R0], R1
0000027B 6101                    		CMP #00H, R1
0000027D 10                   S  		BEQ L111
0000027E 2Err                 B  		BRA L113
00000280                         L110:	; bb17
00000280 05rrrrrr             A  		BSR _vAssertCalled
00000284 2Err                 B  		BRA L118
00000286                         L111:	; bb21
00000286 A981                    		MOV.L 18H[R0], R1
00000288 AC11                    		MOV.L 40H[R1], R1
0000028A 6101                    		CMP #00H, R1
0000028C 10                   S  		BEQ L113
0000028D                         L112:	; bb27
0000028D F80601                  		MOV.L #00000001H, [R0]
00000290 08                   S  		BRA L114
00000291                         L113:	; bb28
00000291 F80600                  		MOV.L #00000000H, [R0]
00000294                         L114:	; bb29
00000294 EC01                    		MOV.L [R0], R1
00000296 6101                    		CMP #00H, R1
00000298 10                   S  		BEQ L116
00000299                         L115:	; bb33
00000299 F80600                  		MOV.L #00000000H, [R0]
0000029C 08                   S  		BRA L117
0000029D                         L116:	; bb34
0000029D F80601                  		MOV.L #00000001H, [R0]
000002A0                         L117:	; bb35
000002A0 EC01                    		MOV.L [R0], R1
000002A2 6101                    		CMP #00H, R1
000002A4 20rr                    		BEQ L110
000002A6                         L118:	; bb42
                                 ;     621 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",621
000002A6 AA01                    		MOV.L 20H[R0], R1
000002A8 6121                    		CMP #02H, R1
000002AA 10                   S  		BEQ L120
000002AB 2Err                 B  		BRA L122
000002AD                         L119:	; bb43
000002AD 05rrrrrr             A  		BSR _vAssertCalled
000002B1 2Err                 B  		BRA L127
000002B3                         L120:	; bb47
000002B3 A981                    		MOV.L 18H[R0], R1
000002B5 AB99                    		MOV.L 3CH[R1], R1
000002B7 6111                    		CMP #01H, R1
000002B9 10                   S  		BEQ L122
000002BA                         L121:	; bb53
000002BA F80601                  		MOV.L #00000001H, [R0]
000002BD 08                   S  		BRA L123
000002BE                         L122:	; bb54
000002BE F80600                  		MOV.L #00000000H, [R0]
000002C1                         L123:	; bb55
000002C1 EC01                    		MOV.L [R0], R1
000002C3 6101                    		CMP #00H, R1
000002C5 10                   S  		BEQ L125
000002C6                         L124:	; bb59
000002C6 F80600                  		MOV.L #00000000H, [R0]
000002C9 08                   S  		BRA L126
000002CA                         L125:	; bb60
000002CA F80601                  		MOV.L #00000001H, [R0]
000002CD                         L126:	; bb61
000002CD EC01                    		MOV.L [R0], R1
000002CF 6101                    		CMP #00H, R1
000002D1 20rr                    		BEQ L119
000002D3                         L127:	; bb68
                                 ;     622 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
                                 ;     623 	{
                                 ;     624 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",624
000002D3 05rrrrrr             A  		BSR _xTaskGetSchedulerState
000002D7 6101                    		CMP #00H, R1
000002D9 10                   S  		BEQ L129
000002DA 2Err                 B  		BRA L131
000002DC                         L128:	; bb69
000002DC 05rrrrrr             A  		BSR _vAssertCalled
000002E0 38rrrr               W  		BRA L176
000002E3                         L129:	; bb73
000002E3 AA09                    		MOV.L 24H[R0], R1
000002E5 6101                    		CMP #00H, R1
000002E7 10                   S  		BEQ L131
000002E8                         L130:	; bb77
000002E8 F80601                  		MOV.L #00000001H, [R0]
000002EB 08                   S  		BRA L132
000002EC                         L131:	; bb78
000002EC F80600                  		MOV.L #00000000H, [R0]
000002EF                         L132:	; bb79
000002EF EC01                    		MOV.L [R0], R1
000002F1 6101                    		CMP #00H, R1
000002F3 10                   S  		BEQ L134
000002F4                         L133:	; bb83
000002F4 F80600                  		MOV.L #00000000H, [R0]
000002F7 08                   S  		BRA L135
000002F8                         L134:	; bb84
000002F8 F80601                  		MOV.L #00000001H, [R0]
000002FB                         L135:	; bb85
000002FB EC01                    		MOV.L [R0], R1
000002FD 6101                    		CMP #00H, R1
000002FF 20rr                    		BEQ L128
00000301 38rrrr               W  		BRA L176
00000304                         L136:	; bb94
                                 ;     625 	}
                                 ;     626 	#endif
                                 ;     627 
                                 ;     628 
                                 ;     629 	/* This function relaxes the coding standard somewhat to allow return
                                 ;     630 	statements within the function itself.  This is done in the interest
                                 ;     631 	of execution time efficiency. */
                                 ;     632 	for( ;; )
                                 ;     633 	{
                                 ;     634 		taskENTER_CRITICAL();
                                 ;     635 		{
                                 ;     636 			/* Is there room on the queue now?  The running task must be the
                                 ;     637 			highest priority task wanting to access the queue.  If the head item
                                 ;     638 			in the queue is to be overwritten then it does not matter if the
                                 ;     639 			queue is full. */
                                 ;     640 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
                                 ;     641 			{
                                 ;     642 				traceQUEUE_SEND( pxQueue );
                                 ;     643 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",643
00000304 AA03                    		MOV.L 20H[R0], R3
00000306 AA82                    		MOV.L 28H[R0], R2
00000308 A981                    		MOV.L 18H[R0], R1
0000030A 39rrrr               W  		BSR __$prvCopyDataToQueue
0000030D A089                    		MOV.L R1, 0CH[R0]
0000030F                         L137:	; bb94.split
                                 ;     644 
                                 ;     645 				#if ( configUSE_QUEUE_SETS == 1 )
                                 ;     646 				{
                                 ;     647 					if( pxQueue->pxQueueSetContainer != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",647
0000030F A981                    		MOV.L 18H[R0], R1
00000311 AD1A                    		MOV.L 54H[R1], R2
00000313 6102                    		CMP #00H, R2
00000315 20rr                    		BEQ L140
00000317                         L138:	; bb101
                                 ;     648 					{
                                 ;     649 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",649
00000317 AA02                    		MOV.L 20H[R0], R2
00000319 39rrrr               W  		BSR __$prvNotifyQueueSetContainer
0000031C 6111                    		CMP #01H, R1
0000031E 21rr                    		BNE L145
00000320                         L139:	; bb102
                                 ;     650 						{
                                 ;     651 							/* The queue is a member of a queue set, and posting
                                 ;     652 							to the queue set caused a higher priority task to
                                 ;     653 							unblock. A context switch is required. */
                                 ;     654 							queueYIELD_IF_USING_PREEMPTION();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",654
                                 		._LINE_TOP  inline_asm
                                  
00000320 7EA5                    	PUSH.L R5
                                 	 
00000322 FB5EE07208              	MOV.L #553696, R5
00000327 F85401                  	MOV.B #1, [R5]
                                 	 
0000032A EC55                    	MOV.L [R5], R5
                                 	 
0000032C 7EB5                    	POP R5
                                 		._LINE_END  inline_asm
0000032E 2Err                 B  		BRA L145
00000330                         L140:	; bb112
                                 ;     655 						}
                                 ;     656 						else
                                 ;     657 						{
                                 ;     658 							mtCOVERAGE_TEST_MARKER();
                                 ;     659 						}
                                 ;     660 					}
                                 ;     661 					else
                                 ;     662 					{
                                 ;     663 						/* If there was a task waiting for data to arrive on the
                                 ;     664 						queue then unblock it now. */
                                 ;     665 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",665
00000330 AA19                    		MOV.L 24H[R1], R1
00000332 6101                    		CMP #00H, R1
00000334 20rr                    		BEQ L143
00000336                         L141:	; bb114
                                 ;     666 						{
                                 ;     667 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",667
00000336 A981                    		MOV.L 18H[R0], R1
00000338 711124                  		ADD #24H, R1
0000033B 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
0000033F 6111                    		CMP #01H, R1
00000341 21rr                    		BNE L145
00000343                         L142:	; bb115
                                 ;     668 							{
                                 ;     669 								/* The unblocked task has a priority higher than
                                 ;     670 								our own so yield immediately.  Yes it is ok to
                                 ;     671 								do this from within the critical section - the
                                 ;     672 								kernel takes care of that. */
                                 ;     673 								queueYIELD_IF_USING_PREEMPTION();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",673
                                 		._LINE_TOP  inline_asm
                                  
00000343 7EA5                    	PUSH.L R5
                                 	 
00000345 FB5EE07208              	MOV.L #553696, R5
0000034A F85401                  	MOV.B #1, [R5]
                                 	 
0000034D EC55                    	MOV.L [R5], R5
                                 	 
0000034F 7EB5                    	POP R5
                                 		._LINE_END  inline_asm
00000351 2Err                 B  		BRA L145
00000353                         L143:	; bb125
                                 ;     674 							}
                                 ;     675 							else
                                 ;     676 							{
                                 ;     677 								mtCOVERAGE_TEST_MARKER();
                                 ;     678 							}
                                 ;     679 						}
                                 ;     680 						else if( xYieldRequired != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",680
00000353 A889                    		MOV.L 0CH[R0], R1
00000355 6101                    		CMP #00H, R1
00000357 20rr                    		BEQ L145
00000359                         L144:	; bb126
                                 ;     681 						{
                                 ;     682 							/* This path is a special case that will only get
                                 ;     683 							executed if the task was holding multiple mutexes
                                 ;     684 							and the mutexes were given back in an order that is
                                 ;     685 							different to that in which they were taken. */
                                 ;     686 							queueYIELD_IF_USING_PREEMPTION();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",686
                                 		._LINE_TOP  inline_asm
                                  
00000359 7EA5                    	PUSH.L R5
                                 	 
0000035B FB5EE07208              	MOV.L #553696, R5
00000360 F85401                  	MOV.B #1, [R5]
                                 	 
00000363 EC55                    	MOV.L [R5], R5
                                 	 
00000365 7EB5                    	POP R5
                                 		._LINE_END  inline_asm
00000367                         L145:	; bb149
                                 ;     687 						}
                                 ;     688 						else
                                 ;     689 						{
                                 ;     690 							mtCOVERAGE_TEST_MARKER();
                                 ;     691 						}
                                 ;     692 					}
                                 ;     693 				}
                                 ;     694 				#else /* configUSE_QUEUE_SETS */
                                 ;     695 				{
                                 ;     696 					/* If there was a task waiting for data to arrive on the
                                 ;     697 					queue then unblock it now. */
                                 ;     698 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 ;     699 					{
                                 ;     700 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
                                 ;     701 						{
                                 ;     702 							/* The unblocked task has a priority higher than
                                 ;     703 							our own so yield immediately.  Yes it is ok to do
                                 ;     704 							this from within the critical section - the kernel
                                 ;     705 							takes care of that. */
                                 ;     706 							queueYIELD_IF_USING_PREEMPTION();
                                 ;     707 						}
                                 ;     708 						else
                                 ;     709 						{
                                 ;     710 							mtCOVERAGE_TEST_MARKER();
                                 ;     711 						}
                                 ;     712 					}
                                 ;     713 					else if( xYieldRequired != pdFALSE )
                                 ;     714 					{
                                 ;     715 						/* This path is a special case that will only get
                                 ;     716 						executed if the task was holding multiple mutexes and
                                 ;     717 						the mutexes were given back in an order that is
                                 ;     718 						different to that in which they were taken. */
                                 ;     719 						queueYIELD_IF_USING_PREEMPTION();
                                 ;     720 					}
                                 ;     721 					else
                                 ;     722 					{
                                 ;     723 						mtCOVERAGE_TEST_MARKER();
                                 ;     724 					}
                                 ;     725 				}
                                 ;     726 				#endif /* configUSE_QUEUE_SETS */
                                 ;     727 
                                 ;     728 				taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",728
00000367 05rrrrrr             A  		BSR _vTaskExitCritical
0000036B                         L146:	; bb149.split
                                 ;     729 				return pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",729
0000036B 3E0101                  		MOV.L #00000001H, 04H[R0]
0000036E 38rrrr               W  		BRA L178
00000371                         L147:	; bb152
                                 ;     730 			}
                                 ;     731 			else
                                 ;     732 			{
                                 ;     733 				if( xTicksToWait == ( TickType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",733
00000371 AA09                    		MOV.L 24H[R0], R1
00000373 6101                    		CMP #00H, R1
00000375 21rr                    		BNE L150
00000377                         L148:	; bb153
                                 ;     734 				{
                                 ;     735 					/* The queue was full and no block time is specified (or
                                 ;     736 					the block time has expired) so leave now. */
                                 ;     737 					taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",737
00000377 05rrrrrr             A  		BSR _vTaskExitCritical
0000037B                         L149:	; bb153.split
                                 ;     738 
                                 ;     739 					/* Return to the original privilege level before exiting
                                 ;     740 					the function. */
                                 ;     741 					traceQUEUE_SEND_FAILED( pxQueue );
                                 ;     742 					return errQUEUE_FULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",742
0000037B 3E0100                  		MOV.L #00000000H, 04H[R0]
0000037E 38rrrr               W  		BRA L178
00000381                         L150:	; bb156
                                 ;     743 				}
                                 ;     744 				else if( xEntryTimeSet == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",744
00000381 A881                    		MOV.L 08H[R0], R1
00000383 6101                    		CMP #00H, R1
00000385 21rr                    		BNE L157
00000387                         L151:	; bb157
00000387 710110                  		ADD #10H, R0, R1
                                 ;     745 				{
                                 ;     746 					/* The queue was full and a block time was specified so
                                 ;     747 					configure the timeout structure. */
                                 ;     748 					vTaskSetTimeOutState( &xTimeOut );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",748
0000038A 05rrrrrr             A  		BSR _vTaskSetTimeOutState
0000038E                         L152:	; bb157.split
                                 ;     749 					xEntryTimeSet = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",749
0000038E 3E0201                  		MOV.L #00000001H, 08H[R0]
00000391 2Err                 B  		BRA L157
00000393                         L153:	; bb177
00000393 AA01                    		MOV.L 20H[R0], R1
00000395 6121                    		CMP #02H, R1
00000397 18                   S  		BNE L155
00000398                         L154:	; bb181
00000398 F80601                  		MOV.L #00000001H, [R0]
0000039B 08                   S  		BRA L156
0000039C                         L155:	; bb182
0000039C F80600                  		MOV.L #00000000H, [R0]
0000039F                         L156:	; bb183
0000039F EC01                    		MOV.L [R0], R1
000003A1 6101                    		CMP #00H, R1
000003A3 3Brrrr               W  		BNE L136
000003A6 2Err                 B  		BRA L147
000003A8                         L157:	; bb188
                                 ;     750 				}
                                 ;     751 				else
                                 ;     752 				{
                                 ;     753 					/* Entry time was already set. */
                                 ;     754 					mtCOVERAGE_TEST_MARKER();
                                 ;     755 				}
                                 ;     756 			}
                                 ;     757 		}
                                 ;     758 		taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",758
000003A8 05rrrrrr             A  		BSR _vTaskExitCritical
000003AC                         L158:	; bb188.split
                                 ;     759 
                                 ;     760 		/* Interrupts and other tasks can send to and receive from the queue
                                 ;     761 		now the critical section has been exited. */
                                 ;     762 
                                 ;     763 		vTaskSuspendAll();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",763
000003AC 05rrrrrr             A  		BSR _vTaskSuspendAll
000003B0                         L159:	; bb188.split2
                                 ;     764 		prvLockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",764
000003B0 05rrrrrr             A  		BSR _vTaskEnterCritical
000003B4                         L160:	; bb188.split3
000003B4 A981                    		MOV.L 18H[R0], R1
000003B6 AC19                    		MOV.L 44H[R1], R1
000003B8 7501FF                  		CMP #0FFFFFFFFH, R1
000003BB 18                   S  		BNE L162
000003BC                         L161:	; bb190
000003BC A981                    		MOV.L 18H[R0], R1
000003BE 3E9100                  		MOV.L #00000000H, 44H[R1]
000003C1                         L162:	; bb200
000003C1 A981                    		MOV.L 18H[R0], R1
000003C3 AC91                    		MOV.L 48H[R1], R1
000003C5 7501FF                  		CMP #0FFFFFFFFH, R1
000003C8 18                   S  		BNE L164
000003C9                         L163:	; bb201
000003C9 A981                    		MOV.L 18H[R0], R1
000003CB 3E9200                  		MOV.L #00000000H, 48H[R1]
000003CE                         L164:	; bb210
000003CE 05rrrrrr             A  		BSR _vTaskExitCritical
000003D2                         L165:	; bb210.split
000003D2 710224                  		ADD #24H, R0, R2
000003D5 710110                  		ADD #10H, R0, R1
                                 ;     765 
                                 ;     766 		/* Update the timeout state to see if it has expired yet. */
                                 ;     767 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",767
000003D8 05rrrrrr             A  		BSR _xTaskCheckForTimeOut
000003DC 6101                    		CMP #00H, R1
000003DE A981                    		MOV.L 18H[R0], R1
000003E0 21rr                    		BNE L173
000003E2                         L166:	; bb213
                                 ;     768 		{
                                 ;     769 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",769
000003E2 39rrrr               W  		BSR __$prvIsQueueFull
000003E5 6101                    		CMP #00H, R1
000003E7 A981                    		MOV.L 18H[R0], R1
000003E9 20rr                    		BEQ L171
000003EB                         L167:	; bb214
                                 ;     770 			{
                                 ;     771 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                                 ;     772 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",772
000003EB AA0A                    		MOV.L 24H[R0], R2
000003ED 711110                  		ADD #10H, R1
000003F0 05rrrrrr             A  		BSR _vTaskPlaceOnEventList
000003F4                         L168:	; bb214.split
                                 ;     773 
                                 ;     774 				/* Unlocking the queue means queue events can effect the
                                 ;     775 				event list.  It is possible	that interrupts occurring now
                                 ;     776 				remove this task from the event	list again - but as the
                                 ;     777 				scheduler is suspended the task will go onto the pending
                                 ;     778 				ready last instead of the actual ready list. */
                                 ;     779 				prvUnlockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",779
000003F4 A981                    		MOV.L 18H[R0], R1
000003F6 39rrrr               W  		BSR __$prvUnlockQueue
000003F9                         L169:	; bb214.split4
                                 ;     780 
                                 ;     781 				/* Resuming the scheduler will move tasks from the pending
                                 ;     782 				ready list into the ready list - so it is feasible that this
                                 ;     783 				task is already in a ready list before it yields - in which
                                 ;     784 				case the yield will not cause a context switch unless there
                                 ;     785 				is also a higher priority task in the pending ready list. */
                                 ;     786 				if( xTaskResumeAll() == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",786
000003F9 05rrrrrr             A  		BSR _xTaskResumeAll
000003FD 6101                    		CMP #00H, R1
000003FF 21rr                    		BNE L176
00000401                         L170:	; bb220
                                 ;     787 				{
                                 ;     788 					portYIELD_WITHIN_API();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",788
                                 		._LINE_TOP  inline_asm
                                  
00000401 7EA5                    	PUSH.L R5
                                 	 
00000403 FB5EE07208              	MOV.L #553696, R5
00000408 F85401                  	MOV.B #1, [R5]
                                 	 
0000040B EC55                    	MOV.L [R5], R5
                                 	 
0000040D 7EB5                    	POP R5
                                 		._LINE_END  inline_asm
0000040F 2Err                 B  		BRA L176
00000411                         L171:	; bb226
                                 ;     789 				}
                                 ;     790 			}
                                 ;     791 			else
                                 ;     792 			{
                                 ;     793 				/* Try again. */
                                 ;     794 				prvUnlockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",794
00000411 39rrrr               W  		BSR __$prvUnlockQueue
00000414                         L172:	; bb226.split
                                 ;     795 				( void ) xTaskResumeAll();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",795
00000414 05rrrrrr             A  		BSR _xTaskResumeAll
00000418 2Err                 B  		BRA L176
0000041A                         L173:	; bb235
                                 ;     796 			}
                                 ;     797 		}
                                 ;     798 		else
                                 ;     799 		{
                                 ;     800 			/* The timeout has expired. */
                                 ;     801 			prvUnlockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",801
0000041A 39rrrr               W  		BSR __$prvUnlockQueue
0000041D                         L174:	; bb235.split
                                 ;     802 			( void ) xTaskResumeAll();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",802
0000041D 05rrrrrr             A  		BSR _xTaskResumeAll
00000421                         L175:	; bb235.split5
                                 ;     803 
                                 ;     804 			/* Return to the original privilege level before exiting the
                                 ;     805 			function. */
                                 ;     806 			traceQUEUE_SEND_FAILED( pxQueue );
                                 ;     807 			return errQUEUE_FULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",807
00000421 3E0100                  		MOV.L #00000000H, 04H[R0]
00000424 2Err                 B  		BRA L178
00000426                         L176:	; bb244.split
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",634
00000426 05rrrrrr             A  		BSR _vTaskEnterCritical
0000042A                         L177:	; bb244.split6
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",640
0000042A A981                    		MOV.L 18H[R0], R1
0000042C AB91                    		MOV.L 38H[R1], R1
0000042E A982                    		MOV.L 18H[R0], R2
00000430 0685210F                		CMP 3CH[R2].L, R1
00000434 22rr                  * 		BLTU L154
         38rrrr                  
00000439 38rrrr               W  		BRA L153
0000043C                         L178:	; bb246
0000043C A809                    		MOV.L 04H[R0], R1
0000043E A189                    		MOV.L R1, 1CH[R0]
                                 ;     808 		}
                                 ;     809 	}
                                 ;     810 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",810
00000440 670C                    		RTSD #30H
00000442                         _xQueueGenericSendFromISR:
                                 		.STACK	_xQueueGenericSendFromISR=40
                                 ;     811 /*-----------------------------------------------------------*/
                                 ;     812 
                                 ;     813 #if ( configUSE_ALTERNATIVE_API == 1 )
                                 ;     814 
                                 ;     815 	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition )
                                 ;     816 	{
                                 ;     817 	BaseType_t xEntryTimeSet = pdFALSE;
                                 ;     818 	TimeOut_t xTimeOut;
                                 ;     819 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 ;     820 
                                 ;     821 		configASSERT( pxQueue );
                                 ;     822 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
                                 ;     823 
                                 ;     824 		for( ;; )
                                 ;     825 		{
                                 ;     826 			taskENTER_CRITICAL();
                                 ;     827 			{
                                 ;     828 				/* Is there room on the queue now?  To be running we must be
                                 ;     829 				the highest priority task wanting to access the queue. */
                                 ;     830 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
                                 ;     831 				{
                                 ;     832 					traceQUEUE_SEND( pxQueue );
                                 ;     833 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
                                 ;     834 
                                 ;     835 					/* If there was a task waiting for data to arrive on the
                                 ;     836 					queue then unblock it now. */
                                 ;     837 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 ;     838 					{
                                 ;     839 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
                                 ;     840 						{
                                 ;     841 							/* The unblocked task has a priority higher than
                                 ;     842 							our own so yield immediately. */
                                 ;     843 							portYIELD_WITHIN_API();
                                 ;     844 						}
                                 ;     845 						else
                                 ;     846 						{
                                 ;     847 							mtCOVERAGE_TEST_MARKER();
                                 ;     848 						}
                                 ;     849 					}
                                 ;     850 					else
                                 ;     851 					{
                                 ;     852 						mtCOVERAGE_TEST_MARKER();
                                 ;     853 					}
                                 ;     854 
                                 ;     855 					taskEXIT_CRITICAL();
                                 ;     856 					return pdPASS;
                                 ;     857 				}
                                 ;     858 				else
                                 ;     859 				{
                                 ;     860 					if( xTicksToWait == ( TickType_t ) 0 )
                                 ;     861 					{
                                 ;     862 						taskEXIT_CRITICAL();
                                 ;     863 						return errQUEUE_FULL;
                                 ;     864 					}
                                 ;     865 					else if( xEntryTimeSet == pdFALSE )
                                 ;     866 					{
                                 ;     867 						vTaskSetTimeOutState( &xTimeOut );
                                 ;     868 						xEntryTimeSet = pdTRUE;
                                 ;     869 					}
                                 ;     870 				}
                                 ;     871 			}
                                 ;     872 			taskEXIT_CRITICAL();
                                 ;     873 
                                 ;     874 			taskENTER_CRITICAL();
                                 ;     875 			{
                                 ;     876 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
                                 ;     877 				{
                                 ;     878 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
                                 ;     879 					{
                                 ;     880 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                                 ;     881 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
                                 ;     882 						portYIELD_WITHIN_API();
                                 ;     883 					}
                                 ;     884 					else
                                 ;     885 					{
                                 ;     886 						mtCOVERAGE_TEST_MARKER();
                                 ;     887 					}
                                 ;     888 				}
                                 ;     889 				else
                                 ;     890 				{
                                 ;     891 					taskEXIT_CRITICAL();
                                 ;     892 					traceQUEUE_SEND_FAILED( pxQueue );
                                 ;     893 					return errQUEUE_FULL;
                                 ;     894 				}
                                 ;     895 			}
                                 ;     896 			taskEXIT_CRITICAL();
                                 ;     897 		}
                                 ;     898 	}
                                 ;     899 
                                 ;     900 #endif /* configUSE_ALTERNATIVE_API */
                                 ;     901 /*-----------------------------------------------------------*/
                                 ;     902 
                                 ;     903 #if ( configUSE_ALTERNATIVE_API == 1 )
                                 ;     904 
                                 ;     905 	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking )
                                 ;     906 	{
                                 ;     907 	BaseType_t xEntryTimeSet = pdFALSE;
                                 ;     908 	TimeOut_t xTimeOut;
                                 ;     909 	int8_t *pcOriginalReadPosition;
                                 ;     910 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 ;     911 
                                 ;     912 		configASSERT( pxQueue );
                                 ;     913 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
                                 ;     914 
                                 ;     915 		for( ;; )
                                 ;     916 		{
                                 ;     917 			taskENTER_CRITICAL();
                                 ;     918 			{
                                 ;     919 				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
                                 ;     920 				{
                                 ;     921 					/* Remember our read position in case we are just peeking. */
                                 ;     922 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
                                 ;     923 
                                 ;     924 					prvCopyDataFromQueue( pxQueue, pvBuffer );
                                 ;     925 
                                 ;     926 					if( xJustPeeking == pdFALSE )
                                 ;     927 					{
                                 ;     928 						traceQUEUE_RECEIVE( pxQueue );
                                 ;     929 
                                 ;     930 						/* Data is actually being removed (not just peeked). */
                                 ;     931 						--( pxQueue->uxMessagesWaiting );
                                 ;     932 
                                 ;     933 						#if ( configUSE_MUTEXES == 1 )
                                 ;     934 						{
                                 ;     935 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
                                 ;     936 							{
                                 ;     937 								/* Record the information required to implement
                                 ;     938 								priority inheritance should it become necessary. */
                                 ;     939 								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
                                 ;     940 							}
                                 ;     941 							else
                                 ;     942 							{
                                 ;     943 								mtCOVERAGE_TEST_MARKER();
                                 ;     944 							}
                                 ;     945 						}
                                 ;     946 						#endif
                                 ;     947 
                                 ;     948 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
                                 ;     949 						{
                                 ;     950 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
                                 ;     951 							{
                                 ;     952 								portYIELD_WITHIN_API();
                                 ;     953 							}
                                 ;     954 							else
                                 ;     955 							{
                                 ;     956 								mtCOVERAGE_TEST_MARKER();
                                 ;     957 							}
                                 ;     958 						}
                                 ;     959 					}
                                 ;     960 					else
                                 ;     961 					{
                                 ;     962 						traceQUEUE_PEEK( pxQueue );
                                 ;     963 
                                 ;     964 						/* The data is not being removed, so reset our read
                                 ;     965 						pointer. */
                                 ;     966 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
                                 ;     967 
                                 ;     968 						/* The data is being left in the queue, so see if there are
                                 ;     969 						any other tasks waiting for the data. */
                                 ;     970 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 ;     971 						{
                                 ;     972 							/* Tasks that are removed from the event list will get added to
                                 ;     973 							the pending ready list as the scheduler is still suspended. */
                                 ;     974 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 ;     975 							{
                                 ;     976 								/* The task waiting has a higher priority than this task. */
                                 ;     977 								portYIELD_WITHIN_API();
                                 ;     978 							}
                                 ;     979 							else
                                 ;     980 							{
                                 ;     981 								mtCOVERAGE_TEST_MARKER();
                                 ;     982 							}
                                 ;     983 						}
                                 ;     984 						else
                                 ;     985 						{
                                 ;     986 							mtCOVERAGE_TEST_MARKER();
                                 ;     987 						}
                                 ;     988 					}
                                 ;     989 
                                 ;     990 					taskEXIT_CRITICAL();
                                 ;     991 					return pdPASS;
                                 ;     992 				}
                                 ;     993 				else
                                 ;     994 				{
                                 ;     995 					if( xTicksToWait == ( TickType_t ) 0 )
                                 ;     996 					{
                                 ;     997 						taskEXIT_CRITICAL();
                                 ;     998 						traceQUEUE_RECEIVE_FAILED( pxQueue );
                                 ;     999 						return errQUEUE_EMPTY;
                                 ;    1000 					}
                                 ;    1001 					else if( xEntryTimeSet == pdFALSE )
                                 ;    1002 					{
                                 ;    1003 						vTaskSetTimeOutState( &xTimeOut );
                                 ;    1004 						xEntryTimeSet = pdTRUE;
                                 ;    1005 					}
                                 ;    1006 				}
                                 ;    1007 			}
                                 ;    1008 			taskEXIT_CRITICAL();
                                 ;    1009 
                                 ;    1010 			taskENTER_CRITICAL();
                                 ;    1011 			{
                                 ;    1012 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
                                 ;    1013 				{
                                 ;    1014 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
                                 ;    1015 					{
                                 ;    1016 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                                 ;    1017 
                                 ;    1018 						#if ( configUSE_MUTEXES == 1 )
                                 ;    1019 						{
                                 ;    1020 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
                                 ;    1021 							{
                                 ;    1022 								taskENTER_CRITICAL();
                                 ;    1023 								{
                                 ;    1024 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
                                 ;    1025 								}
                                 ;    1026 								taskEXIT_CRITICAL();
                                 ;    1027 							}
                                 ;    1028 							else
                                 ;    1029 							{
                                 ;    1030 								mtCOVERAGE_TEST_MARKER();
                                 ;    1031 							}
                                 ;    1032 						}
                                 ;    1033 						#endif
                                 ;    1034 
                                 ;    1035 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
                                 ;    1036 						portYIELD_WITHIN_API();
                                 ;    1037 					}
                                 ;    1038 					else
                                 ;    1039 					{
                                 ;    1040 						mtCOVERAGE_TEST_MARKER();
                                 ;    1041 					}
                                 ;    1042 				}
                                 ;    1043 				else
                                 ;    1044 				{
                                 ;    1045 					taskEXIT_CRITICAL();
                                 ;    1046 					traceQUEUE_RECEIVE_FAILED( pxQueue );
                                 ;    1047 					return errQUEUE_EMPTY;
                                 ;    1048 				}
                                 ;    1049 			}
                                 ;    1050 			taskEXIT_CRITICAL();
                                 ;    1051 		}
                                 ;    1052 	}
                                 ;    1053 
                                 ;    1054 
                                 ;    1055 #endif /* configUSE_ALTERNATIVE_API */
                                 ;    1056 /*-----------------------------------------------------------*/
                                 ;    1057 
                                 ;    1058 BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t x
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1058
00000442 7100DC                  		ADD #0FFFFFFDCH, R0
00000445 A201                    		MOV.L R1, 20H[R0]
00000447 A18A                    		MOV.L R2, 1CH[R0]
00000449 A183                    		MOV.L R3, 18H[R0]
0000044B A10C                    		MOV.L R4, 14H[R0]
                                 ;    1059 {
                                 ;    1060 BaseType_t xReturn;
                                 ;    1061 UBaseType_t uxSavedInterruptStatus;
                                 ;    1062 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1062
0000044D E5000803                		MOV.L 20H[R0], 0CH[R0]
00000451                         L180:	; entry.split
                                 ;    1063 
                                 ;    1064 	configASSERT( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1064
00000451 A889                    		MOV.L 0CH[R0], R1
00000453 6101                    		CMP #00H, R1
00000455 18                   S  		BNE L182
00000456                         L181:	; bb10
00000456 05rrrrrr             A  		BSR _vAssertCalled
0000045A                         L182:	; bb15
                                 ;    1065 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1065
0000045A A989                    		MOV.L 1CH[R0], R1
0000045C 6101                    		CMP #00H, R1
0000045E 10                   S  		BEQ L184
0000045F 2Err                 B  		BRA L186
00000461                         L183:	; bb16
00000461 05rrrrrr             A  		BSR _vAssertCalled
00000465 2Err                 B  		BRA L191
00000467                         L184:	; bb20
00000467 A889                    		MOV.L 0CH[R0], R1
00000469 AC11                    		MOV.L 40H[R1], R1
0000046B 6101                    		CMP #00H, R1
0000046D 10                   S  		BEQ L186
0000046E                         L185:	; bb26
0000046E F80601                  		MOV.L #00000001H, [R0]
00000471 08                   S  		BRA L187
00000472                         L186:	; bb27
00000472 F80600                  		MOV.L #00000000H, [R0]
00000475                         L187:	; bb28
00000475 EC01                    		MOV.L [R0], R1
00000477 6101                    		CMP #00H, R1
00000479 10                   S  		BEQ L189
0000047A                         L188:	; bb32
0000047A F80600                  		MOV.L #00000000H, [R0]
0000047D 08                   S  		BRA L190
0000047E                         L189:	; bb33
0000047E F80601                  		MOV.L #00000001H, [R0]
00000481                         L190:	; bb34
00000481 EC01                    		MOV.L [R0], R1
00000483 6101                    		CMP #00H, R1
00000485 20rr                    		BEQ L183
00000487                         L191:	; bb41
                                 ;    1066 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1066
00000487 A909                    		MOV.L 14H[R0], R1
00000489 6121                    		CMP #02H, R1
0000048B 10                   S  		BEQ L193
0000048C 2Err                 B  		BRA L195
0000048E                         L192:	; bb42
0000048E 05rrrrrr             A  		BSR _vAssertCalled
00000492 2Err                 B  		BRA L200
00000494                         L193:	; bb46
00000494 A889                    		MOV.L 0CH[R0], R1
00000496 AB99                    		MOV.L 3CH[R1], R1
00000498 6111                    		CMP #01H, R1
0000049A 10                   S  		BEQ L195
0000049B                         L194:	; bb52
0000049B F80601                  		MOV.L #00000001H, [R0]
0000049E 08                   S  		BRA L196
0000049F                         L195:	; bb53
0000049F F80600                  		MOV.L #00000000H, [R0]
000004A2                         L196:	; bb54
000004A2 EC01                    		MOV.L [R0], R1
000004A4 6101                    		CMP #00H, R1
000004A6 10                   S  		BEQ L198
000004A7                         L197:	; bb58
000004A7 F80600                  		MOV.L #00000000H, [R0]
000004AA 08                   S  		BRA L199
000004AB                         L198:	; bb59
000004AB F80601                  		MOV.L #00000001H, [R0]
000004AE                         L199:	; bb60
000004AE EC01                    		MOV.L [R0], R1
000004B0 6101                    		CMP #00H, R1
000004B2 20rr                    		BEQ L192
000004B4                         L200:	; bb67
                                 ;    1067 
                                 ;    1068 	/* RTOS ports that support interrupt nesting have the concept of a maximum
                                 ;    1069 	system call (or maximum API call) interrupt priority.  Interrupts that are
                                 ;    1070 	above the maximum system call priority are kept permanently enabled, even
                                 ;    1071 	when the RTOS kernel is in a critical section, but cannot make any calls to
                                 ;    1072 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
                                 ;    1073 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
                                 ;    1074 	failure if a FreeRTOS API function is called from an interrupt that has been
                                 ;    1075 	assigned a priority above the configured maximum system call priority.
                                 ;    1076 	Only FreeRTOS functions that end in FromISR can be called from interrupts
                                 ;    1077 	that have been assigned a priority at or (logically) below the maximum
                                 ;    1078 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
                                 ;    1079 	safe API to ensure interrupt entry is as fast and as simple as possible.
                                 ;    1080 	More information (albeit Cortex-M specific) is provided on the following
                                 ;    1081 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
                                 ;    1082 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1082
000004B4 FD6A0E                  		MVFC PSW, R14
000004B7 FD67EE                  		REVL R14, R14
000004BA 64FE                    		AND #0FH, R14
000004BC 616E                    		CMP #06H, R14
000004BE 29rr                    		BLT L202
000004C0                         L201:	; bb68
000004C0 05rrrrrr             A  		BSR _vAssertCalled
000004C4                         L202:	; bb77
                                 ;    1083 
                                 ;    1084 	/* Similar to xQueueGenericSend, except without blocking if there is no room
                                 ;    1085 	in the queue.  Also don't directly wake a task that was blocked on a queue
                                 ;    1086 	read, instead return a flag to say whether a context switch is required or
                                 ;    1087 	not (i.e. has a task with a higher priority than us been woken by this
                                 ;    1088 	post). */
                                 ;    1089 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1089
000004C4 FD6A0E                  		MVFC PSW, R14
000004C7 FD67E1                  		REVL R14, R1
000004CA 64F1                    		AND #0FH, R1
000004CC A081                    		MOV.L R1, 08H[R0]
000004CE 757005                  		MVTIPL #05H
000004D1                         L203:	; bb77.split
                                 ;    1090 	{
                                 ;    1091 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1091
000004D1 A889                    		MOV.L 0CH[R0], R1
000004D3 AB91                    		MOV.L 38H[R1], R1
000004D5 A88A                    		MOV.L 0CH[R0], R2
000004D7 0685210F                		CMP 3CH[R2].L, R1
000004DB 23rr                    		BLTU L218
000004DD 2Err                 B  		BRA L217
000004DF                         L204:	; bb82
                                 ;    1092 		{
                                 ;    1093 			traceQUEUE_SEND_FROM_ISR( pxQueue );
                                 ;    1094 
                                 ;    1095 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
                                 ;    1096 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
                                 ;    1097 			in a task disinheriting a priority and prvCopyDataToQueue() can be
                                 ;    1098 			called here even though the disinherit function does not check if
                                 ;    1099 			the scheduler is suspended before accessing the ready lists. */
                                 ;    1100 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1100
000004DF A90B                    		MOV.L 14H[R0], R3
000004E1 A98A                    		MOV.L 1CH[R0], R2
000004E3 A889                    		MOV.L 0CH[R0], R1
000004E5 39rrrr               W  		BSR __$prvCopyDataToQueue
000004E8                         L205:	; bb82.split
                                 ;    1101 
                                 ;    1102 			/* The event list is not altered if the queue is locked.  This will
                                 ;    1103 			be done when the queue is unlocked later. */
                                 ;    1104 			if( pxQueue->xTxLock == queueUNLOCKED )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1104
000004E8 A889                    		MOV.L 0CH[R0], R1
000004EA AC91                    		MOV.L 48H[R1], R1
000004EC 7501FF                  		CMP #0FFFFFFFFH, R1
000004EF A889                    		MOV.L 0CH[R0], R1
000004F1 21rr                    		BNE L214
000004F3                         L206:	; bb89
                                 ;    1105 			{
                                 ;    1106 				#if ( configUSE_QUEUE_SETS == 1 )
                                 ;    1107 				{
                                 ;    1108 					if( pxQueue->pxQueueSetContainer != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1108
000004F3 AD19                    		MOV.L 54H[R1], R1
000004F5 6101                    		CMP #00H, R1
000004F7 A889                    		MOV.L 0CH[R0], R1
000004F9 20rr                    		BEQ L210
000004FB                         L207:	; bb91
                                 ;    1109 					{
                                 ;    1110 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1110
000004FB A90A                    		MOV.L 14H[R0], R2
000004FD 39rrrr               W  		BSR __$prvNotifyQueueSetContainer
00000500 6111                    		CMP #01H, R1
00000502 21rr                    		BNE L215
00000504                         L208:	; bb93
                                 ;    1111 						{
                                 ;    1112 							/* The queue is a member of a queue set, and posting
                                 ;    1113 							to the queue set caused a higher priority task to
                                 ;    1114 							unblock.  A context switch is required. */
                                 ;    1115 							if( pxHigherPriorityTaskWoken != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1115
00000504 A981                    		MOV.L 18H[R0], R1
00000506 6101                    		CMP #00H, R1
00000508 20rr                    		BEQ L215
0000050A                         L209:	; bb94
                                 ;    1116 							{
                                 ;    1117 								*pxHigherPriorityTaskWoken = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1117
0000050A A981                    		MOV.L 18H[R0], R1
0000050C F81601                  		MOV.L #00000001H, [R1]
0000050F 2Err                 B  		BRA L215
00000511                         L210:	; bb111
                                 ;    1118 							}
                                 ;    1119 							else
                                 ;    1120 							{
                                 ;    1121 								mtCOVERAGE_TEST_MARKER();
                                 ;    1122 							}
                                 ;    1123 						}
                                 ;    1124 						else
                                 ;    1125 						{
                                 ;    1126 							mtCOVERAGE_TEST_MARKER();
                                 ;    1127 						}
                                 ;    1128 					}
                                 ;    1129 					else
                                 ;    1130 					{
                                 ;    1131 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1131
00000511 AA19                    		MOV.L 24H[R1], R1
00000513 6101                    		CMP #00H, R1
00000515 20rr                    		BEQ L215
00000517                         L211:	; bb113
                                 ;    1132 						{
                                 ;    1133 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1133
00000517 A889                    		MOV.L 0CH[R0], R1
00000519 711124                  		ADD #24H, R1
0000051C 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
00000520 6101                    		CMP #00H, R1
00000522 20rr                    		BEQ L215
00000524                         L212:	; bb115
                                 ;    1134 							{
                                 ;    1135 								/* The task waiting has a higher priority so
                                 ;    1136 								record that a context switch is required. */
                                 ;    1137 								if( pxHigherPriorityTaskWoken != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1137
00000524 A981                    		MOV.L 18H[R0], R1
00000526 6101                    		CMP #00H, R1
00000528 20rr                    		BEQ L215
0000052A                         L213:	; bb116
                                 ;    1138 								{
                                 ;    1139 									*pxHigherPriorityTaskWoken = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1139
0000052A A981                    		MOV.L 18H[R0], R1
0000052C F81601                  		MOV.L #00000001H, [R1]
0000052F 08                   S  		BRA L215
00000530                         L214:	; bb150
                                 ;    1140 								}
                                 ;    1141 								else
                                 ;    1142 								{
                                 ;    1143 									mtCOVERAGE_TEST_MARKER();
                                 ;    1144 								}
                                 ;    1145 							}
                                 ;    1146 							else
                                 ;    1147 							{
                                 ;    1148 								mtCOVERAGE_TEST_MARKER();
                                 ;    1149 							}
                                 ;    1150 						}
                                 ;    1151 						else
                                 ;    1152 						{
                                 ;    1153 							mtCOVERAGE_TEST_MARKER();
                                 ;    1154 						}
                                 ;    1155 					}
                                 ;    1156 				}
                                 ;    1157 				#else /* configUSE_QUEUE_SETS */
                                 ;    1158 				{
                                 ;    1159 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 ;    1160 					{
                                 ;    1161 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 ;    1162 						{
                                 ;    1163 							/* The task waiting has a higher priority so record that a
                                 ;    1164 							context	switch is required. */
                                 ;    1165 							if( pxHigherPriorityTaskWoken != NULL )
                                 ;    1166 							{
                                 ;    1167 								*pxHigherPriorityTaskWoken = pdTRUE;
                                 ;    1168 							}
                                 ;    1169 							else
                                 ;    1170 							{
                                 ;    1171 								mtCOVERAGE_TEST_MARKER();
                                 ;    1172 							}
                                 ;    1173 						}
                                 ;    1174 						else
                                 ;    1175 						{
                                 ;    1176 							mtCOVERAGE_TEST_MARKER();
                                 ;    1177 						}
                                 ;    1178 					}
                                 ;    1179 					else
                                 ;    1180 					{
                                 ;    1181 						mtCOVERAGE_TEST_MARKER();
                                 ;    1182 					}
                                 ;    1183 				}
                                 ;    1184 				#endif /* configUSE_QUEUE_SETS */
                                 ;    1185 			}
                                 ;    1186 			else
                                 ;    1187 			{
                                 ;    1188 				/* Increment the lock count so the task that unlocks the queue
                                 ;    1189 				knows that data was posted while it was locked. */
                                 ;    1190 				++( pxQueue->xTxLock );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1190
00000530 AC92                    		MOV.L 48H[R1], R2
00000532 6212                    		ADD #01H, R2
00000534 A492                    		MOV.L R2, 48H[R1]
00000536                         L215:	; bb161
                                 ;    1191 			}
                                 ;    1192 
                                 ;    1193 			xReturn = pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1193
00000536 3E0101                  		MOV.L #00000001H, 04H[R0]
00000539 2Err                 B  		BRA L221
0000053B                         L216:	; bb162
                                 ;    1194 		}
                                 ;    1195 		else
                                 ;    1196 		{
                                 ;    1197 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
                                 ;    1198 			xReturn = errQUEUE_FULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1198
0000053B 3E0100                  		MOV.L #00000000H, 04H[R0]
0000053E 2Err                 B  		BRA L221
00000540                         L217:	; bb171
00000540 A909                    		MOV.L 14H[R0], R1
00000542 6121                    		CMP #02H, R1
00000544 18                   S  		BNE L219
00000545                         L218:	; bb175
00000545 F80601                  		MOV.L #00000001H, [R0]
00000548 08                   S  		BRA L220
00000549                         L219:	; bb176
00000549 F80600                  		MOV.L #00000000H, [R0]
0000054C                         L220:	; bb177
0000054C EC01                    		MOV.L [R0], R1
0000054E 6101                    		CMP #00H, R1
00000550 21rr                    		BNE L204
00000552 2Err                 B  		BRA L216
00000554                         L221:	; bb182
                                 ;    1199 		}
                                 ;    1200 	}
                                 ;    1201 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1201
00000554 A881                    		MOV.L 08H[R0], R1
00000556 6DC1                    		SHLL #1CH, R1
00000558 6841                    		SHLR #04H, R1
0000055A FD6A0E                  		MVFC PSW, R14
0000055D 742EFFFFFFF0            		AND #0F0FFFFFFH, R14
00000563 57E1                    		OR R14, R1
00000565 FD6810                  		MVTC R1, PSW
00000568                         L222:	; bb182.split
                                 ;    1202 
                                 ;    1203 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1203
00000568 A809                    		MOV.L 04H[R0], R1
0000056A A101                    		MOV.L R1, 10H[R0]
0000056C                         L223:	; bb182.split1
                                 ;    1204 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1204
0000056C 6709                    		RTSD #24H
0000056E                         _xQueueGiveFromISR:
                                 		.STACK	_xQueueGiveFromISR=32
                                 ;    1205 /*-----------------------------------------------------------*/
                                 ;    1206 
                                 ;    1207 BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1207
0000056E 7100E4                  		ADD #0FFFFFFE4H, R0
00000571 A181                    		MOV.L R1, 18H[R0]
00000573 A10A                    		MOV.L R2, 14H[R0]
                                 ;    1208 {
                                 ;    1209 BaseType_t xReturn;
                                 ;    1210 UBaseType_t uxSavedInterruptStatus;
                                 ;    1211 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1211
00000575 E5000603                		MOV.L 18H[R0], 0CH[R0]
00000579                         L225:	; entry.split
                                 ;    1212 
                                 ;    1213 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
                                 ;    1214 	item size is 0.  Don't directly wake a task that was blocked on a queue
                                 ;    1215 	read, instead return a flag to say whether a context switch is required or
                                 ;    1216 	not (i.e. has a task with a higher priority than us been woken by this
                                 ;    1217 	post). */
                                 ;    1218 
                                 ;    1219 	configASSERT( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1219
00000579 A889                    		MOV.L 0CH[R0], R1
0000057B 6101                    		CMP #00H, R1
0000057D 18                   S  		BNE L227
0000057E                         L226:	; bb8
0000057E 05rrrrrr             A  		BSR _vAssertCalled
00000582                         L227:	; bb13
                                 ;    1220 
                                 ;    1221 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
                                 ;    1222 	if the item size is not 0. */
                                 ;    1223 	configASSERT( pxQueue->uxItemSize == 0 );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1223
00000582 A889                    		MOV.L 0CH[R0], R1
00000584 AC11                    		MOV.L 40H[R1], R1
00000586 6101                    		CMP #00H, R1
00000588 10                   S  		BEQ L229
00000589                         L228:	; bb14
00000589 05rrrrrr             A  		BSR _vAssertCalled
0000058D                         L229:	; bb24
                                 ;    1224 
                                 ;    1225 	/* Normally a mutex would not be given from an interrupt, and doing so is
                                 ;    1226 	definitely wrong if there is a mutex holder as priority inheritance makes no
                                 ;    1227 	sense for an interrupts, only tasks. */
                                 ;    1228 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1228
0000058D A889                    		MOV.L 0CH[R0], R1
0000058F EC1E                    		MOV.L [R1], R14
00000591 610E                    		CMP #00H, R14
00000593 10                   S  		BEQ L231
00000594 2Err                 B  		BRA L233
00000596                         L230:	; bb25
00000596 05rrrrrr             A  		BSR _vAssertCalled
0000059A 2Err                 B  		BRA L238
0000059C                         L231:	; bb31
0000059C A889                    		MOV.L 0CH[R0], R1
0000059E A819                    		MOV.L 04H[R1], R1
000005A0 6101                    		CMP #00H, R1
000005A2 10                   S  		BEQ L233
000005A3                         L232:	; bb37
000005A3 F80601                  		MOV.L #00000001H, [R0]
000005A6 08                   S  		BRA L234
000005A7                         L233:	; bb38
000005A7 F80600                  		MOV.L #00000000H, [R0]
000005AA                         L234:	; bb39
000005AA EC01                    		MOV.L [R0], R1
000005AC 6101                    		CMP #00H, R1
000005AE 10                   S  		BEQ L236
000005AF                         L235:	; bb43
000005AF F80600                  		MOV.L #00000000H, [R0]
000005B2 08                   S  		BRA L237
000005B3                         L236:	; bb44
000005B3 F80601                  		MOV.L #00000001H, [R0]
000005B6                         L237:	; bb45
000005B6 EC01                    		MOV.L [R0], R1
000005B8 6101                    		CMP #00H, R1
000005BA 20rr                    		BEQ L230
000005BC                         L238:	; bb52
                                 ;    1229 
                                 ;    1230 	/* RTOS ports that support interrupt nesting have the concept of a maximum
                                 ;    1231 	system call (or maximum API call) interrupt priority.  Interrupts that are
                                 ;    1232 	above the maximum system call priority are kept permanently enabled, even
                                 ;    1233 	when the RTOS kernel is in a critical section, but cannot make any calls to
                                 ;    1234 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
                                 ;    1235 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
                                 ;    1236 	failure if a FreeRTOS API function is called from an interrupt that has been
                                 ;    1237 	assigned a priority above the configured maximum system call priority.
                                 ;    1238 	Only FreeRTOS functions that end in FromISR can be called from interrupts
                                 ;    1239 	that have been assigned a priority at or (logically) below the maximum
                                 ;    1240 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
                                 ;    1241 	safe API to ensure interrupt entry is as fast and as simple as possible.
                                 ;    1242 	More information (albeit Cortex-M specific) is provided on the following
                                 ;    1243 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
                                 ;    1244 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1244
000005BC FD6A0E                  		MVFC PSW, R14
000005BF FD67EE                  		REVL R14, R14
000005C2 64FE                    		AND #0FH, R14
000005C4 616E                    		CMP #06H, R14
000005C6 29rr                    		BLT L240
000005C8                         L239:	; bb53
000005C8 05rrrrrr             A  		BSR _vAssertCalled
000005CC                         L240:	; bb62
                                 ;    1245 
                                 ;    1246 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1246
000005CC FD6A0E                  		MVFC PSW, R14
000005CF FD67E1                  		REVL R14, R1
000005D2 64F1                    		AND #0FH, R1
000005D4 A081                    		MOV.L R1, 08H[R0]
000005D6 757005                  		MVTIPL #05H
000005D9                         L241:	; bb62.split
                                 ;    1247 	{
                                 ;    1248 		/* When the queue is used to implement a semaphore no data is ever
                                 ;    1249 		moved through the queue but it is still valid to see if the queue 'has
                                 ;    1250 		space'. */
                                 ;    1251 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1251
000005D9 A889                    		MOV.L 0CH[R0], R1
000005DB AB91                    		MOV.L 38H[R1], R1
000005DD A88A                    		MOV.L 0CH[R0], R2
000005DF 0685210F                		CMP 3CH[R2].L, R1
000005E3 22rr                    		BGEU L254
000005E5                         L242:	; bb67
                                 ;    1252 		{
                                 ;    1253 			traceQUEUE_SEND_FROM_ISR( pxQueue );
                                 ;    1254 
                                 ;    1255 			/* A task can only have an inherited priority if it is a mutex
                                 ;    1256 			holder - and if there is a mutex holder then the mutex cannot be
                                 ;    1257 			given from an ISR.  As this is the ISR version of the function it
                                 ;    1258 			can be assumed there is no mutex holder and no need to determine if
                                 ;    1259 			priority disinheritance is needed.  Simply increase the count of
                                 ;    1260 			messages (semaphores) available. */
                                 ;    1261 			++( pxQueue->uxMessagesWaiting );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1261
000005E5 A889                    		MOV.L 0CH[R0], R1
000005E7 AB92                    		MOV.L 38H[R1], R2
000005E9 6212                    		ADD #01H, R2
000005EB A392                    		MOV.L R2, 38H[R1]
000005ED                         L243:	; bb67.split
                                 ;    1262 
                                 ;    1263 			/* The event list is not altered if the queue is locked.  This will
                                 ;    1264 			be done when the queue is unlocked later. */
                                 ;    1265 			if( pxQueue->xTxLock == queueUNLOCKED )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1265
000005ED A889                    		MOV.L 0CH[R0], R1
000005EF AC91                    		MOV.L 48H[R1], R1
000005F1 7501FF                  		CMP #0FFFFFFFFH, R1
000005F4 A889                    		MOV.L 0CH[R0], R1
000005F6 21rr                    		BNE L252
000005F8                         L244:	; bb74
                                 ;    1266 			{
                                 ;    1267 				#if ( configUSE_QUEUE_SETS == 1 )
                                 ;    1268 				{
                                 ;    1269 					if( pxQueue->pxQueueSetContainer != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1269
000005F8 AD19                    		MOV.L 54H[R1], R1
000005FA 6101                    		CMP #00H, R1
000005FC A889                    		MOV.L 0CH[R0], R1
000005FE 20rr                    		BEQ L248
00000600                         L245:	; bb76
00000600 6602                    		MOV.L #00000000H, R2
                                 ;    1270 					{
                                 ;    1271 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1271
00000602 39rrrr               W  		BSR __$prvNotifyQueueSetContainer
00000605 6111                    		CMP #01H, R1
00000607 21rr                    		BNE L253
00000609                         L246:	; bb78
                                 ;    1272 						{
                                 ;    1273 							/* The semaphore is a member of a queue set, and
                                 ;    1274 							posting	to the queue set caused a higher priority
                                 ;    1275 							task to	unblock.  A context switch is required. */
                                 ;    1276 							if( pxHigherPriorityTaskWoken != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1276
00000609 A909                    		MOV.L 14H[R0], R1
0000060B 6101                    		CMP #00H, R1
0000060D 20rr                    		BEQ L253
0000060F                         L247:	; bb79
                                 ;    1277 							{
                                 ;    1278 								*pxHigherPriorityTaskWoken = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1278
0000060F A909                    		MOV.L 14H[R0], R1
00000611 F81601                  		MOV.L #00000001H, [R1]
00000614 2Err                 B  		BRA L253
00000616                         L248:	; bb95
                                 ;    1279 							}
                                 ;    1280 							else
                                 ;    1281 							{
                                 ;    1282 								mtCOVERAGE_TEST_MARKER();
                                 ;    1283 							}
                                 ;    1284 						}
                                 ;    1285 						else
                                 ;    1286 						{
                                 ;    1287 							mtCOVERAGE_TEST_MARKER();
                                 ;    1288 						}
                                 ;    1289 					}
                                 ;    1290 					else
                                 ;    1291 					{
                                 ;    1292 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1292
00000616 AA19                    		MOV.L 24H[R1], R1
00000618 6101                    		CMP #00H, R1
0000061A 20rr                    		BEQ L253
0000061C                         L249:	; bb97
                                 ;    1293 						{
                                 ;    1294 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1294
0000061C A889                    		MOV.L 0CH[R0], R1
0000061E 711124                  		ADD #24H, R1
00000621 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
00000625 6101                    		CMP #00H, R1
00000627 20rr                    		BEQ L253
00000629                         L250:	; bb99
                                 ;    1295 							{
                                 ;    1296 								/* The task waiting has a higher priority so
                                 ;    1297 								record that a context switch is required. */
                                 ;    1298 								if( pxHigherPriorityTaskWoken != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1298
00000629 A909                    		MOV.L 14H[R0], R1
0000062B 6101                    		CMP #00H, R1
0000062D 20rr                    		BEQ L253
0000062F                         L251:	; bb100
                                 ;    1299 								{
                                 ;    1300 									*pxHigherPriorityTaskWoken = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1300
0000062F A909                    		MOV.L 14H[R0], R1
00000631 F81601                  		MOV.L #00000001H, [R1]
00000634 08                   S  		BRA L253
00000635                         L252:	; bb134
                                 ;    1301 								}
                                 ;    1302 								else
                                 ;    1303 								{
                                 ;    1304 									mtCOVERAGE_TEST_MARKER();
                                 ;    1305 								}
                                 ;    1306 							}
                                 ;    1307 							else
                                 ;    1308 							{
                                 ;    1309 								mtCOVERAGE_TEST_MARKER();
                                 ;    1310 							}
                                 ;    1311 						}
                                 ;    1312 						else
                                 ;    1313 						{
                                 ;    1314 							mtCOVERAGE_TEST_MARKER();
                                 ;    1315 						}
                                 ;    1316 					}
                                 ;    1317 				}
                                 ;    1318 				#else /* configUSE_QUEUE_SETS */
                                 ;    1319 				{
                                 ;    1320 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 ;    1321 					{
                                 ;    1322 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 ;    1323 						{
                                 ;    1324 							/* The task waiting has a higher priority so record that a
                                 ;    1325 							context	switch is required. */
                                 ;    1326 							if( pxHigherPriorityTaskWoken != NULL )
                                 ;    1327 							{
                                 ;    1328 								*pxHigherPriorityTaskWoken = pdTRUE;
                                 ;    1329 							}
                                 ;    1330 							else
                                 ;    1331 							{
                                 ;    1332 								mtCOVERAGE_TEST_MARKER();
                                 ;    1333 							}
                                 ;    1334 						}
                                 ;    1335 						else
                                 ;    1336 						{
                                 ;    1337 							mtCOVERAGE_TEST_MARKER();
                                 ;    1338 						}
                                 ;    1339 					}
                                 ;    1340 					else
                                 ;    1341 					{
                                 ;    1342 						mtCOVERAGE_TEST_MARKER();
                                 ;    1343 					}
                                 ;    1344 				}
                                 ;    1345 				#endif /* configUSE_QUEUE_SETS */
                                 ;    1346 			}
                                 ;    1347 			else
                                 ;    1348 			{
                                 ;    1349 				/* Increment the lock count so the task that unlocks the queue
                                 ;    1350 				knows that data was posted while it was locked. */
                                 ;    1351 				++( pxQueue->xTxLock );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1351
00000635 AC92                    		MOV.L 48H[R1], R2
00000637 6212                    		ADD #01H, R2
00000639 A492                    		MOV.L R2, 48H[R1]
0000063B                         L253:	; bb145
                                 ;    1352 			}
                                 ;    1353 
                                 ;    1354 			xReturn = pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1354
0000063B 3E0101                  		MOV.L #00000001H, 04H[R0]
0000063E 08                   S  		BRA L255
0000063F                         L254:	; bb146
                                 ;    1355 		}
                                 ;    1356 		else
                                 ;    1357 		{
                                 ;    1358 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
                                 ;    1359 			xReturn = errQUEUE_FULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1359
0000063F 3E0100                  		MOV.L #00000000H, 04H[R0]
00000642                         L255:	; bb156
                                 ;    1360 		}
                                 ;    1361 	}
                                 ;    1362 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1362
00000642 A881                    		MOV.L 08H[R0], R1
00000644 6DC1                    		SHLL #1CH, R1
00000646 6841                    		SHLR #04H, R1
00000648 FD6A0E                  		MVFC PSW, R14
0000064B 742EFFFFFFF0            		AND #0F0FFFFFFH, R14
00000651 57E1                    		OR R14, R1
00000653 FD6810                  		MVTC R1, PSW
00000656                         L256:	; bb156.split
                                 ;    1363 
                                 ;    1364 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1364
00000656 A809                    		MOV.L 04H[R0], R1
00000658 A101                    		MOV.L R1, 10H[R0]
0000065A                         L257:	; bb156.split1
                                 ;    1365 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1365
0000065A 6707                    		RTSD #1CH
0000065C                         _xQueueGenericReceive:
                                 		.STACK	_xQueueGenericReceive=56
                                 ;    1366 /*-----------------------------------------------------------*/
                                 ;    1367 
                                 ;    1368 BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1368
0000065C 7EA6                    		PUSH.L R6
0000065E 7100D0                  		ADD #0FFFFFFD0H, R0
00000661 A289                    		MOV.L R1, 2CH[R0]
00000663 A282                    		MOV.L R2, 28H[R0]
00000665 A20B                    		MOV.L R3, 24H[R0]
00000667 A204                    		MOV.L R4, 20H[R0]
                                 ;    1369 {
                                 ;    1370 BaseType_t xEntryTimeSet = pdFALSE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1370
00000669 3E0200                  		MOV.L #00000000H, 08H[R0]
0000066C                         L259:	; entry.split
                                 ;    1371 TimeOut_t xTimeOut;
                                 ;    1372 int8_t *pcOriginalReadPosition;
                                 ;    1373 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1373
0000066C E5000B06                		MOV.L 2CH[R0], 18H[R0]
00000670                         L260:	; entry.split1
                                 ;    1374 
                                 ;    1375 	configASSERT( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1375
00000670 A981                    		MOV.L 18H[R0], R1
00000672 6101                    		CMP #00H, R1
00000674 18                   S  		BNE L262
00000675                         L261:	; bb11
00000675 05rrrrrr             A  		BSR _vAssertCalled
00000679                         L262:	; bb16
                                 ;    1376 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1376
00000679 AA81                    		MOV.L 28H[R0], R1
0000067B 6101                    		CMP #00H, R1
0000067D 10                   S  		BEQ L264
0000067E 2Err                 B  		BRA L266
00000680                         L263:	; bb17
00000680 05rrrrrr             A  		BSR _vAssertCalled
00000684 2Err                 B  		BRA L271
00000686                         L264:	; bb21
00000686 A981                    		MOV.L 18H[R0], R1
00000688 AC11                    		MOV.L 40H[R1], R1
0000068A 6101                    		CMP #00H, R1
0000068C 10                   S  		BEQ L266
0000068D                         L265:	; bb27
0000068D F80601                  		MOV.L #00000001H, [R0]
00000690 08                   S  		BRA L267
00000691                         L266:	; bb28
00000691 F80600                  		MOV.L #00000000H, [R0]
00000694                         L267:	; bb29
00000694 EC01                    		MOV.L [R0], R1
00000696 6101                    		CMP #00H, R1
00000698 10                   S  		BEQ L269
00000699                         L268:	; bb33
00000699 F80600                  		MOV.L #00000000H, [R0]
0000069C 08                   S  		BRA L270
0000069D                         L269:	; bb34
0000069D F80601                  		MOV.L #00000001H, [R0]
000006A0                         L270:	; bb35
000006A0 EC01                    		MOV.L [R0], R1
000006A2 6101                    		CMP #00H, R1
000006A4 20rr                    		BEQ L263
000006A6                         L271:	; bb42
                                 ;    1377 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
                                 ;    1378 	{
                                 ;    1379 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1379
000006A6 05rrrrrr             A  		BSR _xTaskGetSchedulerState
000006AA 6101                    		CMP #00H, R1
000006AC 10                   S  		BEQ L273
000006AD 2Err                 B  		BRA L275
000006AF                         L272:	; bb43
000006AF 05rrrrrr             A  		BSR _vAssertCalled
000006B3 38rrrr               W  		BRA L324
000006B6                         L273:	; bb47
000006B6 AA09                    		MOV.L 24H[R0], R1
000006B8 6101                    		CMP #00H, R1
000006BA 10                   S  		BEQ L275
000006BB                         L274:	; bb51
000006BB F80601                  		MOV.L #00000001H, [R0]
000006BE 08                   S  		BRA L276
000006BF                         L275:	; bb52
000006BF F80600                  		MOV.L #00000000H, [R0]
000006C2                         L276:	; bb53
000006C2 EC01                    		MOV.L [R0], R1
000006C4 6101                    		CMP #00H, R1
000006C6 10                   S  		BEQ L278
000006C7                         L277:	; bb57
000006C7 F80600                  		MOV.L #00000000H, [R0]
000006CA 08                   S  		BRA L279
000006CB                         L278:	; bb58
000006CB F80601                  		MOV.L #00000001H, [R0]
000006CE                         L279:	; bb59
000006CE EC01                    		MOV.L [R0], R1
000006D0 6101                    		CMP #00H, R1
000006D2 20rr                    		BEQ L272
000006D4 38rrrr               W  		BRA L324
000006D7                         L280:	; bb68
                                 ;    1380 	}
                                 ;    1381 	#endif
                                 ;    1382 
                                 ;    1383 	/* This function relaxes the coding standard somewhat to allow return
                                 ;    1384 	statements within the function itself.  This is done in the interest
                                 ;    1385 	of execution time efficiency. */
                                 ;    1386 
                                 ;    1387 	for( ;; )
                                 ;    1388 	{
                                 ;    1389 		taskENTER_CRITICAL();
                                 ;    1390 		{
                                 ;    1391 			/* Is there data in the queue now?  To be running the calling task
                                 ;    1392 			must be	the highest priority task wanting to access the queue. */
                                 ;    1393 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
                                 ;    1394 			{
                                 ;    1395 				/* Remember the read position in case the queue is only being
                                 ;    1396 				peeked. */
                                 ;    1397 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1397
000006D7 A981                    		MOV.L 18H[R0], R1
000006D9 E5100305                		MOV.L 0CH[R1], 14H[R0]
000006DD                         L281:	; bb68.split
                                 ;    1398 
                                 ;    1399 				prvCopyDataFromQueue( pxQueue, pvBuffer );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1399
000006DD AA82                    		MOV.L 28H[R0], R2
000006DF A981                    		MOV.L 18H[R0], R1
000006E1 39rrrr               W  		BSR __$prvCopyDataFromQueue
000006E4                         L282:	; bb68.split2
                                 ;    1400 
                                 ;    1401 				if( xJustPeeking == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1401
000006E4 AA01                    		MOV.L 20H[R0], R1
000006E6 6101                    		CMP #00H, R1
000006E8 A981                    		MOV.L 18H[R0], R1
000006EA 21rr                    		BNE L289
000006EC                         L283:	; bb76
                                 ;    1402 				{
                                 ;    1403 					traceQUEUE_RECEIVE( pxQueue );
                                 ;    1404 
                                 ;    1405 					/* Actually removing data, not just peeking. */
                                 ;    1406 					--( pxQueue->uxMessagesWaiting );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1406
000006EC AB92                    		MOV.L 38H[R1], R2
000006EE 6012                    		SUB #01H, R2
000006F0 A392                    		MOV.L R2, 38H[R1]
000006F2                         L284:	; bb76.split
                                 ;    1407 
                                 ;    1408 					#if ( configUSE_MUTEXES == 1 )
                                 ;    1409 					{
                                 ;    1410 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1410
000006F2 A981                    		MOV.L 18H[R0], R1
000006F4 EC1E                    		MOV.L [R1], R14
000006F6 610E                    		CMP #00H, R14
000006F8 18                   S  		BNE L286
000006F9                         L285:	; bb82
                                 ;    1411 						{
                                 ;    1412 							/* Record the information required to implement
                                 ;    1413 							priority inheritance should it become necessary. */
                                 ;    1414 							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundan
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1414
000006F9 A986                    		MOV.L 18H[R0], R6
000006FB 05rrrrrr             A  		BSR _pvTaskIncrementMutexHeldCount
000006FF A069                    		MOV.L R1, 04H[R6]
00000701                         L286:	; bb94
                                 ;    1415 						}
                                 ;    1416 						else
                                 ;    1417 						{
                                 ;    1418 							mtCOVERAGE_TEST_MARKER();
                                 ;    1419 						}
                                 ;    1420 					}
                                 ;    1421 					#endif /* configUSE_MUTEXES */
                                 ;    1422 
                                 ;    1423 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1423
00000701 A981                    		MOV.L 18H[R0], R1
00000703 A911                    		MOV.L 10H[R1], R1
00000705 6101                    		CMP #00H, R1
00000707 20rr                    		BEQ L293
00000709                         L287:	; bb96
                                 ;    1424 					{
                                 ;    1425 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1425
00000709 A981                    		MOV.L 18H[R0], R1
0000070B 711110                  		ADD #10H, R1
0000070E 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
00000712 6111                    		CMP #01H, R1
00000714 21rr                    		BNE L293
00000716                         L288:	; bb97
                                 ;    1426 						{
                                 ;    1427 							queueYIELD_IF_USING_PREEMPTION();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1427
                                 		._LINE_TOP  inline_asm
                                  
00000716 7EA5                    	PUSH.L R5
                                 	 
00000718 FB5EE07208              	MOV.L #553696, R5
0000071D F85401                  	MOV.B #1, [R5]
                                 	 
00000720 EC55                    	MOV.L [R5], R5
                                 	 
00000722 7EB5                    	POP R5
                                 		._LINE_END  inline_asm
00000724 2Err                 B  		BRA L293
00000726                         L289:	; bb117
                                 ;    1428 						}
                                 ;    1429 						else
                                 ;    1430 						{
                                 ;    1431 							mtCOVERAGE_TEST_MARKER();
                                 ;    1432 						}
                                 ;    1433 					}
                                 ;    1434 					else
                                 ;    1435 					{
                                 ;    1436 						mtCOVERAGE_TEST_MARKER();
                                 ;    1437 					}
                                 ;    1438 				}
                                 ;    1439 				else
                                 ;    1440 				{
                                 ;    1441 					traceQUEUE_PEEK( pxQueue );
                                 ;    1442 
                                 ;    1443 					/* The data is not being removed, so reset the read
                                 ;    1444 					pointer. */
                                 ;    1445 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1445
00000726 E5010503                		MOV.L 14H[R0], 0CH[R1]
0000072A                         L290:	; bb117.split
                                 ;    1446 
                                 ;    1447 					/* The data is being left in the queue, so see if there are
                                 ;    1448 					any other tasks waiting for the data. */
                                 ;    1449 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1449
0000072A A981                    		MOV.L 18H[R0], R1
0000072C AA19                    		MOV.L 24H[R1], R1
0000072E 6101                    		CMP #00H, R1
00000730 20rr                    		BEQ L293
00000732                         L291:	; bb124
                                 ;    1450 					{
                                 ;    1451 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1451
00000732 A981                    		MOV.L 18H[R0], R1
00000734 711124                  		ADD #24H, R1
00000737 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
0000073B 6101                    		CMP #00H, R1
0000073D 20rr                    		BEQ L293
0000073F                         L292:	; bb125
                                 ;    1452 						{
                                 ;    1453 							/* The task waiting has a higher priority than this task. */
                                 ;    1454 							queueYIELD_IF_USING_PREEMPTION();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1454
                                 		._LINE_TOP  inline_asm
                                  
0000073F 7EA5                    	PUSH.L R5
                                 	 
00000741 FB5EE07208              	MOV.L #553696, R5
00000746 F85401                  	MOV.B #1, [R5]
                                 	 
00000749 EC55                    	MOV.L [R5], R5
                                 	 
0000074B 7EB5                    	POP R5
                                 		._LINE_END  inline_asm
0000074D                         L293:	; bb149
                                 ;    1455 						}
                                 ;    1456 						else
                                 ;    1457 						{
                                 ;    1458 							mtCOVERAGE_TEST_MARKER();
                                 ;    1459 						}
                                 ;    1460 					}
                                 ;    1461 					else
                                 ;    1462 					{
                                 ;    1463 						mtCOVERAGE_TEST_MARKER();
                                 ;    1464 					}
                                 ;    1465 				}
                                 ;    1466 
                                 ;    1467 				taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1467
0000074D 05rrrrrr             A  		BSR _vTaskExitCritical
00000751                         L294:	; bb149.split
                                 ;    1468 				return pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1468
00000751 3E0101                  		MOV.L #00000001H, 04H[R0]
00000754 38rrrr               W  		BRA L326
00000757                         L295:	; bb152
                                 ;    1469 			}
                                 ;    1470 			else
                                 ;    1471 			{
                                 ;    1472 				if( xTicksToWait == ( TickType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1472
00000757 AA09                    		MOV.L 24H[R0], R1
00000759 6101                    		CMP #00H, R1
0000075B 21rr                    		BNE L298
0000075D                         L296:	; bb153
                                 ;    1473 				{
                                 ;    1474 					/* The queue was empty and no block time is specified (or
                                 ;    1475 					the block time has expired) so leave now. */
                                 ;    1476 					taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1476
0000075D 05rrrrrr             A  		BSR _vTaskExitCritical
00000761                         L297:	; bb153.split
                                 ;    1477 					traceQUEUE_RECEIVE_FAILED( pxQueue );
                                 ;    1478 					return errQUEUE_EMPTY;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1478
00000761 3E0100                  		MOV.L #00000000H, 04H[R0]
00000764 38rrrr               W  		BRA L326
00000767                         L298:	; bb156
                                 ;    1479 				}
                                 ;    1480 				else if( xEntryTimeSet == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1480
00000767 A881                    		MOV.L 08H[R0], R1
00000769 6101                    		CMP #00H, R1
0000076B 21rr                    		BNE L301
0000076D                         L299:	; bb157
0000076D 71010C                  		ADD #0CH, R0, R1
                                 ;    1481 				{
                                 ;    1482 					/* The queue was empty and a block time was specified so
                                 ;    1483 					configure the timeout structure. */
                                 ;    1484 					vTaskSetTimeOutState( &xTimeOut );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1484
00000770 05rrrrrr             A  		BSR _vTaskSetTimeOutState
00000774                         L300:	; bb157.split
                                 ;    1485 					xEntryTimeSet = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1485
00000774 3E0201                  		MOV.L #00000001H, 08H[R0]
00000777                         L301:	; bb175
                                 ;    1486 				}
                                 ;    1487 				else
                                 ;    1488 				{
                                 ;    1489 					/* Entry time was already set. */
                                 ;    1490 					mtCOVERAGE_TEST_MARKER();
                                 ;    1491 				}
                                 ;    1492 			}
                                 ;    1493 		}
                                 ;    1494 		taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1494
00000777 05rrrrrr             A  		BSR _vTaskExitCritical
0000077B                         L302:	; bb175.split
                                 ;    1495 
                                 ;    1496 		/* Interrupts and other tasks can send to and receive from the queue
                                 ;    1497 		now the critical section has been exited. */
                                 ;    1498 
                                 ;    1499 		vTaskSuspendAll();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1499
0000077B 05rrrrrr             A  		BSR _vTaskSuspendAll
0000077F                         L303:	; bb175.split3
                                 ;    1500 		prvLockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1500
0000077F 05rrrrrr             A  		BSR _vTaskEnterCritical
00000783                         L304:	; bb175.split4
00000783 A981                    		MOV.L 18H[R0], R1
00000785 AC19                    		MOV.L 44H[R1], R1
00000787 7501FF                  		CMP #0FFFFFFFFH, R1
0000078A 18                   S  		BNE L306
0000078B                         L305:	; bb177
0000078B A981                    		MOV.L 18H[R0], R1
0000078D 3E9100                  		MOV.L #00000000H, 44H[R1]
00000790                         L306:	; bb187
00000790 A981                    		MOV.L 18H[R0], R1
00000792 AC91                    		MOV.L 48H[R1], R1
00000794 7501FF                  		CMP #0FFFFFFFFH, R1
00000797 18                   S  		BNE L308
00000798                         L307:	; bb188
00000798 A981                    		MOV.L 18H[R0], R1
0000079A 3E9200                  		MOV.L #00000000H, 48H[R1]
0000079D                         L308:	; bb197
0000079D 05rrrrrr             A  		BSR _vTaskExitCritical
000007A1                         L309:	; bb197.split
000007A1 710224                  		ADD #24H, R0, R2
000007A4 71010C                  		ADD #0CH, R0, R1
                                 ;    1501 
                                 ;    1502 		/* Update the timeout state to see if it has expired yet. */
                                 ;    1503 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1503
000007A7 05rrrrrr             A  		BSR _xTaskCheckForTimeOut
000007AB 6101                    		CMP #00H, R1
000007AD A981                    		MOV.L 18H[R0], R1
000007AF 21rr                    		BNE L321
000007B1                         L310:	; bb200
                                 ;    1504 		{
                                 ;    1505 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1505
000007B1 39rrrr               W  		BSR __$prvIsQueueEmpty
000007B4 6101                    		CMP #00H, R1
000007B6 A981                    		MOV.L 18H[R0], R1
000007B8 20rr                    		BEQ L319
000007BA                         L311:	; bb202
                                 ;    1506 			{
                                 ;    1507 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                                 ;    1508 
                                 ;    1509 				#if ( configUSE_MUTEXES == 1 )
                                 ;    1510 				{
                                 ;    1511 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1511
000007BA EC1E                    		MOV.L [R1], R14
000007BC 610E                    		CMP #00H, R14
000007BE 21rr                    		BNE L315
000007C0                         L312:	; bb203
                                 ;    1512 					{
                                 ;    1513 						taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1513
000007C0 05rrrrrr             A  		BSR _vTaskEnterCritical
000007C4                         L313:	; bb203.split
                                 ;    1514 						{
                                 ;    1515 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1515
000007C4 A981                    		MOV.L 18H[R0], R1
000007C6 A819                    		MOV.L 04H[R1], R1
000007C8 05rrrrrr             A  		BSR _vTaskPriorityInherit
000007CC                         L314:	; bb203.split5
                                 ;    1516 						}
                                 ;    1517 						taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1517
000007CC 05rrrrrr             A  		BSR _vTaskExitCritical
000007D0                         L315:	; bb214
                                 ;    1518 					}
                                 ;    1519 					else
                                 ;    1520 					{
                                 ;    1521 						mtCOVERAGE_TEST_MARKER();
                                 ;    1522 					}
                                 ;    1523 				}
                                 ;    1524 				#endif
                                 ;    1525 
                                 ;    1526 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1526
000007D0 AA0A                    		MOV.L 24H[R0], R2
000007D2 A981                    		MOV.L 18H[R0], R1
000007D4 711124                  		ADD #24H, R1
000007D7 05rrrrrr             A  		BSR _vTaskPlaceOnEventList
000007DB                         L316:	; bb214.split
                                 ;    1527 				prvUnlockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1527
000007DB A981                    		MOV.L 18H[R0], R1
000007DD 39rrrr               W  		BSR __$prvUnlockQueue
000007E0                         L317:	; bb214.split6
                                 ;    1528 				if( xTaskResumeAll() == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1528
000007E0 05rrrrrr             A  		BSR _xTaskResumeAll
000007E4 6101                    		CMP #00H, R1
000007E6 21rr                    		BNE L324
000007E8                         L318:	; bb220
                                 ;    1529 				{
                                 ;    1530 					portYIELD_WITHIN_API();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1530
                                 		._LINE_TOP  inline_asm
                                  
000007E8 7EA5                    	PUSH.L R5
                                 	 
000007EA FB5EE07208              	MOV.L #553696, R5
000007EF F85401                  	MOV.B #1, [R5]
                                 	 
000007F2 EC55                    	MOV.L [R5], R5
                                 	 
000007F4 7EB5                    	POP R5
                                 		._LINE_END  inline_asm
000007F6 2Err                 B  		BRA L324
000007F8                         L319:	; bb227
                                 ;    1531 				}
                                 ;    1532 				else
                                 ;    1533 				{
                                 ;    1534 					mtCOVERAGE_TEST_MARKER();
                                 ;    1535 				}
                                 ;    1536 			}
                                 ;    1537 			else
                                 ;    1538 			{
                                 ;    1539 				/* Try again. */
                                 ;    1540 				prvUnlockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1540
000007F8 39rrrr               W  		BSR __$prvUnlockQueue
000007FB                         L320:	; bb227.split
                                 ;    1541 				( void ) xTaskResumeAll();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1541
000007FB 05rrrrrr             A  		BSR _xTaskResumeAll
000007FF 2Err                 B  		BRA L324
00000801                         L321:	; bb236
                                 ;    1542 			}
                                 ;    1543 		}
                                 ;    1544 		else
                                 ;    1545 		{
                                 ;    1546 			prvUnlockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1546
00000801 39rrrr               W  		BSR __$prvUnlockQueue
00000804                         L322:	; bb236.split
                                 ;    1547 			( void ) xTaskResumeAll();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1547
00000804 05rrrrrr             A  		BSR _xTaskResumeAll
00000808                         L323:	; bb236.split7
                                 ;    1548 			traceQUEUE_RECEIVE_FAILED( pxQueue );
                                 ;    1549 			return errQUEUE_EMPTY;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1549
00000808 3E0100                  		MOV.L #00000000H, 04H[R0]
0000080B 2Err                 B  		BRA L326
0000080D                         L324:	; bb245.split
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1389
0000080D 05rrrrrr             A  		BSR _vTaskEnterCritical
00000811                         L325:	; bb245.split8
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1393
00000811 A981                    		MOV.L 18H[R0], R1
00000813 AB91                    		MOV.L 38H[R1], R1
00000815 6101                    		CMP #00H, R1
00000817 3Brrrr               W  		BNE L280
0000081A 38rrrr               W  		BRA L295
0000081D                         L326:	; bb247
0000081D A809                    		MOV.L 04H[R0], R1
0000081F A189                    		MOV.L R1, 1CH[R0]
                                 ;    1550 		}
                                 ;    1551 	}
                                 ;    1552 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1552
00000821 3F660D                  		RTSD #34H, R6-R6
00000824                         _xQueueReceiveFromISR:
                                 		.STACK	_xQueueReceiveFromISR=36
                                 ;    1553 /*-----------------------------------------------------------*/
                                 ;    1554 
                                 ;    1555 BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1555
00000824 7100E0                  		ADD #0FFFFFFE0H, R0
00000827 A189                    		MOV.L R1, 1CH[R0]
00000829 A182                    		MOV.L R2, 18H[R0]
0000082B A10B                    		MOV.L R3, 14H[R0]
                                 ;    1556 {
                                 ;    1557 BaseType_t xReturn;
                                 ;    1558 UBaseType_t uxSavedInterruptStatus;
                                 ;    1559 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1559
0000082D E5000703                		MOV.L 1CH[R0], 0CH[R0]
00000831                         L328:	; entry.split
                                 ;    1560 
                                 ;    1561 	configASSERT( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1561
00000831 A889                    		MOV.L 0CH[R0], R1
00000833 6101                    		CMP #00H, R1
00000835 18                   S  		BNE L330
00000836                         L329:	; bb9
00000836 05rrrrrr             A  		BSR _vAssertCalled
0000083A                         L330:	; bb14
                                 ;    1562 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1562
0000083A A981                    		MOV.L 18H[R0], R1
0000083C 6101                    		CMP #00H, R1
0000083E 10                   S  		BEQ L332
0000083F 2Err                 B  		BRA L334
00000841                         L331:	; bb15
00000841 05rrrrrr             A  		BSR _vAssertCalled
00000845 2Err                 B  		BRA L339
00000847                         L332:	; bb19
00000847 A889                    		MOV.L 0CH[R0], R1
00000849 AC11                    		MOV.L 40H[R1], R1
0000084B 6101                    		CMP #00H, R1
0000084D 10                   S  		BEQ L334
0000084E                         L333:	; bb25
0000084E F80601                  		MOV.L #00000001H, [R0]
00000851 08                   S  		BRA L335
00000852                         L334:	; bb26
00000852 F80600                  		MOV.L #00000000H, [R0]
00000855                         L335:	; bb27
00000855 EC01                    		MOV.L [R0], R1
00000857 6101                    		CMP #00H, R1
00000859 10                   S  		BEQ L337
0000085A                         L336:	; bb31
0000085A F80600                  		MOV.L #00000000H, [R0]
0000085D 08                   S  		BRA L338
0000085E                         L337:	; bb32
0000085E F80601                  		MOV.L #00000001H, [R0]
00000861                         L338:	; bb33
00000861 EC01                    		MOV.L [R0], R1
00000863 6101                    		CMP #00H, R1
00000865 20rr                    		BEQ L331
00000867                         L339:	; bb40
                                 ;    1563 
                                 ;    1564 	/* RTOS ports that support interrupt nesting have the concept of a maximum
                                 ;    1565 	system call (or maximum API call) interrupt priority.  Interrupts that are
                                 ;    1566 	above the maximum system call priority are kept permanently enabled, even
                                 ;    1567 	when the RTOS kernel is in a critical section, but cannot make any calls to
                                 ;    1568 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
                                 ;    1569 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
                                 ;    1570 	failure if a FreeRTOS API function is called from an interrupt that has been
                                 ;    1571 	assigned a priority above the configured maximum system call priority.
                                 ;    1572 	Only FreeRTOS functions that end in FromISR can be called from interrupts
                                 ;    1573 	that have been assigned a priority at or (logically) below the maximum
                                 ;    1574 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
                                 ;    1575 	safe API to ensure interrupt entry is as fast and as simple as possible.
                                 ;    1576 	More information (albeit Cortex-M specific) is provided on the following
                                 ;    1577 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
                                 ;    1578 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1578
00000867 FD6A0E                  		MVFC PSW, R14
0000086A FD67EE                  		REVL R14, R14
0000086D 64FE                    		AND #0FH, R14
0000086F 616E                    		CMP #06H, R14
00000871 29rr                    		BLT L341
00000873                         L340:	; bb41
00000873 05rrrrrr             A  		BSR _vAssertCalled
00000877                         L341:	; bb50
                                 ;    1579 
                                 ;    1580 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1580
00000877 FD6A0E                  		MVFC PSW, R14
0000087A FD67E1                  		REVL R14, R1
0000087D 64F1                    		AND #0FH, R1
0000087F A081                    		MOV.L R1, 08H[R0]
00000881 757005                  		MVTIPL #05H
00000884                         L342:	; bb50.split
                                 ;    1581 	{
                                 ;    1582 		/* Cannot block in an ISR, so check there is data available. */
                                 ;    1583 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1583
00000884 A889                    		MOV.L 0CH[R0], R1
00000886 AB91                    		MOV.L 38H[R1], R1
00000888 6101                    		CMP #00H, R1
0000088A 20rr                    		BEQ L352
0000088C                         L343:	; bb55
                                 ;    1584 		{
                                 ;    1585 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
                                 ;    1586 
                                 ;    1587 			prvCopyDataFromQueue( pxQueue, pvBuffer );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1587
0000088C A982                    		MOV.L 18H[R0], R2
0000088E A889                    		MOV.L 0CH[R0], R1
00000890 39rrrr               W  		BSR __$prvCopyDataFromQueue
00000893                         L344:	; bb55.split
                                 ;    1588 			--( pxQueue->uxMessagesWaiting );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1588
00000893 A889                    		MOV.L 0CH[R0], R1
00000895 AB92                    		MOV.L 38H[R1], R2
00000897 6012                    		SUB #01H, R2
00000899 A392                    		MOV.L R2, 38H[R1]
0000089B                         L345:	; bb55.split1
                                 ;    1589 
                                 ;    1590 			/* If the queue is locked the event list will not be modified.
                                 ;    1591 			Instead update the lock count so the task that unlocks the queue
                                 ;    1592 			will know that an ISR has removed data while the queue was
                                 ;    1593 			locked. */
                                 ;    1594 			if( pxQueue->xRxLock == queueUNLOCKED )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1594
0000089B A889                    		MOV.L 0CH[R0], R1
0000089D AC19                    		MOV.L 44H[R1], R1
0000089F 7501FF                  		CMP #0FFFFFFFFH, R1
000008A2 A889                    		MOV.L 0CH[R0], R1
000008A4 21rr                    		BNE L350
000008A6                         L346:	; bb64
                                 ;    1595 			{
                                 ;    1596 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1596
000008A6 A911                    		MOV.L 10H[R1], R1
000008A8 6101                    		CMP #00H, R1
000008AA 20rr                    		BEQ L351
000008AC                         L347:	; bb66
                                 ;    1597 				{
                                 ;    1598 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1598
000008AC A889                    		MOV.L 0CH[R0], R1
000008AE 711110                  		ADD #10H, R1
000008B1 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
000008B5 6101                    		CMP #00H, R1
000008B7 20rr                    		BEQ L351
000008B9                         L348:	; bb68
                                 ;    1599 					{
                                 ;    1600 						/* The task waiting has a higher priority than us so
                                 ;    1601 						force a context switch. */
                                 ;    1602 						if( pxHigherPriorityTaskWoken != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1602
000008B9 A909                    		MOV.L 14H[R0], R1
000008BB 6101                    		CMP #00H, R1
000008BD 20rr                    		BEQ L351
000008BF                         L349:	; bb69
                                 ;    1603 						{
                                 ;    1604 							*pxHigherPriorityTaskWoken = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1604
000008BF A909                    		MOV.L 14H[R0], R1
000008C1 F81601                  		MOV.L #00000001H, [R1]
000008C4 08                   S  		BRA L351
000008C5                         L350:	; bb97
                                 ;    1605 						}
                                 ;    1606 						else
                                 ;    1607 						{
                                 ;    1608 							mtCOVERAGE_TEST_MARKER();
                                 ;    1609 						}
                                 ;    1610 					}
                                 ;    1611 					else
                                 ;    1612 					{
                                 ;    1613 						mtCOVERAGE_TEST_MARKER();
                                 ;    1614 					}
                                 ;    1615 				}
                                 ;    1616 				else
                                 ;    1617 				{
                                 ;    1618 					mtCOVERAGE_TEST_MARKER();
                                 ;    1619 				}
                                 ;    1620 			}
                                 ;    1621 			else
                                 ;    1622 			{
                                 ;    1623 				/* Increment the lock count so the task that unlocks the queue
                                 ;    1624 				knows that data was removed while it was locked. */
                                 ;    1625 				++( pxQueue->xRxLock );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1625
000008C5 AC1A                    		MOV.L 44H[R1], R2
000008C7 6212                    		ADD #01H, R2
000008C9 A41A                    		MOV.L R2, 44H[R1]
000008CB                         L351:	; bb108
                                 ;    1626 			}
                                 ;    1627 
                                 ;    1628 			xReturn = pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1628
000008CB 3E0101                  		MOV.L #00000001H, 04H[R0]
000008CE 08                   S  		BRA L353
000008CF                         L352:	; bb109
                                 ;    1629 		}
                                 ;    1630 		else
                                 ;    1631 		{
                                 ;    1632 			xReturn = pdFAIL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1632
000008CF 3E0100                  		MOV.L #00000000H, 04H[R0]
000008D2                         L353:	; bb116
                                 ;    1633 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
                                 ;    1634 		}
                                 ;    1635 	}
                                 ;    1636 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1636
000008D2 A881                    		MOV.L 08H[R0], R1
000008D4 6DC1                    		SHLL #1CH, R1
000008D6 6841                    		SHLR #04H, R1
000008D8 FD6A0E                  		MVFC PSW, R14
000008DB 742EFFFFFFF0            		AND #0F0FFFFFFH, R14
000008E1 57E1                    		OR R14, R1
000008E3 FD6810                  		MVTC R1, PSW
000008E6                         L354:	; bb116.split
                                 ;    1637 
                                 ;    1638 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1638
000008E6 A809                    		MOV.L 04H[R0], R1
000008E8 A101                    		MOV.L R1, 10H[R0]
000008EA                         L355:	; bb116.split2
                                 ;    1639 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1639
000008EA 6708                    		RTSD #20H
000008EC                         _xQueuePeekFromISR:
                                 		.STACK	_xQueuePeekFromISR=36
                                 ;    1640 /*-----------------------------------------------------------*/
                                 ;    1641 
                                 ;    1642 BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1642
000008EC 7100E0                  		ADD #0FFFFFFE0H, R0
000008EF A189                    		MOV.L R1, 1CH[R0]
000008F1 A182                    		MOV.L R2, 18H[R0]
                                 ;    1643 {
                                 ;    1644 BaseType_t xReturn;
                                 ;    1645 UBaseType_t uxSavedInterruptStatus;
                                 ;    1646 int8_t *pcOriginalReadPosition;
                                 ;    1647 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1647
000008F3 E5000704                		MOV.L 1CH[R0], 10H[R0]
000008F7                         L357:	; entry.split
                                 ;    1648 
                                 ;    1649 	configASSERT( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1649
000008F7 A901                    		MOV.L 10H[R0], R1
000008F9 6101                    		CMP #00H, R1
000008FB 18                   S  		BNE L359
000008FC                         L358:	; bb9
000008FC 05rrrrrr             A  		BSR _vAssertCalled
00000900                         L359:	; bb14
                                 ;    1650 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1650
00000900 A981                    		MOV.L 18H[R0], R1
00000902 6101                    		CMP #00H, R1
00000904 10                   S  		BEQ L361
00000905 2Err                 B  		BRA L363
00000907                         L360:	; bb15
00000907 05rrrrrr             A  		BSR _vAssertCalled
0000090B 2Err                 B  		BRA L368
0000090D                         L361:	; bb19
0000090D A901                    		MOV.L 10H[R0], R1
0000090F AC11                    		MOV.L 40H[R1], R1
00000911 6101                    		CMP #00H, R1
00000913 10                   S  		BEQ L363
00000914                         L362:	; bb25
00000914 F80601                  		MOV.L #00000001H, [R0]
00000917 08                   S  		BRA L364
00000918                         L363:	; bb26
00000918 F80600                  		MOV.L #00000000H, [R0]
0000091B                         L364:	; bb27
0000091B EC01                    		MOV.L [R0], R1
0000091D 6101                    		CMP #00H, R1
0000091F 10                   S  		BEQ L366
00000920                         L365:	; bb31
00000920 F80600                  		MOV.L #00000000H, [R0]
00000923 08                   S  		BRA L367
00000924                         L366:	; bb32
00000924 F80601                  		MOV.L #00000001H, [R0]
00000927                         L367:	; bb33
00000927 EC01                    		MOV.L [R0], R1
00000929 6101                    		CMP #00H, R1
0000092B 20rr                    		BEQ L360
0000092D                         L368:	; bb40
                                 ;    1651 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1651
0000092D A901                    		MOV.L 10H[R0], R1
0000092F AC11                    		MOV.L 40H[R1], R1
00000931 6101                    		CMP #00H, R1
00000933 18                   S  		BNE L370
00000934                         L369:	; bb41
00000934 05rrrrrr             A  		BSR _vAssertCalled
00000938                         L370:	; bb51
                                 ;    1652 
                                 ;    1653 	/* RTOS ports that support interrupt nesting have the concept of a maximum
                                 ;    1654 	system call (or maximum API call) interrupt priority.  Interrupts that are
                                 ;    1655 	above the maximum system call priority are kept permanently enabled, even
                                 ;    1656 	when the RTOS kernel is in a critical section, but cannot make any calls to
                                 ;    1657 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
                                 ;    1658 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
                                 ;    1659 	failure if a FreeRTOS API function is called from an interrupt that has been
                                 ;    1660 	assigned a priority above the configured maximum system call priority.
                                 ;    1661 	Only FreeRTOS functions that end in FromISR can be called from interrupts
                                 ;    1662 	that have been assigned a priority at or (logically) below the maximum
                                 ;    1663 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
                                 ;    1664 	safe API to ensure interrupt entry is as fast and as simple as possible.
                                 ;    1665 	More information (albeit Cortex-M specific) is provided on the following
                                 ;    1666 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
                                 ;    1667 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1667
00000938 FD6A0E                  		MVFC PSW, R14
0000093B FD67EE                  		REVL R14, R14
0000093E 64FE                    		AND #0FH, R14
00000940 616E                    		CMP #06H, R14
00000942 29rr                    		BLT L372
00000944                         L371:	; bb52
00000944 05rrrrrr             A  		BSR _vAssertCalled
00000948                         L372:	; bb61
                                 ;    1668 
                                 ;    1669 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1669
00000948 FD6A0E                  		MVFC PSW, R14
0000094B FD67E1                  		REVL R14, R1
0000094E 64F1                    		AND #0FH, R1
00000950 A081                    		MOV.L R1, 08H[R0]
00000952 757005                  		MVTIPL #05H
00000955                         L373:	; bb61.split
                                 ;    1670 	{
                                 ;    1671 		/* Cannot block in an ISR, so check there is data available. */
                                 ;    1672 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1672
00000955 A901                    		MOV.L 10H[R0], R1
00000957 AB91                    		MOV.L 38H[R1], R1
00000959 6101                    		CMP #00H, R1
0000095B 20rr                    		BEQ L378
0000095D                         L374:	; bb66
                                 ;    1673 		{
                                 ;    1674 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
                                 ;    1675 
                                 ;    1676 			/* Remember the read position so it can be reset as nothing is
                                 ;    1677 			actually being removed from the queue. */
                                 ;    1678 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1678
0000095D A901                    		MOV.L 10H[R0], R1
0000095F E5100303                		MOV.L 0CH[R1], 0CH[R0]
00000963                         L375:	; bb66.split
                                 ;    1679 			prvCopyDataFromQueue( pxQueue, pvBuffer );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1679
00000963 A982                    		MOV.L 18H[R0], R2
00000965 A901                    		MOV.L 10H[R0], R1
00000967 39rrrr               W  		BSR __$prvCopyDataFromQueue
0000096A                         L376:	; bb66.split1
                                 ;    1680 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1680
0000096A A889                    		MOV.L 0CH[R0], R1
0000096C A902                    		MOV.L 10H[R0], R2
0000096E A0A9                    		MOV.L R1, 0CH[R2]
00000970                         L377:	; bb66.split2
                                 ;    1681 
                                 ;    1682 			xReturn = pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1682
00000970 3E0101                  		MOV.L #00000001H, 04H[R0]
00000973 08                   S  		BRA L379
00000974                         L378:	; bb77
                                 ;    1683 		}
                                 ;    1684 		else
                                 ;    1685 		{
                                 ;    1686 			xReturn = pdFAIL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1686
00000974 3E0100                  		MOV.L #00000000H, 04H[R0]
00000977                         L379:	; bb85
                                 ;    1687 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
                                 ;    1688 		}
                                 ;    1689 	}
                                 ;    1690 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1690
00000977 A881                    		MOV.L 08H[R0], R1
00000979 6DC1                    		SHLL #1CH, R1
0000097B 6841                    		SHLR #04H, R1
0000097D FD6A0E                  		MVFC PSW, R14
00000980 742EFFFFFFF0            		AND #0F0FFFFFFH, R14
00000986 57E1                    		OR R14, R1
00000988 FD6810                  		MVTC R1, PSW
0000098B                         L380:	; bb85.split
                                 ;    1691 
                                 ;    1692 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1692
0000098B A809                    		MOV.L 04H[R0], R1
0000098D A109                    		MOV.L R1, 14H[R0]
0000098F                         L381:	; bb85.split3
                                 ;    1693 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1693
0000098F 6708                    		RTSD #20H
00000991                         _uxQueueMessagesWaiting:
                                 		.STACK	_uxQueueMessagesWaiting=16
                                 ;    1694 /*-----------------------------------------------------------*/
                                 ;    1695 
                                 ;    1696 UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1696
00000991 60C0                    		SUB #0CH, R0
00000993 A081                    		MOV.L R1, 08H[R0]
                                 ;    1697 {
                                 ;    1698 UBaseType_t uxReturn;
                                 ;    1699 
                                 ;    1700 	configASSERT( xQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1700
00000995 6101                    		CMP #00H, R1
00000997 18                   S  		BNE L384
00000998                         L383:	; bb3
00000998 05rrrrrr             A  		BSR _vAssertCalled
0000099C                         L384:	; bb7
                                 ;    1701 
                                 ;    1702 	taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1702
0000099C 05rrrrrr             A  		BSR _vTaskEnterCritical
000009A0                         L385:	; bb7.split
                                 ;    1703 	{
                                 ;    1704 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1704
000009A0 A881                    		MOV.L 08H[R0], R1
000009A2 E1100E                  		MOV.L 38H[R1], [R0]
000009A5                         L386:	; bb7.split1
                                 ;    1705 	}
                                 ;    1706 	taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1706
000009A5 05rrrrrr             A  		BSR _vTaskExitCritical
000009A9                         L387:	; bb7.split2
                                 ;    1707 
                                 ;    1708 	return uxReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1708
000009A9 EC01                    		MOV.L [R0], R1
000009AB A009                    		MOV.L R1, 04H[R0]
000009AD                         L388:	; bb7.split3
                                 ;    1709 } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1709
000009AD 6703                    		RTSD #0CH
000009AF                         _uxQueueSpacesAvailable:
                                 		.STACK	_uxQueueSpacesAvailable=20
                                 ;    1710 /*-----------------------------------------------------------*/
                                 ;    1711 
                                 ;    1712 UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1712
000009AF 7100F0                  		ADD #0FFFFFFF0H, R0
000009B2 A089                    		MOV.L R1, 0CH[R0]
                                 ;    1713 {
                                 ;    1714 UBaseType_t uxReturn;
                                 ;    1715 Queue_t *pxQueue;
                                 ;    1716 
                                 ;    1717 	pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1717
000009B4 A009                    		MOV.L R1, 04H[R0]
000009B6                         L390:	; entry.split
                                 ;    1718 	configASSERT( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1718
000009B6 A809                    		MOV.L 04H[R0], R1
000009B8 6101                    		CMP #00H, R1
000009BA 18                   S  		BNE L392
000009BB                         L391:	; bb6
000009BB 05rrrrrr             A  		BSR _vAssertCalled
000009BF                         L392:	; bb10
                                 ;    1719 
                                 ;    1720 	taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1720
000009BF 05rrrrrr             A  		BSR _vTaskEnterCritical
000009C3                         L393:	; bb10.split
                                 ;    1721 	{
                                 ;    1722 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1722
000009C3 A809                    		MOV.L 04H[R0], R1
000009C5 AB9A                    		MOV.L 3CH[R1], R2
000009C7 0681120E                		SUB 38H[R1].L, R2
000009CB E302                    		MOV.L R2, [R0]
000009CD                         L394:	; bb10.split1
                                 ;    1723 	}
                                 ;    1724 	taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1724
000009CD 05rrrrrr             A  		BSR _vTaskExitCritical
000009D1                         L395:	; bb10.split2
                                 ;    1725 
                                 ;    1726 	return uxReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1726
000009D1 EC01                    		MOV.L [R0], R1
000009D3 A081                    		MOV.L R1, 08H[R0]
000009D5                         L396:	; bb10.split3
                                 ;    1727 } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1727
000009D5 6704                    		RTSD #10H
000009D7                         _uxQueueMessagesWaitingFromISR:
                                 		.STACK	_uxQueueMessagesWaitingFromISR=16
                                 ;    1728 /*-----------------------------------------------------------*/
                                 ;    1729 
                                 ;    1730 UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1730
000009D7 60C0                    		SUB #0CH, R0
000009D9 A081                    		MOV.L R1, 08H[R0]
                                 ;    1731 {
                                 ;    1732 UBaseType_t uxReturn;
                                 ;    1733 
                                 ;    1734 	configASSERT( xQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1734
000009DB 6101                    		CMP #00H, R1
000009DD 18                   S  		BNE L399
000009DE                         L398:	; bb3
000009DE 05rrrrrr             A  		BSR _vAssertCalled
000009E2                         L399:	; bb7
                                 ;    1735 
                                 ;    1736 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1736
000009E2 A881                    		MOV.L 08H[R0], R1
000009E4 E1100E                  		MOV.L 38H[R1], [R0]
000009E7                         L400:	; bb7.split
                                 ;    1737 
                                 ;    1738 	return uxReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1738
000009E7 EC01                    		MOV.L [R0], R1
000009E9 A009                    		MOV.L R1, 04H[R0]
000009EB                         L401:	; bb7.split1
                                 ;    1739 } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1739
000009EB 6703                    		RTSD #0CH
000009ED                         _vQueueDelete:
                                 		.STACK	_vQueueDelete=12
                                 ;    1740 /*-----------------------------------------------------------*/
                                 ;    1741 
                                 ;    1742 void vQueueDelete( QueueHandle_t xQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1742
000009ED 6080                    		SUB #08H, R0
000009EF A009                    		MOV.L R1, 04H[R0]
                                 ;    1743 {
                                 ;    1744 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1744
000009F1 E301                    		MOV.L R1, [R0]
000009F3                         L403:	; entry.split
                                 ;    1745 
                                 ;    1746 	configASSERT( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1746
000009F3 EC01                    		MOV.L [R0], R1
000009F5 6101                    		CMP #00H, R1
000009F7 18                   S  		BNE L405
000009F8                         L404:	; bb4
000009F8 05rrrrrr             A  		BSR _vAssertCalled
000009FC                         L405:	; bb8
                                 ;    1747 
                                 ;    1748 	traceQUEUE_DELETE( pxQueue );
                                 ;    1749 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
                                 ;    1750 	{
                                 ;    1751 		vQueueUnregisterQueue( pxQueue );
                                 ;    1752 	}
                                 ;    1753 	#endif
                                 ;    1754 	vPortFree( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1754
000009FC EC01                    		MOV.L [R0], R1
000009FE 05rrrrrr             A  		BSR _vPortFree
00000A02 6702                    		RTSD #08H
00000A04                         _uxQueueGetQueueNumber:
                                 		.STACK	_uxQueueGetQueueNumber=12
                                 ;    1755 }
                                 ;    1756 /*-----------------------------------------------------------*/
                                 ;    1757 
                                 ;    1758 #if ( configUSE_TRACE_FACILITY == 1 )
                                 ;    1759 
                                 ;    1760 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1760
00000A04 6080                    		SUB #08H, R0
00000A06 A009                    		MOV.L R1, 04H[R0]
                                 ;    1761 	{
                                 ;    1762 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1762
00000A08 AC99                    		MOV.L 4CH[R1], R1
00000A0A E301                    		MOV.L R1, [R0]
00000A0C                         L407:	; entry.split
                                 ;    1763 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1763
00000A0C 6702                    		RTSD #08H
00000A0E                         _vQueueSetQueueNumber:
                                 		.STACK	_vQueueSetQueueNumber=12
                                 ;    1764 
                                 ;    1765 #endif /* configUSE_TRACE_FACILITY */
                                 ;    1766 /*-----------------------------------------------------------*/
                                 ;    1767 
                                 ;    1768 #if ( configUSE_TRACE_FACILITY == 1 )
                                 ;    1769 
                                 ;    1770 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1770
00000A0E 6080                    		SUB #08H, R0
00000A10 A009                    		MOV.L R1, 04H[R0]
00000A12 E302                    		MOV.L R2, [R0]
                                 ;    1771 	{
                                 ;    1772 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1772
00000A14 A809                    		MOV.L 04H[R0], R1
00000A16 A49A                    		MOV.L R2, 4CH[R1]
00000A18 6702                    		RTSD #08H
00000A1A                         _ucQueueGetQueueType:
                                 		.STACK	_ucQueueGetQueueType=12
                                 ;    1773 	}
                                 ;    1774 
                                 ;    1775 #endif /* configUSE_TRACE_FACILITY */
                                 ;    1776 /*-----------------------------------------------------------*/
                                 ;    1777 
                                 ;    1778 #if ( configUSE_TRACE_FACILITY == 1 )
                                 ;    1779 
                                 ;    1780 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1780
00000A1A 6080                    		SUB #08H, R0
00000A1C A009                    		MOV.L R1, 04H[R0]
                                 ;    1781 	{
                                 ;    1782 		return ( ( Queue_t * ) xQueue )->ucQueueType;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1782
00000A1E C5105003                		MOV.B 50H[R1], 03H[R0]
00000A22 B089                    		MOVU.B 03H[R0], R1
00000A24                         L410:	; entry.split
                                 ;    1783 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1783
00000A24 5B11                    		MOVU.B R1, R1
00000A26 6702                    		RTSD #08H
00000A28                         __$prvCopyDataToQueue:
                                 		.STACK	__$prvCopyDataToQueue=24
                                 ;    1784 
                                 ;    1785 #endif /* configUSE_TRACE_FACILITY */
                                 ;    1786 /*-----------------------------------------------------------*/
                                 ;    1787 
                                 ;    1788 static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1788
00000A28 7100EC                  		ADD #0FFFFFFECH, R0
00000A2B A101                    		MOV.L R1, 10H[R0]
00000A2D A08A                    		MOV.L R2, 0CH[R0]
00000A2F A083                    		MOV.L R3, 08H[R0]
                                 ;    1789 {
                                 ;    1790 BaseType_t xReturn = pdFALSE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1790
00000A31 F80600                  		MOV.L #00000000H, [R0]
00000A34                         L412:	; entry.split
                                 ;    1791 
                                 ;    1792 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1792
00000A34 A901                    		MOV.L 10H[R0], R1
00000A36 AC11                    		MOV.L 40H[R1], R1
00000A38 6101                    		CMP #00H, R1
00000A3A 21rr                    		BNE L416
00000A3C                         L413:	; bb6
                                 ;    1793 	{
                                 ;    1794 		#if ( configUSE_MUTEXES == 1 )
                                 ;    1795 		{
                                 ;    1796 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1796
00000A3C A901                    		MOV.L 10H[R0], R1
00000A3E EC1E                    		MOV.L [R1], R14
00000A40 610E                    		CMP #00H, R14
00000A42 21rr                    		BNE L428
00000A44                         L414:	; bb7
                                 ;    1797 			{
                                 ;    1798 				/* The mutex is no longer being held. */
                                 ;    1799 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1799
00000A44 A901                    		MOV.L 10H[R0], R1
00000A46 A819                    		MOV.L 04H[R1], R1
00000A48 05rrrrrr             A  		BSR _xTaskPriorityDisinherit
00000A4C E301                    		MOV.L R1, [R0]
00000A4E                         L415:	; bb7.split
                                 ;    1800 				pxQueue->pxMutexHolder = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1800
00000A4E A901                    		MOV.L 10H[R0], R1
00000A50 3E1100                  		MOV.L #00000000H, 04H[R1]
00000A53 2Err                 B  		BRA L428
00000A55                         L416:	; bb22
                                 ;    1801 			}
                                 ;    1802 			else
                                 ;    1803 			{
                                 ;    1804 				mtCOVERAGE_TEST_MARKER();
                                 ;    1805 			}
                                 ;    1806 		}
                                 ;    1807 		#endif /* configUSE_MUTEXES */
                                 ;    1808 	}
                                 ;    1809 	else if( xPosition == queueSEND_TO_BACK )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1809
00000A55 A881                    		MOV.L 08H[R0], R1
00000A57 6101                    		CMP #00H, R1
00000A59 A901                    		MOV.L 10H[R0], R1
00000A5B 21rr                    		BNE L421
00000A5D                         L417:	; bb23
                                 ;    1810 	{
                                 ;    1811 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1811
00000A5D A902                    		MOV.L 10H[R0], R2
00000A5F AC23                    		MOV.L 40H[R2], R3
00000A61 A891                    		MOV.L 08H[R1], R1
00000A63 A88A                    		MOV.L 0CH[R0], R2
00000A65 7F8F                    		SMOVF
00000A67                         L418:	; bb23.split
                                 ;    1812 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1812
00000A67 A901                    		MOV.L 10H[R0], R1
00000A69 A892                    		MOV.L 08H[R1], R2
00000A6B 06891210                		ADD 40H[R1].L, R2
00000A6F A092                    		MOV.L R2, 08H[R1]
00000A71                         L419:	; bb23.split1
                                 ;    1813 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1813
00000A71 A901                    		MOV.L 10H[R0], R1
00000A73 A892                    		MOV.L 08H[R1], R2
00000A75 06851201                		CMP 04H[R1].L, R2
00000A79 23rr                    		BLTU L428
00000A7B                         L420:	; bb39
                                 ;    1814 		{
                                 ;    1815 			pxQueue->pcWriteTo = pxQueue->pcHead;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1815
00000A7B A901                    		MOV.L 10H[R0], R1
00000A7D E41102                  		MOV.L [R1], 08H[R1]
00000A80 2Err                 B  		BRA L428
00000A82                         L421:	; bb56
                                 ;    1816 		}
                                 ;    1817 		else
                                 ;    1818 		{
                                 ;    1819 			mtCOVERAGE_TEST_MARKER();
                                 ;    1820 		}
                                 ;    1821 	}
                                 ;    1822 	else
                                 ;    1823 	{
                                 ;    1824 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts ar
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1824
00000A82 A902                    		MOV.L 10H[R0], R2
00000A84 AC23                    		MOV.L 40H[R2], R3
00000A86 A899                    		MOV.L 0CH[R1], R1
00000A88 A88A                    		MOV.L 0CH[R0], R2
00000A8A 7F8F                    		SMOVF
00000A8C                         L422:	; bb56.split
                                 ;    1825 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1825
00000A8C A901                    		MOV.L 10H[R0], R1
00000A8E A89A                    		MOV.L 0CH[R1], R2
00000A90 06811210                		SUB 40H[R1].L, R2
00000A94 A09A                    		MOV.L R2, 0CH[R1]
00000A96                         L423:	; bb56.split2
                                 ;    1826 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1826
00000A96 A901                    		MOV.L 10H[R0], R1
00000A98 A89A                    		MOV.L 0CH[R1], R2
00000A9A 068412                  		CMP [R1].L, R2
00000A9D 22rr                    		BGEU L425
00000A9F                         L424:	; bb75
                                 ;    1827 		{
                                 ;    1828 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1828
00000A9F A901                    		MOV.L 10H[R0], R1
00000AA1 A81A                    		MOV.L 04H[R1], R2
00000AA3 06811210                		SUB 40H[R1].L, R2
00000AA7 A09A                    		MOV.L R2, 0CH[R1]
00000AA9                         L425:	; bb99
                                 ;    1829 		}
                                 ;    1830 		else
                                 ;    1831 		{
                                 ;    1832 			mtCOVERAGE_TEST_MARKER();
                                 ;    1833 		}
                                 ;    1834 
                                 ;    1835 		if( xPosition == queueOVERWRITE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1835
00000AA9 A881                    		MOV.L 08H[R0], R1
00000AAB 6121                    		CMP #02H, R1
00000AAD 21rr                    		BNE L428
00000AAF                         L426:	; bb101
                                 ;    1836 		{
                                 ;    1837 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1837
00000AAF A901                    		MOV.L 10H[R0], R1
00000AB1 AB91                    		MOV.L 38H[R1], R1
00000AB3 6101                    		CMP #00H, R1
00000AB5 10                   S  		BEQ L428
00000AB6                         L427:	; bb102
                                 ;    1838 			{
                                 ;    1839 				/* An item is not being added but overwritten, so subtract
                                 ;    1840 				one from the recorded number of items in the queue so when
                                 ;    1841 				one is added again below the number of recorded items remains
                                 ;    1842 				correct. */
                                 ;    1843 				--( pxQueue->uxMessagesWaiting );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1843
00000AB6 A901                    		MOV.L 10H[R0], R1
00000AB8 AB92                    		MOV.L 38H[R1], R2
00000ABA 6012                    		SUB #01H, R2
00000ABC A392                    		MOV.L R2, 38H[R1]
00000ABE                         L428:	; bb132
                                 ;    1844 			}
                                 ;    1845 			else
                                 ;    1846 			{
                                 ;    1847 				mtCOVERAGE_TEST_MARKER();
                                 ;    1848 			}
                                 ;    1849 		}
                                 ;    1850 		else
                                 ;    1851 		{
                                 ;    1852 			mtCOVERAGE_TEST_MARKER();
                                 ;    1853 		}
                                 ;    1854 	}
                                 ;    1855 
                                 ;    1856 	++( pxQueue->uxMessagesWaiting );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1856
00000ABE A901                    		MOV.L 10H[R0], R1
00000AC0 AB92                    		MOV.L 38H[R1], R2
00000AC2 6212                    		ADD #01H, R2
00000AC4 A392                    		MOV.L R2, 38H[R1]
00000AC6                         L429:	; bb132.split
                                 ;    1857 
                                 ;    1858 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1858
00000AC6 EC01                    		MOV.L [R0], R1
00000AC8 A009                    		MOV.L R1, 04H[R0]
00000ACA                         L430:	; bb132.split3
                                 ;    1859 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1859
00000ACA 6705                    		RTSD #14H
00000ACC                         __$prvCopyDataFromQueue:
                                 		.STACK	__$prvCopyDataFromQueue=12
                                 ;    1860 /*-----------------------------------------------------------*/
                                 ;    1861 
                                 ;    1862 static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1862
00000ACC 6080                    		SUB #08H, R0
00000ACE A009                    		MOV.L R1, 04H[R0]
00000AD0 E302                    		MOV.L R2, [R0]
                                 ;    1863 {
                                 ;    1864 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1864
00000AD2 A809                    		MOV.L 04H[R0], R1
00000AD4 AC11                    		MOV.L 40H[R1], R1
00000AD6 6101                    		CMP #00H, R1
00000AD8 20rr                    		BEQ L436
00000ADA                         L432:	; bb3
                                 ;    1865 	{
                                 ;    1866 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1866
00000ADA A809                    		MOV.L 04H[R0], R1
00000ADC A89A                    		MOV.L 0CH[R1], R2
00000ADE 06891210                		ADD 40H[R1].L, R2
00000AE2 A09A                    		MOV.L R2, 0CH[R1]
00000AE4                         L433:	; bb3.split
                                 ;    1867 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solution
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1867
00000AE4 A809                    		MOV.L 04H[R0], R1
00000AE6 A89A                    		MOV.L 0CH[R1], R2
00000AE8 06851201                		CMP 04H[R1].L, R2
00000AEC 23rr                    		BLTU L435
00000AEE                         L434:	; bb12
                                 ;    1868 		{
                                 ;    1869 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1869
00000AEE A809                    		MOV.L 04H[R0], R1
00000AF0 E41103                  		MOV.L [R1], 0CH[R1]
00000AF3                         L435:	; bb29
                                 ;    1870 		}
                                 ;    1871 		else
                                 ;    1872 		{
                                 ;    1873 			mtCOVERAGE_TEST_MARKER();
                                 ;    1874 		}
                                 ;    1875 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1875
00000AF3 A809                    		MOV.L 04H[R0], R1
00000AF5 AC13                    		MOV.L 40H[R1], R3
00000AF7 A89A                    		MOV.L 0CH[R1], R2
00000AF9 EC01                    		MOV.L [R0], R1
00000AFB 7F8F                    		SMOVF
00000AFD 6702                    		RTSD #08H
00000AFF                         L436:	; return
                                 ;    1876 	}
                                 ;    1877 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1877
00000AFF 6702                    		RTSD #08H
00000B01                         __$prvUnlockQueue:
                                 		.STACK	__$prvUnlockQueue=8
                                 ;    1878 /*-----------------------------------------------------------*/
                                 ;    1879 
                                 ;    1880 static void prvUnlockQueue( Queue_t * const pxQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1880
00000B01 6040                    		SUB #04H, R0
00000B03 E301                    		MOV.L R1, [R0]
                                 ;    1881 {
                                 ;    1882 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
                                 ;    1883 
                                 ;    1884 	/* The lock counts contains the number of extra data items placed or
                                 ;    1885 	removed from the queue while the queue was locked.  When a queue is
                                 ;    1886 	locked items can be added or removed, but the event lists cannot be
                                 ;    1887 	updated. */
                                 ;    1888 	taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1888
00000B05 05rrrrrr             A  		BSR _vTaskEnterCritical
00000B09 2Err                 B  		BRA L445
00000B0B                         L438:	; bb2
                                 ;    1889 	{
                                 ;    1890 		/* See if data was added to the queue while it was locked. */
                                 ;    1891 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
                                 ;    1892 		{
                                 ;    1893 			/* Data was posted while the queue was locked.  Are any tasks
                                 ;    1894 			blocked waiting for data to become available? */
                                 ;    1895 			#if ( configUSE_QUEUE_SETS == 1 )
                                 ;    1896 			{
                                 ;    1897 				if( pxQueue->pxQueueSetContainer != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1897
00000B0B EC01                    		MOV.L [R0], R1
00000B0D AD1A                    		MOV.L 54H[R1], R2
00000B0F 6102                    		CMP #00H, R2
00000B11 20rr                    		BEQ L441
00000B13                         L439:	; bb4
00000B13 6602                    		MOV.L #00000000H, R2
                                 ;    1898 				{
                                 ;    1899 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1899
00000B15 39rrrr               W  		BSR __$prvNotifyQueueSetContainer
00000B18 6111                    		CMP #01H, R1
00000B1A 21rr                    		BNE L444
00000B1C                         L440:	; bb5
                                 ;    1900 					{
                                 ;    1901 						/* The queue is a member of a queue set, and posting to
                                 ;    1902 						the queue set caused a higher priority task to unblock.
                                 ;    1903 						A context switch is required. */
                                 ;    1904 						vTaskMissedYield();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1904
00000B1C 05rrrrrr             A  		BSR _vTaskMissedYield
00000B20 2Err                 B  		BRA L444
00000B22                         L441:	; bb12
                                 ;    1905 					}
                                 ;    1906 					else
                                 ;    1907 					{
                                 ;    1908 						mtCOVERAGE_TEST_MARKER();
                                 ;    1909 					}
                                 ;    1910 				}
                                 ;    1911 				else
                                 ;    1912 				{
                                 ;    1913 					/* Tasks that are removed from the event list will get added to
                                 ;    1914 					the pending ready list as the scheduler is still suspended. */
                                 ;    1915 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1915
00000B22 AA19                    		MOV.L 24H[R1], R1
00000B24 6101                    		CMP #00H, R1
00000B26 20rr                    		BEQ L446
00000B28                         L442:	; bb14
                                 ;    1916 					{
                                 ;    1917 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1917
00000B28 EC01                    		MOV.L [R0], R1
00000B2A 711124                  		ADD #24H, R1
00000B2D 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
00000B31 6101                    		CMP #00H, R1
00000B33 10                   S  		BEQ L444
00000B34                         L443:	; bb15
                                 ;    1918 						{
                                 ;    1919 							/* The task waiting has a higher priority so record that a
                                 ;    1920 							context	switch is required. */
                                 ;    1921 							vTaskMissedYield();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1921
00000B34 05rrrrrr             A  		BSR _vTaskMissedYield
00000B38                         L444:	; bb42
                                 ;    1922 						}
                                 ;    1923 						else
                                 ;    1924 						{
                                 ;    1925 							mtCOVERAGE_TEST_MARKER();
                                 ;    1926 						}
                                 ;    1927 					}
                                 ;    1928 					else
                                 ;    1929 					{
                                 ;    1930 						break;
                                 ;    1931 					}
                                 ;    1932 				}
                                 ;    1933 			}
                                 ;    1934 			#else /* configUSE_QUEUE_SETS */
                                 ;    1935 			{
                                 ;    1936 				/* Tasks that are removed from the event list will get added to
                                 ;    1937 				the pending ready list as the scheduler is still suspended. */
                                 ;    1938 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 ;    1939 				{
                                 ;    1940 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 ;    1941 					{
                                 ;    1942 						/* The task waiting has a higher priority so record that a
                                 ;    1943 						context	switch is required. */
                                 ;    1944 						vTaskMissedYield();
                                 ;    1945 					}
                                 ;    1946 					else
                                 ;    1947 					{
                                 ;    1948 						mtCOVERAGE_TEST_MARKER();
                                 ;    1949 					}
                                 ;    1950 				}
                                 ;    1951 				else
                                 ;    1952 				{
                                 ;    1953 					break;
                                 ;    1954 				}
                                 ;    1955 			}
                                 ;    1956 			#endif /* configUSE_QUEUE_SETS */
                                 ;    1957 
                                 ;    1958 			--( pxQueue->xTxLock );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1958
00000B38 EC01                    		MOV.L [R0], R1
00000B3A AC92                    		MOV.L 48H[R1], R2
00000B3C 6012                    		SUB #01H, R2
00000B3E A492                    		MOV.L R2, 48H[R1]
00000B40                         L445:	; bb47
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1891
00000B40 EC01                    		MOV.L [R0], R1
00000B42 AC91                    		MOV.L 48H[R1], R1
00000B44 6101                    		CMP #00H, R1
00000B46 2Arr                    		BGT L438
00000B48                         L446:	; bb55
                                 ;    1959 		}
                                 ;    1960 
                                 ;    1961 		pxQueue->xTxLock = queueUNLOCKED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1961
00000B48 EC01                    		MOV.L [R0], R1
00000B4A F91612FF                		MOV.L #0FFFFFFFFH, 48H[R1]
00000B4E                         L447:	; bb55.split
                                 ;    1962 	}
                                 ;    1963 	taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1963
00000B4E 05rrrrrr             A  		BSR _vTaskExitCritical
00000B52                         L448:	; bb55.split1
                                 ;    1964 
                                 ;    1965 	/* Do the same for the Rx lock. */
                                 ;    1966 	taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1966
00000B52 05rrrrrr             A  		BSR _vTaskEnterCritical
00000B56 2Err                 B  		BRA L453
00000B58                         L449:	; bb59
                                 ;    1967 	{
                                 ;    1968 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
                                 ;    1969 		{
                                 ;    1970 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1970
00000B58 EC01                    		MOV.L [R0], R1
00000B5A A911                    		MOV.L 10H[R1], R1
00000B5C 6101                    		CMP #00H, R1
00000B5E 20rr                    		BEQ L454
00000B60                         L450:	; bb61
                                 ;    1971 			{
                                 ;    1972 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1972
00000B60 EC01                    		MOV.L [R0], R1
00000B62 711110                  		ADD #10H, R1
00000B65 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
00000B69 6101                    		CMP #00H, R1
00000B6B 10                   S  		BEQ L452
00000B6C                         L451:	; bb62
                                 ;    1973 				{
                                 ;    1974 					vTaskMissedYield();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1974
00000B6C 05rrrrrr             A  		BSR _vTaskMissedYield
00000B70                         L452:	; bb70
                                 ;    1975 				}
                                 ;    1976 				else
                                 ;    1977 				{
                                 ;    1978 					mtCOVERAGE_TEST_MARKER();
                                 ;    1979 				}
                                 ;    1980 
                                 ;    1981 				--( pxQueue->xRxLock );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1981
00000B70 EC01                    		MOV.L [R0], R1
00000B72 AC1A                    		MOV.L 44H[R1], R2
00000B74 6012                    		SUB #01H, R2
00000B76 A41A                    		MOV.L R2, 44H[R1]
00000B78                         L453:	; bb87
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1968
00000B78 EC01                    		MOV.L [R0], R1
00000B7A AC19                    		MOV.L 44H[R1], R1
00000B7C 6101                    		CMP #00H, R1
00000B7E 2Arr                    		BGT L449
00000B80                         L454:	; bb95
                                 ;    1982 			}
                                 ;    1983 			else
                                 ;    1984 			{
                                 ;    1985 				break;
                                 ;    1986 			}
                                 ;    1987 		}
                                 ;    1988 
                                 ;    1989 		pxQueue->xRxLock = queueUNLOCKED;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1989
00000B80 EC01                    		MOV.L [R0], R1
00000B82 F91611FF                		MOV.L #0FFFFFFFFH, 44H[R1]
00000B86                         L455:	; bb95.split
                                 ;    1990 	}
                                 ;    1991 	taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1991
00000B86 05rrrrrr             A  		BSR _vTaskExitCritical
00000B8A 6701                    		RTSD #04H
00000B8C                         __$prvIsQueueEmpty:
                                 		.STACK	__$prvIsQueueEmpty=16
                                 ;    1992 }
                                 ;    1993 /*-----------------------------------------------------------*/
                                 ;    1994 
                                 ;    1995 static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1995
00000B8C 60C0                    		SUB #0CH, R0
00000B8E A081                    		MOV.L R1, 08H[R0]
                                 ;    1996 {
                                 ;    1997 BaseType_t xReturn;
                                 ;    1998 
                                 ;    1999 	taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",1999
00000B90 05rrrrrr             A  		BSR _vTaskEnterCritical
00000B94                         L457:	; entry.split
                                 ;    2000 	{
                                 ;    2001 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2001
00000B94 A881                    		MOV.L 08H[R0], R1
00000B96 AB91                    		MOV.L 38H[R1], R1
00000B98 6101                    		CMP #00H, R1
00000B9A 18                   S  		BNE L459
00000B9B                         L458:	; bb3
                                 ;    2002 		{
                                 ;    2003 			xReturn = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2003
00000B9B F80601                  		MOV.L #00000001H, [R0]
00000B9E 08                   S  		BRA L460
00000B9F                         L459:	; bb4
                                 ;    2004 		}
                                 ;    2005 		else
                                 ;    2006 		{
                                 ;    2007 			xReturn = pdFALSE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2007
00000B9F F80600                  		MOV.L #00000000H, [R0]
00000BA2                         L460:	; bb10
                                 ;    2008 		}
                                 ;    2009 	}
                                 ;    2010 	taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2010
00000BA2 05rrrrrr             A  		BSR _vTaskExitCritical
00000BA6                         L461:	; bb10.split
                                 ;    2011 
                                 ;    2012 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2012
00000BA6 EC01                    		MOV.L [R0], R1
00000BA8 A009                    		MOV.L R1, 04H[R0]
00000BAA                         L462:	; bb10.split1
                                 ;    2013 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2013
00000BAA 6703                    		RTSD #0CH
00000BAC                         _xQueueIsQueueEmptyFromISR:
                                 		.STACK	_xQueueIsQueueEmptyFromISR=16
                                 ;    2014 /*-----------------------------------------------------------*/
                                 ;    2015 
                                 ;    2016 BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2016
00000BAC 60C0                    		SUB #0CH, R0
00000BAE A081                    		MOV.L R1, 08H[R0]
                                 ;    2017 {
                                 ;    2018 BaseType_t xReturn;
                                 ;    2019 
                                 ;    2020 	configASSERT( xQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2020
00000BB0 6101                    		CMP #00H, R1
00000BB2 18                   S  		BNE L465
00000BB3                         L464:	; bb3
00000BB3 05rrrrrr             A  		BSR _vAssertCalled
00000BB7                         L465:	; bb8
                                 ;    2021 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2021
00000BB7 A881                    		MOV.L 08H[R0], R1
00000BB9 AB91                    		MOV.L 38H[R1], R1
00000BBB 6101                    		CMP #00H, R1
00000BBD 18                   S  		BNE L467
00000BBE                         L466:	; bb9
                                 ;    2022 	{
                                 ;    2023 		xReturn = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2023
00000BBE F80601                  		MOV.L #00000001H, [R0]
00000BC1 08                   S  		BRA L468
00000BC2                         L467:	; bb10
                                 ;    2024 	}
                                 ;    2025 	else
                                 ;    2026 	{
                                 ;    2027 		xReturn = pdFALSE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2027
00000BC2 F80600                  		MOV.L #00000000H, [R0]
00000BC5                         L468:	; bb18
                                 ;    2028 	}
                                 ;    2029 
                                 ;    2030 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2030
00000BC5 EC01                    		MOV.L [R0], R1
00000BC7 A009                    		MOV.L R1, 04H[R0]
00000BC9                         L469:	; bb18.split
                                 ;    2031 } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2031
00000BC9 6703                    		RTSD #0CH
00000BCB                         __$prvIsQueueFull:
                                 		.STACK	__$prvIsQueueFull=16
                                 ;    2032 /*-----------------------------------------------------------*/
                                 ;    2033 
                                 ;    2034 static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2034
00000BCB 60C0                    		SUB #0CH, R0
00000BCD A081                    		MOV.L R1, 08H[R0]
                                 ;    2035 {
                                 ;    2036 BaseType_t xReturn;
                                 ;    2037 
                                 ;    2038 	taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2038
00000BCF 05rrrrrr             A  		BSR _vTaskEnterCritical
00000BD3                         L471:	; entry.split
                                 ;    2039 	{
                                 ;    2040 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2040
00000BD3 A881                    		MOV.L 08H[R0], R1
00000BD5 AB91                    		MOV.L 38H[R1], R1
00000BD7 A882                    		MOV.L 08H[R0], R2
00000BD9 0685210F                		CMP 3CH[R2].L, R1
00000BDD 18                   S  		BNE L473
00000BDE                         L472:	; bb3
                                 ;    2041 		{
                                 ;    2042 			xReturn = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2042
00000BDE F80601                  		MOV.L #00000001H, [R0]
00000BE1 08                   S  		BRA L474
00000BE2                         L473:	; bb4
                                 ;    2043 		}
                                 ;    2044 		else
                                 ;    2045 		{
                                 ;    2046 			xReturn = pdFALSE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2046
00000BE2 F80600                  		MOV.L #00000000H, [R0]
00000BE5                         L474:	; bb13
                                 ;    2047 		}
                                 ;    2048 	}
                                 ;    2049 	taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2049
00000BE5 05rrrrrr             A  		BSR _vTaskExitCritical
00000BE9                         L475:	; bb13.split
                                 ;    2050 
                                 ;    2051 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2051
00000BE9 EC01                    		MOV.L [R0], R1
00000BEB A009                    		MOV.L R1, 04H[R0]
00000BED                         L476:	; bb13.split1
                                 ;    2052 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2052
00000BED 6703                    		RTSD #0CH
00000BEF                         _xQueueIsQueueFullFromISR:
                                 		.STACK	_xQueueIsQueueFullFromISR=16
                                 ;    2053 /*-----------------------------------------------------------*/
                                 ;    2054 
                                 ;    2055 BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2055
00000BEF 60C0                    		SUB #0CH, R0
00000BF1 A081                    		MOV.L R1, 08H[R0]
                                 ;    2056 {
                                 ;    2057 BaseType_t xReturn;
                                 ;    2058 
                                 ;    2059 	configASSERT( xQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2059
00000BF3 6101                    		CMP #00H, R1
00000BF5 18                   S  		BNE L479
00000BF6                         L478:	; bb3
00000BF6 05rrrrrr             A  		BSR _vAssertCalled
00000BFA                         L479:	; bb8
                                 ;    2060 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2060
00000BFA A881                    		MOV.L 08H[R0], R1
00000BFC AB91                    		MOV.L 38H[R1], R1
00000BFE A882                    		MOV.L 08H[R0], R2
00000C00 0685210F                		CMP 3CH[R2].L, R1
00000C04 18                   S  		BNE L481
00000C05                         L480:	; bb9
                                 ;    2061 	{
                                 ;    2062 		xReturn = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2062
00000C05 F80601                  		MOV.L #00000001H, [R0]
00000C08 08                   S  		BRA L482
00000C09                         L481:	; bb10
                                 ;    2063 	}
                                 ;    2064 	else
                                 ;    2065 	{
                                 ;    2066 		xReturn = pdFALSE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2066
00000C09 F80600                  		MOV.L #00000000H, [R0]
00000C0C                         L482:	; bb22
                                 ;    2067 	}
                                 ;    2068 
                                 ;    2069 	return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2069
00000C0C EC01                    		MOV.L [R0], R1
00000C0E A009                    		MOV.L R1, 04H[R0]
00000C10                         L483:	; bb22.split
                                 ;    2070 } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2070
00000C10 6703                    		RTSD #0CH
00000C12                         _vQueueWaitForMessageRestricted:
                                 		.STACK	_vQueueWaitForMessageRestricted=16
                                 ;    2071 /*-----------------------------------------------------------*/
                                 ;    2072 
                                 ;    2073 #if ( configUSE_CO_ROUTINES == 1 )
                                 ;    2074 
                                 ;    2075 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
                                 ;    2076 	{
                                 ;    2077 	BaseType_t xReturn;
                                 ;    2078 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 ;    2079 
                                 ;    2080 		/* If the queue is already full we may have to block.  A critical section
                                 ;    2081 		is required to prevent an interrupt removing something from the queue
                                 ;    2082 		between the check to see if the queue is full and blocking on the queue. */
                                 ;    2083 		portDISABLE_INTERRUPTS();
                                 ;    2084 		{
                                 ;    2085 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
                                 ;    2086 			{
                                 ;    2087 				/* The queue is full - do we want to block or just leave without
                                 ;    2088 				posting? */
                                 ;    2089 				if( xTicksToWait > ( TickType_t ) 0 )
                                 ;    2090 				{
                                 ;    2091 					/* As this is called from a coroutine we cannot block directly, but
                                 ;    2092 					return indicating that we need to block. */
                                 ;    2093 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
                                 ;    2094 					portENABLE_INTERRUPTS();
                                 ;    2095 					return errQUEUE_BLOCKED;
                                 ;    2096 				}
                                 ;    2097 				else
                                 ;    2098 				{
                                 ;    2099 					portENABLE_INTERRUPTS();
                                 ;    2100 					return errQUEUE_FULL;
                                 ;    2101 				}
                                 ;    2102 			}
                                 ;    2103 		}
                                 ;    2104 		portENABLE_INTERRUPTS();
                                 ;    2105 
                                 ;    2106 		portDISABLE_INTERRUPTS();
                                 ;    2107 		{
                                 ;    2108 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
                                 ;    2109 			{
                                 ;    2110 				/* There is room in the queue, copy the data into the queue. */
                                 ;    2111 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
                                 ;    2112 				xReturn = pdPASS;
                                 ;    2113 
                                 ;    2114 				/* Were any co-routines waiting for data to become available? */
                                 ;    2115 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 ;    2116 				{
                                 ;    2117 					/* In this instance the co-routine could be placed directly
                                 ;    2118 					into the ready list as we are within a critical section.
                                 ;    2119 					Instead the same pending ready list mechanism is used as if
                                 ;    2120 					the event were caused from within an interrupt. */
                                 ;    2121 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 ;    2122 					{
                                 ;    2123 						/* The co-routine waiting has a higher priority so record
                                 ;    2124 						that a yield might be appropriate. */
                                 ;    2125 						xReturn = errQUEUE_YIELD;
                                 ;    2126 					}
                                 ;    2127 					else
                                 ;    2128 					{
                                 ;    2129 						mtCOVERAGE_TEST_MARKER();
                                 ;    2130 					}
                                 ;    2131 				}
                                 ;    2132 				else
                                 ;    2133 				{
                                 ;    2134 					mtCOVERAGE_TEST_MARKER();
                                 ;    2135 				}
                                 ;    2136 			}
                                 ;    2137 			else
                                 ;    2138 			{
                                 ;    2139 				xReturn = errQUEUE_FULL;
                                 ;    2140 			}
                                 ;    2141 		}
                                 ;    2142 		portENABLE_INTERRUPTS();
                                 ;    2143 
                                 ;    2144 		return xReturn;
                                 ;    2145 	}
                                 ;    2146 
                                 ;    2147 #endif /* configUSE_CO_ROUTINES */
                                 ;    2148 /*-----------------------------------------------------------*/
                                 ;    2149 
                                 ;    2150 #if ( configUSE_CO_ROUTINES == 1 )
                                 ;    2151 
                                 ;    2152 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
                                 ;    2153 	{
                                 ;    2154 	BaseType_t xReturn;
                                 ;    2155 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 ;    2156 
                                 ;    2157 		/* If the queue is already empty we may have to block.  A critical section
                                 ;    2158 		is required to prevent an interrupt adding something to the queue
                                 ;    2159 		between the check to see if the queue is empty and blocking on the queue. */
                                 ;    2160 		portDISABLE_INTERRUPTS();
                                 ;    2161 		{
                                 ;    2162 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
                                 ;    2163 			{
                                 ;    2164 				/* There are no messages in the queue, do we want to block or just
                                 ;    2165 				leave with nothing? */
                                 ;    2166 				if( xTicksToWait > ( TickType_t ) 0 )
                                 ;    2167 				{
                                 ;    2168 					/* As this is a co-routine we cannot block directly, but return
                                 ;    2169 					indicating that we need to block. */
                                 ;    2170 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
                                 ;    2171 					portENABLE_INTERRUPTS();
                                 ;    2172 					return errQUEUE_BLOCKED;
                                 ;    2173 				}
                                 ;    2174 				else
                                 ;    2175 				{
                                 ;    2176 					portENABLE_INTERRUPTS();
                                 ;    2177 					return errQUEUE_FULL;
                                 ;    2178 				}
                                 ;    2179 			}
                                 ;    2180 			else
                                 ;    2181 			{
                                 ;    2182 				mtCOVERAGE_TEST_MARKER();
                                 ;    2183 			}
                                 ;    2184 		}
                                 ;    2185 		portENABLE_INTERRUPTS();
                                 ;    2186 
                                 ;    2187 		portDISABLE_INTERRUPTS();
                                 ;    2188 		{
                                 ;    2189 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
                                 ;    2190 			{
                                 ;    2191 				/* Data is available from the queue. */
                                 ;    2192 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
                                 ;    2193 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
                                 ;    2194 				{
                                 ;    2195 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
                                 ;    2196 				}
                                 ;    2197 				else
                                 ;    2198 				{
                                 ;    2199 					mtCOVERAGE_TEST_MARKER();
                                 ;    2200 				}
                                 ;    2201 				--( pxQueue->uxMessagesWaiting );
                                 ;    2202 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
                                 ;    2203 
                                 ;    2204 				xReturn = pdPASS;
                                 ;    2205 
                                 ;    2206 				/* Were any co-routines waiting for space to become available? */
                                 ;    2207 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
                                 ;    2208 				{
                                 ;    2209 					/* In this instance the co-routine could be placed directly
                                 ;    2210 					into the ready list as we are within a critical section.
                                 ;    2211 					Instead the same pending ready list mechanism is used as if
                                 ;    2212 					the event were caused from within an interrupt. */
                                 ;    2213 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
                                 ;    2214 					{
                                 ;    2215 						xReturn = errQUEUE_YIELD;
                                 ;    2216 					}
                                 ;    2217 					else
                                 ;    2218 					{
                                 ;    2219 						mtCOVERAGE_TEST_MARKER();
                                 ;    2220 					}
                                 ;    2221 				}
                                 ;    2222 				else
                                 ;    2223 				{
                                 ;    2224 					mtCOVERAGE_TEST_MARKER();
                                 ;    2225 				}
                                 ;    2226 			}
                                 ;    2227 			else
                                 ;    2228 			{
                                 ;    2229 				xReturn = pdFAIL;
                                 ;    2230 			}
                                 ;    2231 		}
                                 ;    2232 		portENABLE_INTERRUPTS();
                                 ;    2233 
                                 ;    2234 		return xReturn;
                                 ;    2235 	}
                                 ;    2236 
                                 ;    2237 #endif /* configUSE_CO_ROUTINES */
                                 ;    2238 /*-----------------------------------------------------------*/
                                 ;    2239 
                                 ;    2240 #if ( configUSE_CO_ROUTINES == 1 )
                                 ;    2241 
                                 ;    2242 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
                                 ;    2243 	{
                                 ;    2244 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 ;    2245 
                                 ;    2246 		/* Cannot block within an ISR so if there is no space on the queue then
                                 ;    2247 		exit without doing anything. */
                                 ;    2248 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
                                 ;    2249 		{
                                 ;    2250 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
                                 ;    2251 
                                 ;    2252 			/* We only want to wake one co-routine per ISR, so check that a
                                 ;    2253 			co-routine has not already been woken. */
                                 ;    2254 			if( xCoRoutinePreviouslyWoken == pdFALSE )
                                 ;    2255 			{
                                 ;    2256 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                                 ;    2257 				{
                                 ;    2258 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
                                 ;    2259 					{
                                 ;    2260 						return pdTRUE;
                                 ;    2261 					}
                                 ;    2262 					else
                                 ;    2263 					{
                                 ;    2264 						mtCOVERAGE_TEST_MARKER();
                                 ;    2265 					}
                                 ;    2266 				}
                                 ;    2267 				else
                                 ;    2268 				{
                                 ;    2269 					mtCOVERAGE_TEST_MARKER();
                                 ;    2270 				}
                                 ;    2271 			}
                                 ;    2272 			else
                                 ;    2273 			{
                                 ;    2274 				mtCOVERAGE_TEST_MARKER();
                                 ;    2275 			}
                                 ;    2276 		}
                                 ;    2277 		else
                                 ;    2278 		{
                                 ;    2279 			mtCOVERAGE_TEST_MARKER();
                                 ;    2280 		}
                                 ;    2281 
                                 ;    2282 		return xCoRoutinePreviouslyWoken;
                                 ;    2283 	}
                                 ;    2284 
                                 ;    2285 #endif /* configUSE_CO_ROUTINES */
                                 ;    2286 /*-----------------------------------------------------------*/
                                 ;    2287 
                                 ;    2288 #if ( configUSE_CO_ROUTINES == 1 )
                                 ;    2289 
                                 ;    2290 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
                                 ;    2291 	{
                                 ;    2292 	BaseType_t xReturn;
                                 ;    2293 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 ;    2294 
                                 ;    2295 		/* We cannot block from an ISR, so check there is data available. If
                                 ;    2296 		not then just leave without doing anything. */
                                 ;    2297 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
                                 ;    2298 		{
                                 ;    2299 			/* Copy the data from the queue. */
                                 ;    2300 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
                                 ;    2301 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
                                 ;    2302 			{
                                 ;    2303 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
                                 ;    2304 			}
                                 ;    2305 			else
                                 ;    2306 			{
                                 ;    2307 				mtCOVERAGE_TEST_MARKER();
                                 ;    2308 			}
                                 ;    2309 			--( pxQueue->uxMessagesWaiting );
                                 ;    2310 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
                                 ;    2311 
                                 ;    2312 			if( ( *pxCoRoutineWoken ) == pdFALSE )
                                 ;    2313 			{
                                 ;    2314 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
                                 ;    2315 				{
                                 ;    2316 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
                                 ;    2317 					{
                                 ;    2318 						*pxCoRoutineWoken = pdTRUE;
                                 ;    2319 					}
                                 ;    2320 					else
                                 ;    2321 					{
                                 ;    2322 						mtCOVERAGE_TEST_MARKER();
                                 ;    2323 					}
                                 ;    2324 				}
                                 ;    2325 				else
                                 ;    2326 				{
                                 ;    2327 					mtCOVERAGE_TEST_MARKER();
                                 ;    2328 				}
                                 ;    2329 			}
                                 ;    2330 			else
                                 ;    2331 			{
                                 ;    2332 				mtCOVERAGE_TEST_MARKER();
                                 ;    2333 			}
                                 ;    2334 
                                 ;    2335 			xReturn = pdPASS;
                                 ;    2336 		}
                                 ;    2337 		else
                                 ;    2338 		{
                                 ;    2339 			xReturn = pdFAIL;
                                 ;    2340 		}
                                 ;    2341 
                                 ;    2342 		return xReturn;
                                 ;    2343 	}
                                 ;    2344 
                                 ;    2345 #endif /* configUSE_CO_ROUTINES */
                                 ;    2346 /*-----------------------------------------------------------*/
                                 ;    2347 
                                 ;    2348 #if ( configQUEUE_REGISTRY_SIZE > 0 )
                                 ;    2349 
                                 ;    2350 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single charact
                                 ;    2351 	{
                                 ;    2352 	UBaseType_t ux;
                                 ;    2353 
                                 ;    2354 		/* See if there is an empty space in the registry.  A NULL name denotes
                                 ;    2355 		a free slot. */
                                 ;    2356 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
                                 ;    2357 		{
                                 ;    2358 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
                                 ;    2359 			{
                                 ;    2360 				/* Store the information on this queue. */
                                 ;    2361 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
                                 ;    2362 				xQueueRegistry[ ux ].xHandle = xQueue;
                                 ;    2363 
                                 ;    2364 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
                                 ;    2365 				break;
                                 ;    2366 			}
                                 ;    2367 			else
                                 ;    2368 			{
                                 ;    2369 				mtCOVERAGE_TEST_MARKER();
                                 ;    2370 			}
                                 ;    2371 		}
                                 ;    2372 	}
                                 ;    2373 
                                 ;    2374 #endif /* configQUEUE_REGISTRY_SIZE */
                                 ;    2375 /*-----------------------------------------------------------*/
                                 ;    2376 
                                 ;    2377 #if ( configQUEUE_REGISTRY_SIZE > 0 )
                                 ;    2378 
                                 ;    2379 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
                                 ;    2380 	{
                                 ;    2381 	UBaseType_t ux;
                                 ;    2382 
                                 ;    2383 		/* See if the handle of the queue being unregistered in actually in the
                                 ;    2384 		registry. */
                                 ;    2385 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
                                 ;    2386 		{
                                 ;    2387 			if( xQueueRegistry[ ux ].xHandle == xQueue )
                                 ;    2388 			{
                                 ;    2389 				/* Set the name to NULL to show that this slot if free again. */
                                 ;    2390 				xQueueRegistry[ ux ].pcQueueName = NULL;
                                 ;    2391 				break;
                                 ;    2392 			}
                                 ;    2393 			else
                                 ;    2394 			{
                                 ;    2395 				mtCOVERAGE_TEST_MARKER();
                                 ;    2396 			}
                                 ;    2397 		}
                                 ;    2398 
                                 ;    2399 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
                                 ;    2400 
                                 ;    2401 #endif /* configQUEUE_REGISTRY_SIZE */
                                 ;    2402 /*-----------------------------------------------------------*/
                                 ;    2403 
                                 ;    2404 #if ( configUSE_TIMERS == 1 )
                                 ;    2405 
                                 ;    2406 	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2406
00000C12 60C0                    		SUB #0CH, R0
00000C14 A081                    		MOV.L R1, 08H[R0]
00000C16 A00A                    		MOV.L R2, 04H[R0]
                                 ;    2407 	{
                                 ;    2408 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2408
00000C18 E10002                  		MOV.L 08H[R0], [R0]
00000C1B                         L485:	; entry.split
                                 ;    2409 
                                 ;    2410 		/* This function should not be called by application code hence the
                                 ;    2411 		'Restricted' in its name.  It is not part of the public API.  It is
                                 ;    2412 		designed for use by kernel code, and has special calling requirements.
                                 ;    2413 		It can result in vListInsert() being called on a list that can only
                                 ;    2414 		possibly ever have one item in it, so the list will be fast, but even
                                 ;    2415 		so it should be called with the scheduler locked and not from a critical
                                 ;    2416 		section. */
                                 ;    2417 
                                 ;    2418 		/* Only do anything if there are no messages in the queue.  This function
                                 ;    2419 		will not actually cause the task to block, just place it on a blocked
                                 ;    2420 		list.  It will not block until the scheduler is unlocked - at which
                                 ;    2421 		time a yield will be performed.  If an item is added to the queue while
                                 ;    2422 		the queue is locked, and the calling task blocks on the queue, then the
                                 ;    2423 		calling task will be immediately unblocked when the queue is unlocked. */
                                 ;    2424 		prvLockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2424
00000C1B 05rrrrrr             A  		BSR _vTaskEnterCritical
00000C1F EC01                    		MOV.L [R0], R1
00000C21 AC19                    		MOV.L 44H[R1], R1
00000C23 7501FF                  		CMP #0FFFFFFFFH, R1
00000C26 18                   S  		BNE L487
00000C27                         L486:	; bb5
00000C27 EC01                    		MOV.L [R0], R1
00000C29 3E9100                  		MOV.L #00000000H, 44H[R1]
00000C2C                         L487:	; bb14
00000C2C EC01                    		MOV.L [R0], R1
00000C2E AC91                    		MOV.L 48H[R1], R1
00000C30 7501FF                  		CMP #0FFFFFFFFH, R1
00000C33 18                   S  		BNE L489
00000C34                         L488:	; bb15
00000C34 EC01                    		MOV.L [R0], R1
00000C36 3E9200                  		MOV.L #00000000H, 48H[R1]
00000C39                         L489:	; bb24
00000C39 05rrrrrr             A  		BSR _vTaskExitCritical
                                 ;    2425 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2425
00000C3D EC01                    		MOV.L [R0], R1
00000C3F AB91                    		MOV.L 38H[R1], R1
00000C41 6101                    		CMP #00H, R1
00000C43 21rr                    		BNE L491
00000C45                         L490:	; bb26
                                 ;    2426 		{
                                 ;    2427 			/* There is nothing in the queue, block for the specified period. */
                                 ;    2428 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2428
00000C45 A80A                    		MOV.L 04H[R0], R2
00000C47 EC01                    		MOV.L [R0], R1
00000C49 711124                  		ADD #24H, R1
00000C4C 05rrrrrr             A  		BSR _vTaskPlaceOnEventListRestricted
00000C50                         L491:	; bb37
                                 ;    2429 		}
                                 ;    2430 		else
                                 ;    2431 		{
                                 ;    2432 			mtCOVERAGE_TEST_MARKER();
                                 ;    2433 		}
                                 ;    2434 		prvUnlockQueue( pxQueue );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2434
00000C50 EC01                    		MOV.L [R0], R1
00000C52 39rrrr               W  		BSR __$prvUnlockQueue
00000C55 6703                    		RTSD #0CH
00000C57                         _xQueueCreateSet:
                                 		.STACK	_xQueueCreateSet=16
                                 ;    2435 	}
                                 ;    2436 
                                 ;    2437 #endif /* configUSE_TIMERS */
                                 ;    2438 /*-----------------------------------------------------------*/
                                 ;    2439 
                                 ;    2440 #if ( configUSE_QUEUE_SETS == 1 )
                                 ;    2441 
                                 ;    2442 	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2442
00000C57 60C0                    		SUB #0CH, R0
00000C59 A081                    		MOV.L R1, 08H[R0]
00000C5B 6603                    		MOV.L #00000000H, R3
00000C5D 6642                    		MOV.L #00000004H, R2
                                 ;    2443 	{
                                 ;    2444 	QueueSetHandle_t pxQueue;
                                 ;    2445 
                                 ;    2446 		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2446
00000C5F 39rrrr               W  		BSR _xQueueGenericCreate
00000C62 E301                    		MOV.L R1, [R0]
00000C64                         L493:	; entry.split
                                 ;    2447 
                                 ;    2448 		return pxQueue;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2448
00000C64 EC01                    		MOV.L [R0], R1
00000C66 A009                    		MOV.L R1, 04H[R0]
00000C68                         L494:	; entry.split1
                                 ;    2449 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2449
00000C68 6703                    		RTSD #0CH
00000C6A                         _xQueueAddToSet:
                                 		.STACK	_xQueueAddToSet=20
                                 ;    2450 
                                 ;    2451 #endif /* configUSE_QUEUE_SETS */
                                 ;    2452 /*-----------------------------------------------------------*/
                                 ;    2453 
                                 ;    2454 #if ( configUSE_QUEUE_SETS == 1 )
                                 ;    2455 
                                 ;    2456 	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2456
00000C6A 7100F0                  		ADD #0FFFFFFF0H, R0
00000C6D A089                    		MOV.L R1, 0CH[R0]
00000C6F A082                    		MOV.L R2, 08H[R0]
                                 ;    2457 	{
                                 ;    2458 	BaseType_t xReturn;
                                 ;    2459 
                                 ;    2460 		taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2460
00000C71 05rrrrrr             A  		BSR _vTaskEnterCritical
00000C75                         L496:	; entry.split
                                 ;    2461 		{
                                 ;    2462 			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2462
00000C75 A889                    		MOV.L 0CH[R0], R1
00000C77 AD19                    		MOV.L 54H[R1], R1
00000C79 6101                    		CMP #00H, R1
00000C7B 10                   S  		BEQ L498
00000C7C                         L497:	; bb4
                                 ;    2463 			{
                                 ;    2464 				/* Cannot add a queue/semaphore to more than one queue set. */
                                 ;    2465 				xReturn = pdFAIL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2465
00000C7C F80600                  		MOV.L #00000000H, [R0]
00000C7F 2Err                 B  		BRA L502
00000C81                         L498:	; bb6
                                 ;    2466 			}
                                 ;    2467 			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2467
00000C81 A889                    		MOV.L 0CH[R0], R1
00000C83 AB91                    		MOV.L 38H[R1], R1
00000C85 6101                    		CMP #00H, R1
00000C87 10                   S  		BEQ L500
00000C88                         L499:	; bb7
                                 ;    2468 			{
                                 ;    2469 				/* Cannot add a queue/semaphore to a queue set if there are already
                                 ;    2470 				items in the queue/semaphore. */
                                 ;    2471 				xReturn = pdFAIL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2471
00000C88 F80600                  		MOV.L #00000000H, [R0]
00000C8B 08                   S  		BRA L502
00000C8C                         L500:	; bb8
                                 ;    2472 			}
                                 ;    2473 			else
                                 ;    2474 			{
                                 ;    2475 				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2475
00000C8C A881                    		MOV.L 08H[R0], R1
00000C8E A88A                    		MOV.L 0CH[R0], R2
00000C90 A529                    		MOV.L R1, 54H[R2]
00000C92                         L501:	; bb8.split
                                 ;    2476 				xReturn = pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2476
00000C92 F80601                  		MOV.L #00000001H, [R0]
00000C95                         L502:	; bb28
                                 ;    2477 			}
                                 ;    2478 		}
                                 ;    2479 		taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2479
00000C95 05rrrrrr             A  		BSR _vTaskExitCritical
00000C99                         L503:	; bb28.split
                                 ;    2480 
                                 ;    2481 		return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2481
00000C99 EC01                    		MOV.L [R0], R1
00000C9B A009                    		MOV.L R1, 04H[R0]
00000C9D                         L504:	; bb28.split1
                                 ;    2482 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2482
00000C9D 6704                    		RTSD #10H
00000C9F                         _xQueueRemoveFromSet:
                                 		.STACK	_xQueueRemoveFromSet=24
                                 ;    2483 
                                 ;    2484 #endif /* configUSE_QUEUE_SETS */
                                 ;    2485 /*-----------------------------------------------------------*/
                                 ;    2486 
                                 ;    2487 #if ( configUSE_QUEUE_SETS == 1 )
                                 ;    2488 
                                 ;    2489 	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2489
00000C9F 7100EC                  		ADD #0FFFFFFECH, R0
00000CA2 A101                    		MOV.L R1, 10H[R0]
00000CA4 A08A                    		MOV.L R2, 0CH[R0]
                                 ;    2490 	{
                                 ;    2491 	BaseType_t xReturn;
                                 ;    2492 	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2492
00000CA6 E5000401                		MOV.L 10H[R0], 04H[R0]
00000CAA                         L506:	; entry.split
                                 ;    2493 
                                 ;    2494 		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2494
00000CAA A809                    		MOV.L 04H[R0], R1
00000CAC AD19                    		MOV.L 54H[R1], R1
00000CAE 06850103                		CMP 0CH[R0].L, R1
00000CB2 10                   S  		BEQ L508
00000CB3                         L507:	; bb7
                                 ;    2495 		{
                                 ;    2496 			/* The queue was not a member of the set. */
                                 ;    2497 			xReturn = pdFAIL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2497
00000CB3 F80600                  		MOV.L #00000000H, [R0]
00000CB6 2Err                 B  		BRA L514
00000CB8                         L508:	; bb9
                                 ;    2498 		}
                                 ;    2499 		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2499
00000CB8 A809                    		MOV.L 04H[R0], R1
00000CBA AB91                    		MOV.L 38H[R1], R1
00000CBC 6101                    		CMP #00H, R1
00000CBE 10                   S  		BEQ L510
00000CBF                         L509:	; bb10
                                 ;    2500 		{
                                 ;    2501 			/* It is dangerous to remove a queue from a set when the queue is
                                 ;    2502 			not empty because the queue set will still hold pending events for
                                 ;    2503 			the queue. */
                                 ;    2504 			xReturn = pdFAIL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2504
00000CBF F80600                  		MOV.L #00000000H, [R0]
00000CC2 2Err                 B  		BRA L514
00000CC4                         L510:	; bb11
                                 ;    2505 		}
                                 ;    2506 		else
                                 ;    2507 		{
                                 ;    2508 			taskENTER_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2508
00000CC4 05rrrrrr             A  		BSR _vTaskEnterCritical
00000CC8                         L511:	; bb11.split
                                 ;    2509 			{
                                 ;    2510 				/* The queue is no longer contained in the set. */
                                 ;    2511 				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2511
00000CC8 A809                    		MOV.L 04H[R0], R1
00000CCA 3E9500                  		MOV.L #00000000H, 54H[R1]
00000CCD                         L512:	; bb11.split1
                                 ;    2512 			}
                                 ;    2513 			taskEXIT_CRITICAL();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2513
00000CCD 05rrrrrr             A  		BSR _vTaskExitCritical
00000CD1                         L513:	; bb11.split2
                                 ;    2514 			xReturn = pdPASS;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2514
00000CD1 F80601                  		MOV.L #00000001H, [R0]
00000CD4                         L514:	; bb28
                                 ;    2515 		}
                                 ;    2516 
                                 ;    2517 		return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2517
00000CD4 EC01                    		MOV.L [R0], R1
00000CD6 A081                    		MOV.L R1, 08H[R0]
00000CD8                         L515:	; bb28.split
                                 ;    2518 	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2518
00000CD8 6705                    		RTSD #14H
00000CDA                         _xQueueSelectFromSet:
                                 		.STACK	_xQueueSelectFromSet=20
                                 ;    2519 
                                 ;    2520 #endif /* configUSE_QUEUE_SETS */
                                 ;    2521 /*-----------------------------------------------------------*/
                                 ;    2522 
                                 ;    2523 #if ( configUSE_QUEUE_SETS == 1 )
                                 ;    2524 
                                 ;    2525 	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2525
00000CDA 7100F0                  		ADD #0FFFFFFF0H, R0
00000CDD A089                    		MOV.L R1, 0CH[R0]
00000CDF A082                    		MOV.L R2, 08H[R0]
                                 ;    2526 	{
                                 ;    2527 	QueueSetMemberHandle_t xReturn = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2527
00000CE1 F80600                  		MOV.L #00000000H, [R0]
00000CE4                         L517:	; entry.split
                                 ;    2528 
                                 ;    2529 		( void ) xQueueGenericReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait, pdFALSE ); /*lint !e961 Casting from one typedef to another 
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2529
00000CE4 A883                    		MOV.L 08H[R0], R3
00000CE6 A889                    		MOV.L 0CH[R0], R1
00000CE8 6604                    		MOV.L #00000000H, R4
00000CEA EF02                    		MOV.L R0, R2
00000CEC 39rrrr               W  		BSR _xQueueGenericReceive
00000CEF                         L518:	; entry.split1
                                 ;    2530 		return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2530
00000CEF EC01                    		MOV.L [R0], R1
00000CF1 A009                    		MOV.L R1, 04H[R0]
00000CF3                         L519:	; entry.split2
                                 ;    2531 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2531
00000CF3 6704                    		RTSD #10H
00000CF5                         _xQueueSelectFromSetFromISR:
                                 		.STACK	_xQueueSelectFromSetFromISR=16
                                 ;    2532 
                                 ;    2533 #endif /* configUSE_QUEUE_SETS */
                                 ;    2534 /*-----------------------------------------------------------*/
                                 ;    2535 
                                 ;    2536 #if ( configUSE_QUEUE_SETS == 1 )
                                 ;    2537 
                                 ;    2538 	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2538
00000CF5 60C0                    		SUB #0CH, R0
00000CF7 A081                    		MOV.L R1, 08H[R0]
                                 ;    2539 	{
                                 ;    2540 	QueueSetMemberHandle_t xReturn = NULL;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2540
00000CF9 F80600                  		MOV.L #00000000H, [R0]
00000CFC                         L521:	; entry.split
                                 ;    2541 
                                 ;    2542 		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant.
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2542
00000CFC A881                    		MOV.L 08H[R0], R1
00000CFE 6603                    		MOV.L #00000000H, R3
00000D00 EF02                    		MOV.L R0, R2
00000D02 39rrrr               W  		BSR _xQueueReceiveFromISR
00000D05                         L522:	; entry.split1
                                 ;    2543 		return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2543
00000D05 EC01                    		MOV.L [R0], R1
00000D07 A009                    		MOV.L R1, 04H[R0]
00000D09                         L523:	; entry.split2
                                 ;    2544 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2544
00000D09 6703                    		RTSD #0CH
00000D0B                         __$prvNotifyQueueSetContainer:
                                 		.STACK	__$prvNotifyQueueSetContainer=24
                                 ;    2545 
                                 ;    2546 #endif /* configUSE_QUEUE_SETS */
                                 ;    2547 /*-----------------------------------------------------------*/
                                 ;    2548 
                                 ;    2549 #if ( configUSE_QUEUE_SETS == 1 )
                                 ;    2550 
                                 ;    2551 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2551
00000D0B 7100EC                  		ADD #0FFFFFFECH, R0
00000D0E A101                    		MOV.L R1, 10H[R0]
00000D10 A08A                    		MOV.L R2, 0CH[R0]
                                 ;    2552 	{
                                 ;    2553 	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2553
00000D12 A901                    		MOV.L 10H[R0], R1
00000D14 E11015                  		MOV.L 54H[R1], [R0]
00000D17                         L525:	; entry.split
                                 ;    2554 	BaseType_t xReturn = pdFALSE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2554
00000D17 3E0100                  		MOV.L #00000000H, 04H[R0]
00000D1A                         L526:	; entry.split1
                                 ;    2555 
                                 ;    2556 		/* This function must be called form a critical section. */
                                 ;    2557 
                                 ;    2558 		configASSERT( pxQueueSetContainer );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2558
00000D1A EC01                    		MOV.L [R0], R1
00000D1C 6101                    		CMP #00H, R1
00000D1E 18                   S  		BNE L528
00000D1F                         L527:	; bb8
00000D1F 05rrrrrr             A  		BSR _vAssertCalled
00000D23                         L528:	; bb13
                                 ;    2559 		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2559
00000D23 EC01                    		MOV.L [R0], R1
00000D25 AB91                    		MOV.L 38H[R1], R1
00000D27 EC02                    		MOV.L [R0], R2
00000D29 0685210F                		CMP 3CH[R2].L, R1
00000D2D 23rr                    		BLTU L530
00000D2F                         L529:	; bb14
00000D2F 05rrrrrr             A  		BSR _vAssertCalled
00000D33                         L530:	; bb27
                                 ;    2560 
                                 ;    2561 		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2561
00000D33 EC01                    		MOV.L [R0], R1
00000D35 AB91                    		MOV.L 38H[R1], R1
00000D37 EC02                    		MOV.L [R0], R2
00000D39 0685210F                		CMP 3CH[R2].L, R1
00000D3D 22rr                    		BGEU L537
00000D3F                         L531:	; bb28
                                 ;    2562 		{
                                 ;    2563 			traceQUEUE_SEND( pxQueueSetContainer );
                                 ;    2564 
                                 ;    2565 			/* The data copied is the handle of the queue that contains data. */
                                 ;    2566 			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2566
00000D3F A88B                    		MOV.L 0CH[R0], R3
00000D41 EC01                    		MOV.L [R0], R1
00000D43 710210                  		ADD #10H, R0, R2
00000D46 39rrrr               W  		BSR __$prvCopyDataToQueue
00000D49 A009                    		MOV.L R1, 04H[R0]
00000D4B                         L532:	; bb28.split
                                 ;    2567 
                                 ;    2568 			if( pxQueueSetContainer->xTxLock == queueUNLOCKED )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2568
00000D4B EC01                    		MOV.L [R0], R1
00000D4D AC91                    		MOV.L 48H[R1], R1
00000D4F 7501FF                  		CMP #0FFFFFFFFH, R1
00000D52 EC01                    		MOV.L [R0], R1
00000D54 21rr                    		BNE L536
00000D56                         L533:	; bb35
                                 ;    2569 			{
                                 ;    2570 				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2570
00000D56 AA19                    		MOV.L 24H[R1], R1
00000D58 6101                    		CMP #00H, R1
00000D5A 20rr                    		BEQ L537
00000D5C                         L534:	; bb37
                                 ;    2571 				{
                                 ;    2572 					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2572
00000D5C EC01                    		MOV.L [R0], R1
00000D5E 711124                  		ADD #24H, R1
00000D61 05rrrrrr             A  		BSR _xTaskRemoveFromEventList
00000D65 6101                    		CMP #00H, R1
00000D67 20rr                    		BEQ L537
00000D69                         L535:	; bb38
                                 ;    2573 					{
                                 ;    2574 						/* The task waiting has a higher priority. */
                                 ;    2575 						xReturn = pdTRUE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2575
00000D69 3E0101                  		MOV.L #00000001H, 04H[R0]
00000D6C 08                   S  		BRA L537
00000D6D                         L536:	; bb58
                                 ;    2576 					}
                                 ;    2577 					else
                                 ;    2578 					{
                                 ;    2579 						mtCOVERAGE_TEST_MARKER();
                                 ;    2580 					}
                                 ;    2581 				}
                                 ;    2582 				else
                                 ;    2583 				{
                                 ;    2584 					mtCOVERAGE_TEST_MARKER();
                                 ;    2585 				}
                                 ;    2586 			}
                                 ;    2587 			else
                                 ;    2588 			{
                                 ;    2589 				( pxQueueSetContainer->xTxLock )++;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2589
00000D6D AC92                    		MOV.L 48H[R1], R2
00000D6F 6212                    		ADD #01H, R2
00000D71 A492                    		MOV.L R2, 48H[R1]
00000D73                         L537:	; bb80
                                 ;    2590 			}
                                 ;    2591 		}
                                 ;    2592 		else
                                 ;    2593 		{
                                 ;    2594 			mtCOVERAGE_TEST_MARKER();
                                 ;    2595 		}
                                 ;    2596 
                                 ;    2597 		return xReturn;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2597
00000D73 A809                    		MOV.L 04H[R0], R1
00000D75 A081                    		MOV.L R1, 08H[R0]
00000D77                         L538:	; bb80.split
                                 ;    2598 	}
                                 		.LINE  "C:\Workspace\e2studio\git\MT01_master\FreeRTOS\Source\queue.c",2598
00000D77 6705                    		RTSD #14H
                                 ;    2599 
                                 ;    2600 #endif /* configUSE_QUEUE_SETS */
                                 ;    2601 
                                 ;    2602 
                                 ;    2603 
                                 ;    2604 
                                 ;    2605 
                                 ;    2606 
                                 ;    2607 
                                 ;    2608 
                                 ;    2609 
                                 ;    2610 
                                 ;    2611 
                                 ;    2612 
                                 		.END

Information List

TOTAL ERROR(S)    00000
TOTAL WARNING(S)  00000
TOTAL LINE(S)     05205   LINES

Section List

Attr         Size               Name
CODE     0000003449(00000D79H)  P

Cpu Type

-ISA=RXV1 -FPU

Command Parameter

-subcommand=C:\Users\LAFONS~1\AppData\Local\Temp\$ccrx124\$ccrx\queue.src.cmd
    -nologo
    -isa=rxv1
    -fpu
    -show=conditionals,definitions,expansions
    -define=__RXV1=1
    -fint_register=0
    -debug
    -endian=little
-listfile=C:\Workspace\e2studio\git\MT01_master\CompactaXP_build\queue.lst
-output=C:\Workspace\e2studio\git\MT01_master\CompactaXP_build\FreeRTOS\Source\queue.obj
