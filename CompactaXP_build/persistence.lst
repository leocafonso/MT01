* RX FAMILY ASSEMBLER V2.03.00.01 [24 Oct 2014] *  SOURCE LIST  Tue Feb 28 14:07:09 2017

LOC.     OBJ.              0XMDA SOURCE STATEMENT

                                 ;RX Family C/C++ Compiler (V2.03.00.03 [04 Dec 2014])  28-Feb-2017 14:07:08
                                 
                                 ;*** CPU TYPE ***
                                 
                                 ;-ISA=RXV1
                                 
                                 ;*** COMMAND PARAMETER ***
                                 
                                 ;-output=src=persistence.src
                                 ;-lang=c99
                                 ;-include=C:\PROGRA~2\Renesas\RX\2_3_0/include,C:\Workspace\e2studio\git\MT01\r_lvd_rx,C:\Workspace\e2studio\git\MT01\r_lvd_rx\src,C:/Workspace/e2studio/git/MT01/r_tfa
                                 ;-debug
                                 ;-show=source,conditionals,definitions,expansions
                                 ;-listfile=persistence.lst
                                 ;-isa=rxv1
                                 ;-optimize=0
                                 ;-fpu
                                 ;-alias=noansi
                                 ;-nologo
                                 ;-nomessage
                                 ;-define=__RX,COMPACTAXP=1,EASYMAK=0,MOBILE=0,FREE_RTOS_PP
                                 ;persistence.c
                                 
                                 		.glb	_status_code
                                 		.glb	_cm
                                 		.glb	_nvm
                                 		.glb	_persistence_init
                                 		.glb	_read_persistent_value
                                 		.glb	_write_persistent_value
                                 		.glb	_rpt_exception
                                 		.glb	__FDclass
                                 ;LineNo. C-SOURCE STATEMENT
                                 
                                 		.SECTION	P,CODE
00000000                         _persistence_init:
                                 		.STACK	_persistence_init=4
                                 ;       1 /*
                                 ;       2  * persistence.c - persistence functions
                                 ;       3  * This file is part of the TinyG project
                                 ;       4  *
                                 ;       5  * Copyright (c) 2013 - 2015 Alden S. Hart Jr.
                                 ;       6  *
                                 ;       7  * This file ("the software") is free software: you can redistribute it and/or modify
                                 ;       8  * it under the terms of the GNU General Public License, version 2 as published by the
                                 ;       9  * Free Software Foundation. You should have received a copy of the GNU General Public
                                 ;      10  * License, version 2 along with the software.  If not, see <http://www.gnu.org/licenses/>.
                                 ;      11  *
                                 ;      12  * As a special exception, you may use this file as part of a software library without
                                 ;      13  * restriction. Specifically, if other files instantiate templates or use macros or
                                 ;      14  * inline functions from this file, or you compile this file and link it with  other
                                 ;      15  * files to produce an executable, this file does not by itself cause the resulting
                                 ;      16  * executable to be covered by the GNU General Public License. This exception does not
                                 ;      17  * however invalidate any other reasons why the executable file might be covered by the
                                 ;      18  * GNU General Public License.
                                 ;      19  *
                                 ;      20  * THE SOFTWARE IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT WITHOUT ANY
                                 ;      21  * WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
                                 ;      22  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
                                 ;      23  * SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                 ;      24  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
                                 ;      25  * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                                 ;      26  */
                                 ;      27 #include "tinyg.h"
                                 ;      28 #include "persistence.h"
                                 ;      29 #include "report.h"
                                 ;      30 #include "canonical_machine.h"
                                 ;      31 #include "util.h"
                                 ;      32 
                                 ;      33 #ifdef __AVR
                                 ;      34 #include "xmega/xmega_eeprom.h"
                                 ;      35 #endif
                                 ;      36 
                                 ;      37 #ifdef __RX
                                 ;      38 #include "platform.h"
                                 ;      39 #endif
                                 ;      40 
                                 ;      41 /***********************************************************************************
                                 ;      42  **** STRUCTURE ALLOCATIONS ********************************************************
                                 ;      43  ***********************************************************************************/
                                 ;      44 
                                 ;      45 nvmSingleton_t nvm;
                                 ;      46 
                                 ;      47 /***********************************************************************************
                                 ;      48  **** GENERIC STATIC FUNCTIONS AND VARIABLES ***************************************
                                 ;      49  ***********************************************************************************/
                                 ;      50 
                                 ;      51 
                                 ;      52 /***********************************************************************************
                                 ;      53  **** CODE *************************************************************************
                                 ;      54  ***********************************************************************************/
                                 ;      55 
                                 ;      56 void persistence_init()
                                 ;      57 {
                                 ;      58 #ifdef __AVR
                                 ;      59 	nvm.base_addr = NVM_BASE_ADDR;
                                 ;      60 	nvm.profile_base = 0;
                                 ;      61 #endif
                                 ;      62 	return;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",62
00000000 02                      		RTS
00000001                         _read_persistent_value:
                                 		.STACK	_read_persistent_value=12
                                 ;      63 }
                                 ;      64 
                                 ;      65 /************************************************************************************
                                 ;      66  * read_persistent_value()	- return value (as float) by index
                                 ;      67  * write_persistent_value() - write to NVM by index, but only if the value has changed
                                 ;      68  *
                                 ;      69  *	It's the responsibility of the caller to make sure the index does not exceed range
                                 ;      70  */
                                 ;      71 
                                 ;      72 #ifdef __AVR
                                 ;      73 stat_t read_persistent_value(nvObj_t *nv)
                                 ;      74 {
                                 ;      75 	nvm.address = nvm.profile_base + (nv->index * NVM_VALUE_LEN);
                                 ;      76 	(void)EEPROM_ReadBytes(nvm.address, nvm.byte_array, NVM_VALUE_LEN);
                                 ;      77 	memcpy(&nv->value, &nvm.byte_array, NVM_VALUE_LEN);
                                 ;      78 	return (STAT_OK);
                                 ;      79 }
                                 ;      80 #endif // __AVR
                                 ;      81 
                                 ;      82 #ifdef __ARM
                                 ;      83 stat_t read_persistent_value(nvObj_t *nv)
                                 ;      84 {
                                 ;      85 	nv->value = 0;
                                 ;      86 	return (STAT_OK);
                                 ;      87 }
                                 ;      88 #endif // __ARM
                                 ;      89 
                                 ;      90 #ifdef __RX
                                 ;      91 stat_t read_persistent_value(nvObj_t *nv)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",91
00000001 6080                    		SUB #08H, R0
00000003 A009                    		MOV.L R1, 04H[R0]
                                 ;      92 {
                                 ;      93 
                                 ;      94 	nvm.address = nvm.profile_base + (nv->index * NVM_VALUE_LEN);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",94
00000005 B911                    		MOVU.W 08H[R1], R1
00000007 6C21                    		SHLL #02H, R1
00000009 FB22rrrrrrrr            		MOV.L #_nvm, R2
0000000F 06C92101                		ADD 02H[R2].UW, R1
00000013 90A1                    		MOV.W R1, 04H[R2]
00000015                         L12:	; entry.split
                                 ;      95 	//(void)EEPROM_ReadBytes(nvm.address, nvm.byte_array, NVM_VALUE_LEN);
                                 ;      96 	memcpy(&nv->value, &nvm.byte_array, NVM_VALUE_LEN);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",96
00000015 FBE2rrrrrrrr            		MOV.L #_nvm, R14
0000001B A809                    		MOV.L 04H[R0], R1
0000001D E5E10304                		MOV.L 0CH[R14], 10H[R1]
00000021                         L13:	; entry.split1
                                 ;      97 	return (STAT_OK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",97
00000021 3C0300                  		MOV.B #00H, 03H[R0]
00000024 B089                    		MOVU.B 03H[R0], R1
00000026                         L14:	; entry.split2
                                 ;      98 
                                 ;      99 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",99
00000026 5B11                    		MOVU.B R1, R1
00000028 6702                    		RTSD #08H
0000002A                         _write_persistent_value:
                                 		.STACK	_write_persistent_value=16
                                 ;     100 #endif // __ARM
                                 ;     101 
                                 ;     102 #ifdef __AVR
                                 ;     103 stat_t write_persistent_value(nvObj_t *nv)
                                 ;     104 {
                                 ;     105 	if (cm.cycle_state != CYCLE_OFF)
                                 ;     106         return(rpt_exception(STAT_FILE_NOT_OPEN));	// can't write when machine is moving
                                 ;     107 
                                 ;     108 /* not needed
                                 ;     109 	if (nv->valuetype == TYPE_FLOAT) {
                                 ;     110 		if (isnan((double)nv->value)) return(rpt_exception(STAT_FLOAT_IS_NAN));		// bad floating point value
                                 ;     111 		if (isinf((double)nv->value)) return(rpt_exception(STAT_FLOAT_IS_INFINITE));// bad floating point value
                                 ;     112 	}
                                 ;     113 */
                                 ;     114 	nvm.tmp_value = nv->value;
                                 ;     115 	ritorno(read_persistent_value(nv));
                                 ;     116 	if ((isnan((double)nv->value)) || (isinf((double)nv->value)) || (fp_NE(nv->value, nvm.tmp_value))) {
                                 ;     117 		memcpy(&nvm.byte_array, &nvm.tmp_value, NVM_VALUE_LEN);
                                 ;     118 		nvm.address = nvm.profile_base + (nv->index * NVM_VALUE_LEN);
                                 ;     119 		(void)EEPROM_WriteBytes(nvm.address, nvm.byte_array, NVM_VALUE_LEN);
                                 ;     120 	}
                                 ;     121 	nv->value =nvm.tmp_value;		// always restore value
                                 ;     122 	return (STAT_OK);
                                 ;     123 }
                                 ;     124 #endif // __AVR
                                 ;     125 
                                 ;     126 #ifdef __ARM
                                 ;     127 stat_t write_persistent_value(nvObj_t *nv)
                                 ;     128 {
                                 ;     129 	if (cm.cycle_state != CYCLE_OFF)
                                 ;     130         return(rpt_exception(STAT_FILE_NOT_OPEN));	// can't write when machine is moving
                                 ;     131 
                                 ;     132 /* not needed
                                 ;     133 	if (nv->valuetype == TYPE_FLOAT) {
                                 ;     134 		if (isnan((double)nv->value)) return(rpt_exception(STAT_FLOAT_IS_NAN));		// bad floating point value
                                 ;     135 		if (isinf((double)nv->value)) return(rpt_exception(STAT_FLOAT_IS_INFINITE));// bad floating point value
                                 ;     136 	}
                                 ;     137 */
                                 ;     138 	return (STAT_OK);
                                 ;     139 }
                                 ;     140 #endif // __ARM
                                 ;     141 
                                 ;     142 #ifdef __RX
                                 ;     143 stat_t write_persistent_value(nvObj_t *nv)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",143
0000002A 60C0                    		SUB #0CH, R0
0000002C A081                    		MOV.L R1, 08H[R0]
                                 ;     144 {
                                 ;     145 	if (cm.cycle_state != CYCLE_OFF)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",145
0000002E FBE2rrrrrrrr            		MOV.L #_cm, R14
00000034 5AEE1E02                		MOVU.B 021EH[R14], R14
00000038 610E                    		CMP #00H, R14
0000003A 20rr                    		BEQ L17
0000003C                         L16:	; bb2
0000003C 6691                    		MOV.L #00000009H, R1
                                 ;     146         return(rpt_exception(STAT_FILE_NOT_OPEN));	// can't write when machine is moving
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",146
0000003E 05rrrrrr             A  		BSR _rpt_exception
00000042 8181                    		MOV.B R1, 06H[R0]
00000044 38rrrr               W  		BRA L33
00000047                         L17:	; bb9
                                 ;     147 
                                 ;     148 /* not needed
                                 ;     149 	if (nv->valuetype == TYPE_FLOAT) {
                                 ;     150 		if (isnan((double)nv->value)) return(rpt_exception(STAT_FLOAT_IS_NAN));		// bad floating point value
                                 ;     151 		if (isinf((double)nv->value)) return(rpt_exception(STAT_FLOAT_IS_INFINITE));// bad floating point value
                                 ;     152 	}
                                 ;     153 */
                                 ;     154 	nvm.tmp_value = nv->value;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",154
00000047 A881                    		MOV.L 08H[R0], R1
00000049 FBE2rrrrrrrr            		MOV.L #_nvm, R14
0000004F E51E0402                		MOV.L 10H[R1], 08H[R14]
00000053                         L18:	; bb9.split
                                 ;     155 	ritorno(read_persistent_value(nv));
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",155
00000053 A881                    		MOV.L 08H[R0], R1
00000055 39rrrr               W  		BSR _read_persistent_value
00000058 FBE2rrrrrrrr            		MOV.L #_status_code, R14
0000005E C3E1                    		MOV.B R1, [R14]
00000060 6101                    		CMP #00H, R1
00000062 20rr                    		BEQ L22
00000064                         L19:	; bb14
00000064 FBE2rrrrrrrr            		MOV.L #_status_code, R14
0000006A C4E006                  		MOV.B [R14], 06H[R0]
0000006D 38rrrr               W  		BRA L33
00000070                         L20:	; bb26
                                 ;     156 	if ((isnan((double)nv->value)) || (isinf((double)nv->value)) || (fp_NE(nv->value, nvm.tmp_value))) {
                                 ;     157 		memcpy(&nvm.byte_array, &nvm.tmp_value, NVM_VALUE_LEN);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",157
00000070 FBE2rrrrrrrr            		MOV.L #_nvm, R14
00000076 E5EE0203                		MOV.L 08H[R14], 0CH[R14]
0000007A                         L21:	; bb26.split
                                 ;     158 		nvm.address = nvm.profile_base + (nv->index * NVM_VALUE_LEN);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",158
0000007A A881                    		MOV.L 08H[R0], R1
0000007C B911                    		MOVU.W 08H[R1], R1
0000007E 6C21                    		SHLL #02H, R1
00000080 FB22rrrrrrrr            		MOV.L #_nvm, R2
00000086 06C92101                		ADD 02H[R2].UW, R1
0000008A 90A1                    		MOV.W R1, 04H[R2]
0000008C 2Err                 B  		BRA L31
0000008E                         L22:	; bb36
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",156
0000008E A881                    		MOV.L 08H[R0], R1
00000090 A911                    		MOV.L 10H[R1], R1
00000092 05rrrrrr             A  		BSR __FDclass
00000096 E301                    		MOV.L R1, [R0]
00000098 6121                    		CMP #02H, R1
0000009A 20rr                    		BEQ L24
0000009C                         L23:	; bb60
0000009C A881                    		MOV.L 08H[R0], R1
0000009E A911                    		MOV.L 10H[R1], R1
000000A0 05rrrrrr             A  		BSR __FDclass
000000A4 E301                    		MOV.L R1, [R0]
000000A6 6111                    		CMP #01H, R1
000000A8 18                   S  		BNE L25
000000A9                         L24:	; bb82
000000A9 F80601                  		MOV.L #00000001H, [R0]
000000AC 08                   S  		BRA L26
000000AD                         L25:	; bb83
000000AD F80600                  		MOV.L #00000000H, [R0]
000000B0                         L26:	; bb84
000000B0 EC01                    		MOV.L [R0], R1
000000B2 6101                    		CMP #00H, R1
000000B4 21rr                    		BNE L28
000000B6                         L27:	; bb88
000000B6 A881                    		MOV.L 08H[R0], R1
000000B8 A911                    		MOV.L 10H[R1], R1
000000BA FBE2rrrrrrrr            		MOV.L #_nvm, R14
000000C0 FC81E102                		FSUB 08H[R14].L, R1
000000C4 7BF1                    		BCLR #1FH, R1
000000C6 FBE2BD378635            		MOV.L #358637BDH, R14
000000CC FC871E                  		FCMP R1, R14
000000CF 26rr                    		BPZ L29
000000D1                         L28:	; bb97
000000D1 F80601                  		MOV.L #00000001H, [R0]
000000D4 08                   S  		BRA L30
000000D5                         L29:	; bb98
000000D5 F80600                  		MOV.L #00000000H, [R0]
000000D8                         L30:	; bb99
000000D8 EC01                    		MOV.L [R0], R1
000000DA 6101                    		CMP #00H, R1
000000DC 21rr                    		BNE L20
000000DE                         L31:	; bb104
                                 ;     159 	//	(void)EEPROM_WriteBytes(nvm.address, nvm.byte_array, NVM_VALUE_LEN);
                                 ;     160 	}
                                 ;     161 	nv->value =nvm.tmp_value;		// always restore value
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",161
000000DE FBE2rrrrrrrr            		MOV.L #_nvm, R14
000000E4 A881                    		MOV.L 08H[R0], R1
000000E6 E5E10204                		MOV.L 08H[R14], 10H[R1]
000000EA                         L32:	; bb104.split
                                 ;     162 	return (STAT_OK);
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",162
000000EA 3C0600                  		MOV.B #00H, 06H[R0]
000000ED                         L33:	; bb109
000000ED C5000607                		MOV.B 06H[R0], 07H[R0]
                                 ;     163 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\cnc\persistence.c",163
000000F1 B189                    		MOVU.B 07H[R0], R1
000000F3 6703                    		RTSD #0CH
                                 ;     164 #endif // __ARM
                                 ;     165 
                                 ;     166 #ifdef __cplusplus
                                 ;     167 }
                                 ;     168 #endif
                                 ;     169 
                                 		.SECTION	B,DATA,ALIGN=4
00000000                         _nvm:
00000000(00000010H)              		.blkl	4
                                 		.END

Information List

TOTAL ERROR(S)    00000
TOTAL WARNING(S)  00000
TOTAL LINE(S)     00336   LINES

Section List

Attr         Size               Name
CODE     0000000245(000000F5H)  P
DATA     0000000016(00000010H)  B

Cpu Type

-ISA=RXV1 -FPU

Command Parameter

-subcommand=C:\Users\LAFONS~1\AppData\Local\Temp\$ccrx12DB\$ccrx\persistence.src.cmd
    -nologo
    -isa=rxv1
    -fpu
    -show=conditionals,definitions,expansions
    -define=__RXV1=1
    -fint_register=0
    -debug
    -endian=little
-listfile=C:\Workspace\e2studio\git\MT01\CompactaXP_build\persistence.lst
-output=C:\Workspace\e2studio\git\MT01\CompactaXP_build\src\cnc\persistence.obj
