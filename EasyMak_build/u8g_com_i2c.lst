* RX FAMILY ASSEMBLER V2.03.00.01 [24 Oct 2014] *  SOURCE LIST  Sun Feb 19 10:48:51 2017

LOC.     OBJ.              0XMDA SOURCE STATEMENT

                                 ;RX Family C/C++ Compiler (V2.03.00.03 [04 Dec 2014])  19-Feb-2017 10:48:51
                                 
                                 ;*** CPU TYPE ***
                                 
                                 ;-ISA=RXV1
                                 
                                 ;*** COMMAND PARAMETER ***
                                 
                                 ;-output=src=u8g_com_i2c.src
                                 ;-lang=c99
                                 ;-include=C:\PROGRA~2\Renesas\RX\2_3_0/include,C:\Workspace\e2studio\git\MT01\r_lvd_rx,C:\Workspace\e2studio\git\MT01\r_lvd_rx\src,C:/Workspace/e2studio/git/MT01/r_tfa
                                 ;-debug
                                 ;-show=source,conditionals,definitions,expansions
                                 ;-listfile=u8g_com_i2c.lst
                                 ;-isa=rxv1
                                 ;-optimize=0
                                 ;-fpu
                                 ;-alias=noansi
                                 ;-nologo
                                 ;-nomessage
                                 ;-define=__RX,COMPACTAXP=0,EASYMAK=1,MOBILE=0,FREE_RTOS_PP
                                 ;u8g_com_i2c.c
                                 
                                 		.glb	_u8g_i2c_clear_error
                                 		.glb	_u8g_i2c_get_error
                                 		.glb	_u8g_i2c_get_err_pos
                                 		.glb	_u8g_i2c_init
                                 		.glb	_u8g_i2c_wait
                                 		.glb	_u8g_i2c_start
                                 		.glb	_u8g_i2c_send_byte
                                 		.glb	_u8g_i2c_stop
                                 ;LineNo. C-SOURCE STATEMENT
                                 
                                 		.SECTION	P,CODE
00000000                         _u8g_i2c_clear_error:
                                 		.STACK	_u8g_i2c_clear_error=4
                                 ;       1 /*
                                 ;       2   
                                 ;       3   u8g_com_i2c.c
                                 ;       4 
                                 ;       5   generic i2c interface
                                 ;       6 
                                 ;       7   Universal 8bit Graphics Library
                                 ;       8   
                                 ;       9   Copyright (c) 2011, olikraus@gmail.com
                                 ;      10   All rights reserved.
                                 ;      11 
                                 ;      12   Redistribution and use in source and binary forms, with or without modification, 
                                 ;      13   are permitted provided that the following conditions are met:
                                 ;      14 
                                 ;      15   * Redistributions of source code must retain the above copyright notice, this list 
                                 ;      16     of conditions and the following disclaimer.
                                 ;      17     
                                 ;      18   * Redistributions in binary form must reproduce the above copyright notice, this 
                                 ;      19     list of conditions and the following disclaimer in the documentation and/or other 
                                 ;      20     materials provided with the distribution.
                                 ;      21 
                                 ;      22   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
                                 ;      23   CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
                                 ;      24   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
                                 ;      25   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                                 ;      26   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
                                 ;      27   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
                                 ;      28   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
                                 ;      29   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
                                 ;      30   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
                                 ;      31   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
                                 ;      32   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
                                 ;      33   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
                                 ;      34   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
                                 ;      35   
                                 ;      36 */
                                 ;      37 
                                 ;      38 
                                 ;      39 #include "u8g.h"
                                 ;      40 
                                 ;      41 //#define U8G_I2C_WITH_NO_ACK
                                 ;      42 
                                 ;      43 static uint8_t u8g_i2c_err_code;
                                 ;      44 /*
                                 ;      45   position values
                                 ;      46     1: start condition
                                 ;      47     2: sla transfer
                                 ;      48 */
                                 ;      49 static uint8_t u8g_i2c_err_pos;
                                 ;      50 
                                 ;      51 
                                 ;      52 void u8g_i2c_clear_error(void)
                                 ;      53 {
                                 ;      54   u8g_i2c_err_code = U8G_I2C_ERR_NONE;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",54
00000000 FBE2rrrrrrrr            		MOV.L #__$u8g_i2c_err_code, R14
00000006 F8E400                  		MOV.B #00H, [R14]
00000009                         L11:	; entry.split
                                 ;      55   u8g_i2c_err_pos = 0;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",55
00000009 FBE2rrrrrrrr            		MOV.L #__$u8g_i2c_err_pos, R14
0000000F F8E400                  		MOV.B #00H, [R14]
00000012 02                      		RTS
00000013                         _u8g_i2c_get_error:
                                 		.STACK	_u8g_i2c_get_error=8
                                 ;      56 }
                                 ;      57 
                                 ;      58 uint8_t  u8g_i2c_get_error(void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",58
00000013 6040                    		SUB #04H, R0
                                 ;      59 {
                                 ;      60   return u8g_i2c_err_code;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",60
00000015 FBE2rrrrrrrr            		MOV.L #__$u8g_i2c_err_code, R14
0000001B C4E003                  		MOV.B [R14], 03H[R0]
0000001E B089                    		MOVU.B 03H[R0], R1
00000020                         L13:	; entry.split
                                 ;      61 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",61
00000020 5B11                    		MOVU.B R1, R1
00000022 6701                    		RTSD #04H
00000024                         _u8g_i2c_get_err_pos:
                                 		.STACK	_u8g_i2c_get_err_pos=8
                                 ;      62 
                                 ;      63 uint8_t u8g_i2c_get_err_pos(void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",63
00000024 6040                    		SUB #04H, R0
                                 ;      64 {
                                 ;      65   return u8g_i2c_err_pos;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",65
00000026 FBE2rrrrrrrr            		MOV.L #__$u8g_i2c_err_pos, R14
0000002C C4E003                  		MOV.B [R14], 03H[R0]
0000002F B089                    		MOVU.B 03H[R0], R1
00000031                         L15:	; entry.split
                                 ;      66 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",66
00000031 5B11                    		MOVU.B R1, R1
00000033 6701                    		RTSD #04H
00000035                         _u8g_i2c_init:
                                 		.STACK	_u8g_i2c_init=8
                                 ;      67 
                                 ;      68 
                                 ;      69 
                                 ;      70 #if defined(__AVR__)
                                 ;      71 
                                 ;      72 static void u8g_i2c_set_error(uint8_t code, uint8_t pos)
                                 ;      73 {
                                 ;      74   if ( u8g_i2c_err_code > 0 )
                                 ;      75     return;
                                 ;      76   u8g_i2c_err_code |= code;
                                 ;      77   u8g_i2c_err_pos = pos;
                                 ;      78 }
                                 ;      79 
                                 ;      80 #define U8G_ATMEGA_HW_TWI
                                 ;      81 
                                 ;      82 /* remove the definition for attiny */
                                 ;      83 #if __AVR_ARCH__ == 2
                                 ;      84 #undef U8G_ATMEGA_HW_TWI
                                 ;      85 #endif
                                 ;      86 #if __AVR_ARCH__ == 25
                                 ;      87 #undef U8G_ATMEGA_HW_TWI
                                 ;      88 #endif
                                 ;      89 #endif
                                 ;      90 
                                 ;      91 #if defined(U8G_ATMEGA_HW_TWI)
                                 ;      92 
                                 ;      93 #include <avr/io.h>
                                 ;      94 #include <util/twi.h>
                                 ;      95 
                                 ;      96 
                                 ;      97 
                                 ;      98 void u8g_i2c_init(uint8_t options)
                                 ;      99 {
                                 ;     100   /*
                                 ;     101   TWBR: bit rate register
                                 ;     102   TWSR: status register (contains preselector bits)
                                 ;     103 
                                 ;     104   prescalar
                                 ;     105     0		1
                                 ;     106     1		4
                                 ;     107     2		16
                                 ;     108     3		64
                                 ;     109 
                                 ;     110   f = F_CPU/(16+2*TWBR*prescalar)
                                 ;     111   
                                 ;     112   F_CPU = 16MHz
                                 ;     113     TWBR = 152;
                                 ;     114     TWSR = 0;
                                 ;     115 	--> 50KHz
                                 ;     116 
                                 ;     117     TWBR = 72;
                                 ;     118     TWSR = 0;
                                 ;     119 	--> 100KHz
                                 ;     120 
                                 ;     121     TWBR = 12;
                                 ;     122     TWSR = 0;
                                 ;     123 	--> 400KHz
                                 ;     124 
                                 ;     125     F_CPU/(2*100000)-8  --> calculate TWBR value for 100KHz
                                 ;     126 */
                                 ;     127   u8g_i2c_opt = options;
                                 ;     128   TWSR = 0;
                                 ;     129   if ( options & U8G_I2C_OPT_FAST )
                                 ;     130   {
                                 ;     131     TWBR = F_CPU/(2*400000)-8;
                                 ;     132   }
                                 ;     133   else
                                 ;     134   {  
                                 ;     135     TWBR = F_CPU/(2*100000)-8;
                                 ;     136   }
                                 ;     137   u8g_i2c_clear_error();
                                 ;     138 }
                                 ;     139 
                                 ;     140 uint8_t u8g_i2c_wait(uint8_t mask, uint8_t pos)
                                 ;     141 {
                                 ;     142   volatile uint16_t cnt = 2000;	/* timout value should be > 280 for 50KHz Bus and 16 Mhz CPU, however the start condition might need longer */
                                 ;     143   while( !(TWCR & mask) )
                                 ;     144   {
                                 ;     145       if ( cnt == 0 )
                                 ;     146       {
                                 ;     147 	if ( u8g_i2c_opt & U8G_I2C_OPT_NO_ACK )
                                 ;     148 	{
                                 ;     149 	  return 1;	/* all ok */
                                 ;     150 	}
                                 ;     151 	else
                                 ;     152 	{
                                 ;     153 	  u8g_i2c_set_error(U8G_I2C_ERR_TIMEOUT, pos);
                                 ;     154 	  return 0; /* error */
                                 ;     155 	}
                                 ;     156       }
                                 ;     157       cnt--;
                                 ;     158     }
                                 ;     159   return 1;	/* all ok */
                                 ;     160 }
                                 ;     161 
                                 ;     162 /* sla includes all 8 bits (with r/w bit), assums master transmit */
                                 ;     163 uint8_t u8g_i2c_start(uint8_t sla)
                                 ;     164 {
                                 ;     165   register uint8_t status;
                                 ;     166   
                                 ;     167   /* send start */
                                 ;     168   TWCR = _BV(TWINT) |  _BV(TWSTA)  |  _BV(TWEN);
                                 ;     169    
                                 ;     170   /* wait */
                                 ;     171   if ( u8g_i2c_wait(_BV(TWINT), 1) == 0 )
                                 ;     172     return 0;
                                 ;     173   
                                 ;     174   status = TW_STATUS;
                                 ;     175  
                                 ;     176   /* check status after start */  
                                 ;     177   if ( status != TW_START && status != TW_REP_START )
                                 ;     178   {
                                 ;     179     u8g_i2c_set_error(U8G_I2C_ERR_BUS, 1);
                                 ;     180     return 0;
                                 ;     181   }
                                 ;     182 
                                 ;     183   /* set slave address */  
                                 ;     184   TWDR = sla;
                                 ;     185   
                                 ;     186   /* enable sla transfer */
                                 ;     187   TWCR = _BV(TWINT)  |  _BV(TWEN);
                                 ;     188 
                                 ;     189   /* wait */
                                 ;     190   if ( u8g_i2c_wait(_BV(TWINT), 2) == 0 )
                                 ;     191     return 0;
                                 ;     192 
                                 ;     193   if ( u8g_i2c_opt & U8G_I2C_OPT_NO_ACK )
                                 ;     194   {
                                 ;     195     /* do not check for ACK */
                                 ;     196   }
                                 ;     197   else
                                 ;     198   {
                                 ;     199     status = TW_STATUS;
                                 ;     200     /* check status after sla */  
                                 ;     201     if ( status != TW_MT_SLA_ACK )
                                 ;     202     {
                                 ;     203       u8g_i2c_set_error(U8G_I2C_ERR_BUS, 2);
                                 ;     204       return 0;
                                 ;     205     }
                                 ;     206   }
                                 ;     207 
                                 ;     208    return 1;
                                 ;     209 }
                                 ;     210 
                                 ;     211 uint8_t u8g_i2c_send_byte(uint8_t data)
                                 ;     212 {
                                 ;     213   register uint8_t status;
                                 ;     214   TWDR = data;
                                 ;     215   TWCR = _BV(TWINT)  |  _BV(TWEN);
                                 ;     216   if ( u8g_i2c_wait(_BV(TWINT), 3) == 0 )
                                 ;     217     return 0;
                                 ;     218     
                                 ;     219   if ( u8g_i2c_opt & U8G_I2C_OPT_NO_ACK )
                                 ;     220   {
                                 ;     221     /* do not check for ACK */
                                 ;     222   }
                                 ;     223   else
                                 ;     224   {
                                 ;     225     status = TW_STATUS;  
                                 ;     226     if ( status != TW_MT_DATA_ACK )
                                 ;     227     {
                                 ;     228       u8g_i2c_set_error(U8G_I2C_ERR_BUS, 3);
                                 ;     229       return 0;
                                 ;     230     }
                                 ;     231   }
                                 ;     232 
                                 ;     233   return 1;  
                                 ;     234 }
                                 ;     235 
                                 ;     236 void u8g_i2c_stop(void)
                                 ;     237 {
                                 ;     238   /* write stop */
                                 ;     239   TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWSTO);
                                 ;     240 
                                 ;     241   /* no error is checked for the stop condition */  
                                 ;     242   u8g_i2c_wait(_BV(TWSTO), 4);
                                 ;     243   
                                 ;     244 }
                                 ;     245 
                                 ;     246 /*
                                 ;     247 void twi_send(uint8_t adr, uint8_t data1, uint8_t data2)
                                 ;     248 {
                                 ;     249   u8g_i2c_start(adr<<1);
                                 ;     250   u8g_i2c_send_byte(data1);
                                 ;     251   u8g_i2c_send_byte(data2);
                                 ;     252   u8g_i2c_stop();
                                 ;     253 }
                                 ;     254 */
                                 ;     255 
                                 ;     256 #elif defined(ARDUINO) && defined(__SAM3X8E__)
                                 ;     257 /* Arduino Due */
                                 ;     258 #include "Arduino.h"
                                 ;     259 #include "sam.h"
                                 ;     260 
                                 ;     261 /*
                                 ;     262 
                                 ;     263 Controller
                                 ;     264 
                                 ;     265 TWI0 TWCK0 PA18 A			DUE PCB: SCL1
                                 ;     266 TWI0 TWD0 PA17 A			DUE PCB: SDA1 
                                 ;     267 TWI1 TWCK1 PB13 A			DUE PCB: SCL 21
                                 ;     268 TWI1 TWD1 PB12 A			DUE PCB: SDA 20
                                 ;     269 
                                 ;     270 Arduino definitions
                                 ;     271 
                                 ;     272 #define PIN_WIRE_SDA         (20u)
                                 ;     273 #define PIN_WIRE_SCL         (21u)
                                 ;     274 #define WIRE_INTERFACE       TWI1
                                 ;     275 #define WIRE_INTERFACE_ID    ID_TWI1
                                 ;     276 #define WIRE_ISR_HANDLER     TWI1_Handler
                                 ;     277 
                                 ;     278 #define PIN_WIRE1_SDA        (70u)
                                 ;     279 #define PIN_WIRE1_SCL        (71u)
                                 ;     280 #define WIRE1_INTERFACE      TWI0
                                 ;     281 #define WIRE1_INTERFACE_ID   ID_TWI0
                                 ;     282 #define WIRE1_ISR_HANDLER    TWI0_Handler
                                 ;     283 
                                 ;     284 
                                 ;     285 */
                                 ;     286 
                                 ;     287 static void i2c_400KHz_delay(void)
                                 ;     288 {
                                 ;     289   /* should be at least 4 */
                                 ;     290   /* should be 5 for 100KHz transfer speed */
                                 ;     291  
                                 ;     292   
                                 ;     293   /*
                                 ;     294     Arduino Due
                                 ;     295     0x NOP: 470KHz
                                 ;     296     4x NOP: 450KHz
                                 ;     297     8x NOP: 430KHz
                                 ;     298     16x NOP: 400KHz
                                 ;     299   */
                                 ;     300   
                                 ;     301   __NOP();
                                 ;     302   __NOP();
                                 ;     303   __NOP();
                                 ;     304   __NOP();
                                 ;     305   
                                 ;     306   __NOP();
                                 ;     307   __NOP();
                                 ;     308   __NOP();
                                 ;     309   __NOP();
                                 ;     310 
                                 ;     311   __NOP();
                                 ;     312   __NOP();
                                 ;     313   __NOP();
                                 ;     314   __NOP();
                                 ;     315 
                                 ;     316   __NOP();
                                 ;     317   __NOP();
                                 ;     318   __NOP();
                                 ;     319   __NOP();
                                 ;     320 }
                                 ;     321 
                                 ;     322 static void i2c_100KHz_delay(void)
                                 ;     323 {
                                 ;     324   /* 
                                 ;     325     1x u8g_MicroDelay()	ca. 130KHz
                                 ;     326     2x u8g_MicroDelay()	ca. 80KHz 
                                 ;     327   */
                                 ;     328   u8g_MicroDelay();
                                 ;     329   u8g_MicroDelay();  
                                 ;     330 }
                                 ;     331 
                                 ;     332 
                                 ;     333 uint32_t i2c_started = 0;
                                 ;     334 uint32_t i2c_scl_pin = 0;
                                 ;     335 uint32_t i2c_sda_pin = 0;
                                 ;     336 void (*i2c_delay)(void) = i2c_100KHz_delay;
                                 ;     337 
                                 ;     338 const PinDescription *i2c_scl_pin_desc;
                                 ;     339 const PinDescription *i2c_sda_pin_desc;
                                 ;     340 
                                 ;     341 
                                 ;     342 /* maybe this can be optimized */
                                 ;     343 static void i2c_init(void)
                                 ;     344 {
                                 ;     345   i2c_sda_pin_desc = &(g_APinDescription[i2c_sda_pin]);
                                 ;     346   i2c_scl_pin_desc = &(g_APinDescription[i2c_scl_pin]);
                                 ;     347   pinMode(i2c_sda_pin, OUTPUT);
                                 ;     348   digitalWrite(i2c_sda_pin, HIGH);
                                 ;     349   pinMode(i2c_scl_pin, OUTPUT);
                                 ;     350   digitalWrite(i2c_scl_pin, HIGH);
                                 ;     351   PIO_Configure( i2c_sda_pin_desc->pPort, PIO_OUTPUT_0, i2c_sda_pin_desc->ulPin, PIO_OPENDRAIN );
                                 ;     352   PIO_Configure( i2c_scl_pin_desc->pPort, PIO_OUTPUT_0, i2c_scl_pin_desc->ulPin, PIO_OPENDRAIN );
                                 ;     353   PIO_Clear( i2c_sda_pin_desc->pPort, i2c_sda_pin_desc->ulPin) ;
                                 ;     354   PIO_Clear( i2c_scl_pin_desc->pPort, i2c_scl_pin_desc->ulPin) ;
                                 ;     355   PIO_Configure( i2c_sda_pin_desc->pPort, PIO_INPUT, i2c_sda_pin_desc->ulPin, PIO_DEFAULT ) ;
                                 ;     356   PIO_Configure( i2c_scl_pin_desc->pPort, PIO_INPUT, i2c_scl_pin_desc->ulPin, PIO_DEFAULT ) ;
                                 ;     357   i2c_delay();
                                 ;     358 }
                                 ;     359 
                                 ;     360 /* actually, the scl line is not observed, so this procedure does not return a value */
                                 ;     361 static void i2c_read_scl_and_delay(void)
                                 ;     362 {
                                 ;     363   uint32_t dwMask = i2c_scl_pin_desc->ulPin;
                                 ;     364   //PIO_Configure( i2c_scl_pin_desc->pPort, PIO_INPUT, i2c_scl_pin_desc->ulPin, PIO_DEFAULT ) ;
                                 ;     365   //PIO_SetInput( i2c_scl_pin_desc->pPort, i2c_scl_pin_desc->ulPin, PIO_DEFAULT ) ;
                                 ;     366 
                                 ;     367   /* set as input */
                                 ;     368   i2c_scl_pin_desc->pPort->PIO_ODR = dwMask ;
                                 ;     369   i2c_scl_pin_desc->pPort->PIO_PER = dwMask ;
                                 ;     370 
                                 ;     371   i2c_delay();
                                 ;     372 }
                                 ;     373 
                                 ;     374 static void i2c_clear_scl(void)
                                 ;     375 {
                                 ;     376   uint32_t dwMask = i2c_scl_pin_desc->ulPin;
                                 ;     377   
                                 ;     378   /* set open collector and drive low */
                                 ;     379   //PIO_Configure( i2c_scl_pin_desc->pPort, PIO_OUTPUT_0, i2c_scl_pin_desc->ulPin, PIO_OPENDRAIN );
                                 ;     380   //PIO_SetOutput( i2c_scl_pin_desc->pPort, i2c_scl_pin_desc->ulPin, 0, 1, 0);
                                 ;     381 
                                 ;     382   /* open drain, zero default output */
                                 ;     383   i2c_scl_pin_desc->pPort->PIO_MDER = dwMask;
                                 ;     384   i2c_scl_pin_desc->pPort->PIO_CODR = dwMask;
                                 ;     385   i2c_scl_pin_desc->pPort->PIO_OER = dwMask;
                                 ;     386   i2c_scl_pin_desc->pPort->PIO_PER = dwMask;
                                 ;     387 
                                 ;     388   //PIO_Clear( i2c_scl_pin_desc->pPort, i2c_scl_pin_desc->ulPin) ;
                                 ;     389 }
                                 ;     390 
                                 ;     391 static uint8_t i2c_read_sda(void)
                                 ;     392 {
                                 ;     393   uint32_t dwMask = i2c_sda_pin_desc->ulPin;
                                 ;     394   //PIO_Configure( i2c_sda_pin_desc->pPort, PIO_INPUT, i2c_sda_pin_desc->ulPin, PIO_DEFAULT ) ;
                                 ;     395   //PIO_SetInput( i2c_sda_pin_desc->pPort, i2c_sda_pin_desc->ulPin, PIO_DEFAULT ) ;
                                 ;     396 
                                 ;     397   /* set as input */
                                 ;     398   i2c_sda_pin_desc->pPort->PIO_ODR = dwMask ;
                                 ;     399   i2c_sda_pin_desc->pPort->PIO_PER = dwMask ;
                                 ;     400 
                                 ;     401 
                                 ;     402   return 1;
                                 ;     403 }
                                 ;     404 
                                 ;     405 static void i2c_clear_sda(void)
                                 ;     406 {
                                 ;     407   uint32_t dwMask = i2c_sda_pin_desc->ulPin;
                                 ;     408   
                                 ;     409   /* set open collector and drive low */
                                 ;     410   //PIO_Configure( i2c_sda_pin_desc->pPort, PIO_OUTPUT_0, i2c_sda_pin_desc->ulPin, PIO_OPENDRAIN );
                                 ;     411   //PIO_SetOutput( i2c_sda_pin_desc->pPort, i2c_sda_pin_desc->ulPin, 0, 1, 0);
                                 ;     412   
                                 ;     413   /* open drain, zero default output */
                                 ;     414   i2c_sda_pin_desc->pPort->PIO_MDER = dwMask ;
                                 ;     415   i2c_sda_pin_desc->pPort->PIO_CODR = dwMask ;
                                 ;     416   i2c_sda_pin_desc->pPort->PIO_OER = dwMask ;
                                 ;     417   i2c_sda_pin_desc->pPort->PIO_PER = dwMask ;
                                 ;     418   
                                 ;     419   //PIO_Clear( i2c_sda_pin_desc->pPort, i2c_sda_pin_desc->ulPin) ;
                                 ;     420 }
                                 ;     421 
                                 ;     422 static void i2c_start(void)
                                 ;     423 {
                                 ;     424   if ( i2c_started != 0 )
                                 ;     425   {
                                 ;     426     /* if already started: do restart */
                                 ;     427     i2c_read_sda();     /* SDA = 1 */
                                 ;     428     i2c_delay();
                                 ;     429     i2c_read_scl_and_delay();
                                 ;     430   }
                                 ;     431   i2c_read_sda();
                                 ;     432   /*
                                 ;     433   if (i2c_read_sda() == 0)
                                 ;     434   {
                                 ;     435     // do something because arbitration is lost
                                 ;     436   }
                                 ;     437   */
                                 ;     438   /* send the start condition, both lines go from 1 to 0 */
                                 ;     439   i2c_clear_sda();
                                 ;     440   i2c_delay();
                                 ;     441   i2c_clear_scl();
                                 ;     442   i2c_started = 1;
                                 ;     443 }
                                 ;     444 
                                 ;     445 
                                 ;     446 static void i2c_stop(void)
                                 ;     447 {
                                 ;     448   /* set SDA to 0 */
                                 ;     449   i2c_clear_sda();  
                                 ;     450   i2c_delay();
                                 ;     451  
                                 ;     452   /* now release all lines */
                                 ;     453   i2c_read_scl_and_delay();
                                 ;     454  
                                 ;     455   /* set SDA to 1 */
                                 ;     456   i2c_read_sda();
                                 ;     457   i2c_delay();
                                 ;     458   i2c_started = 0;
                                 ;     459 }
                                 ;     460 
                                 ;     461 static void i2c_write_bit(uint8_t val)
                                 ;     462 {
                                 ;     463   if (val)
                                 ;     464     i2c_read_sda();
                                 ;     465   else
                                 ;     466     i2c_clear_sda();
                                 ;     467  
                                 ;     468   i2c_delay();
                                 ;     469   i2c_read_scl_and_delay();
                                 ;     470   i2c_clear_scl();
                                 ;     471 }
                                 ;     472 
                                 ;     473 static uint8_t i2c_read_bit(void)
                                 ;     474 {
                                 ;     475   uint8_t val;
                                 ;     476   /* do not drive SDA */
                                 ;     477   i2c_read_sda();
                                 ;     478   i2c_delay();
                                 ;     479   i2c_read_scl_and_delay();
                                 ;     480   val = i2c_read_sda();
                                 ;     481   i2c_delay();
                                 ;     482   i2c_clear_scl();
                                 ;     483   return val;
                                 ;     484 }
                                 ;     485 
                                 ;     486 static uint8_t i2c_write_byte(uint8_t b)
                                 ;     487 {
                                 ;     488   i2c_write_bit(b & 128);
                                 ;     489   i2c_write_bit(b & 64);
                                 ;     490   i2c_write_bit(b & 32);
                                 ;     491   i2c_write_bit(b & 16);
                                 ;     492   i2c_write_bit(b & 8);
                                 ;     493   i2c_write_bit(b & 4);
                                 ;     494   i2c_write_bit(b & 2);
                                 ;     495   i2c_write_bit(b & 1);
                                 ;     496     
                                 ;     497   /* read ack from client */
                                 ;     498   /* 0: ack was given by client */
                                 ;     499   /* 1: nothing happend during ack cycle */  
                                 ;     500   return i2c_read_bit();
                                 ;     501 }
                                 ;     502 
                                 ;     503 
                                 ;     504 
                                 ;     505 void u8g_i2c_init(uint8_t options)
                                 ;     506 {
                                 ;     507   u8g_i2c_opt = options;
                                 ;     508   u8g_i2c_clear_error();
                                 ;     509 
                                 ;     510   if ( u8g_i2c_opt & U8G_I2C_OPT_FAST )
                                 ;     511   {
                                 ;     512     i2c_delay = i2c_400KHz_delay;
                                 ;     513   }
                                 ;     514   else
                                 ;     515   {
                                 ;     516     i2c_delay = i2c_100KHz_delay;
                                 ;     517   }
                                 ;     518 
                                 ;     519 
                                 ;     520   if ( u8g_i2c_opt & U8G_I2C_OPT_DEV_1 )
                                 ;     521   {
                                 ;     522     i2c_scl_pin = PIN_WIRE1_SCL;
                                 ;     523     i2c_sda_pin = PIN_WIRE1_SDA;
                                 ;     524     
                                 ;     525     //REG_PIOA_PDR = PIO_PB12A_TWD1 | PIO_PB13A_TWCK1;
                                 ;     526   }
                                 ;     527   else
                                 ;     528   {    
                                 ;     529     
                                 ;     530     i2c_scl_pin = PIN_WIRE_SCL;
                                 ;     531     i2c_sda_pin = PIN_WIRE_SDA;
                                 ;     532     
                                 ;     533     //REG_PIOA_PDR = PIO_PA17A_TWD0 | PIO_PA18A_TWCK0;
                                 ;     534   }
                                 ;     535   
                                 ;     536   i2c_init();
                                 ;     537 
                                 ;     538 }
                                 ;     539 
                                 ;     540 /* sla includes also the r/w bit */
                                 ;     541 uint8_t u8g_i2c_start(uint8_t sla)
                                 ;     542 {  
                                 ;     543   i2c_start();
                                 ;     544   i2c_write_byte(sla);
                                 ;     545   return 1;
                                 ;     546 }
                                 ;     547 
                                 ;     548 uint8_t u8g_i2c_send_byte(uint8_t data)
                                 ;     549 {
                                 ;     550   return i2c_write_byte(data);
                                 ;     551 }
                                 ;     552 
                                 ;     553 void u8g_i2c_stop(void)
                                 ;     554 {
                                 ;     555   i2c_stop();
                                 ;     556 }
                                 ;     557 
                                 ;     558 
                                 ;     559 #elif defined(U8G_RASPBERRY_PI)
                                 ;     560 
                                 ;     561 #include <wiringPi.h>
                                 ;     562 #include <wiringPiI2C.h>
                                 ;     563 #include <stdio.h>
                                 ;     564 #include <stdlib.h>
                                 ;     565 #include <errno.h>
                                 ;     566 
                                 ;     567 #define I2C_SLA         0x3c
                                 ;     568 
                                 ;     569 static int fd=-1;
                                 ;     570 static uint8_t i2cMode = 0;
                                 ;     571 
                                 ;     572 void u8g_i2c_init(uint8_t options) {
                                 ;     573    u8g_i2c_clear_error();
                                 ;     574    u8g_i2c_opt = options;
                                 ;     575 
                                 ;     576    if (wiringPiSetup() == -1) {
                                 ;     577       printf("wiringPi-Error\n");
                                 ;     578       exit(1);
                                 ;     579    }
                                 ;     580 
                                 ;     581    fd = wiringPiI2CSetup(I2C_SLA);
                                 ;     582    if (fd < 0) {
                                 ;     583       printf ("Unable to open I2C device 0: %s\n", strerror (errno)) ;
                                 ;     584       exit (1) ;
                                 ;     585    }
                                 ;     586    //u8g_SetPIOutput(u8g, U8G_PI_RESET);
                                 ;     587    //u8g_SetPIOutput(u8g, U8G_PI_A0);
                                 ;     588 }
                                 ;     589 uint8_t u8g_i2c_start(uint8_t sla) {
                                 ;     590    u8g_i2c_send_mode(0);
                                 ;     591 
                                 ;     592    return 1;
                                 ;     593 }
                                 ;     594 
                                 ;     595 void u8g_i2c_stop(void) {
                                 ;     596 }
                                 ;     597 
                                 ;     598 uint8_t u8g_i2c_send_mode(uint8_t mode) {
                                 ;     599    i2cMode = mode;
                                 ;     600 } 
                                 ;     601 
                                 ;     602 uint8_t u8g_i2c_send_byte(uint8_t data) {
                                 ;     603    wiringPiI2CWriteReg8(fd, i2cMode, data);
                                 ;     604 
                                 ;     605    return 1;
                                 ;     606 }
                                 ;     607 
                                 ;     608 uint8_t u8g_i2c_wait(uint8_t mask, uint8_t pos)
                                 ;     609 {
                                 ;     610   return 1;
                                 ;     611 }
                                 ;     612 
                                 ;     613 #else
                                 ;     614 
                                 ;     615 /* empty interface */
                                 ;     616 
                                 ;     617 void u8g_i2c_init(uint8_t options)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",617
00000035 6040                    		SUB #04H, R0
00000037 8089                    		MOV.B R1, 03H[R0]
                                 ;     618 {
                                 ;     619   u8g_i2c_clear_error();
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",619
00000039 39rrrr               W  		BSR _u8g_i2c_clear_error
0000003C 6701                    		RTSD #04H
0000003E                         _u8g_i2c_wait:
                                 		.STACK	_u8g_i2c_wait=8
                                 ;     620 }
                                 ;     621 
                                 ;     622 uint8_t u8g_i2c_wait(uint8_t mask, uint8_t pos)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",622
0000003E 6040                    		SUB #04H, R0
00000040 8089                    		MOV.B R1, 03H[R0]
00000042 8082                    		MOV.B R2, 02H[R0]
                                 ;     623 {
                                 ;     624   return 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",624
00000044 3C0101                  		MOV.B #01H, 01H[R0]
00000047 B009                    		MOVU.B 01H[R0], R1
00000049                         L18:	; entry.split
                                 ;     625 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",625
00000049 5B11                    		MOVU.B R1, R1
0000004B 6701                    		RTSD #04H
0000004D                         _u8g_i2c_start:
                                 		.STACK	_u8g_i2c_start=8
                                 ;     626 
                                 ;     627 uint8_t u8g_i2c_start(uint8_t sla)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",627
0000004D 6040                    		SUB #04H, R0
0000004F 8089                    		MOV.B R1, 03H[R0]
                                 ;     628 {
                                 ;     629   return 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",629
00000051 3C0201                  		MOV.B #01H, 02H[R0]
00000054 B081                    		MOVU.B 02H[R0], R1
00000056                         L20:	; entry.split
                                 ;     630 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",630
00000056 5B11                    		MOVU.B R1, R1
00000058 6701                    		RTSD #04H
0000005A                         _u8g_i2c_send_byte:
                                 		.STACK	_u8g_i2c_send_byte=8
                                 ;     631 uint8_t u8g_i2c_send_byte(uint8_t data)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",631
0000005A 6040                    		SUB #04H, R0
0000005C 8089                    		MOV.B R1, 03H[R0]
                                 ;     632 {
                                 ;     633   return 1;
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",633
0000005E 3C0201                  		MOV.B #01H, 02H[R0]
00000061 B081                    		MOVU.B 02H[R0], R1
00000063                         L22:	; entry.split
                                 ;     634 }
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",634
00000063 5B11                    		MOVU.B R1, R1
00000065 6701                    		RTSD #04H
00000067                         _u8g_i2c_stop:
                                 		.STACK	_u8g_i2c_stop=4
                                 ;     635 
                                 ;     636 void u8g_i2c_stop(void)
                                 		.LINE  "C:\Workspace\e2studio\git\MT01\src\Display\u8g_com_i2c.c",636
00000067 02                      		RTS
                                 ;     637 {
                                 ;     638 }
                                 ;     639 
                                 ;     640 
                                 ;     641 #endif
                                 ;     642 
                                 		.SECTION	B_1,DATA
00000000                         __$u8g_i2c_err_code:
00000000(00000001H)              		.blkb	1
00000001                         __$u8g_i2c_err_pos:
00000001(00000001H)              		.blkb	1
                                 		.END

Information List

TOTAL ERROR(S)    00000
TOTAL WARNING(S)  00000
TOTAL LINE(S)     00765   LINES

Section List

Attr         Size               Name
CODE     0000000104(00000068H)  P
DATA     0000000002(00000002H)  B_1

Cpu Type

-ISA=RXV1 -FPU

Command Parameter

-subcommand=C:\Users\LAFONS~1\AppData\Local\Temp\$ccrx12DB\$ccrx\u8g_com_i2c.src.cmd
    -nologo
    -isa=rxv1
    -fpu
    -show=conditionals,definitions,expansions
    -define=__RXV1=1
    -fint_register=0
    -debug
    -endian=little
-listfile=C:\Workspace\e2studio\git\MT01\EasyMak_build\u8g_com_i2c.lst
-output=C:\Workspace\e2studio\git\MT01\EasyMak_build\src\Display\u8g_com_i2c.obj
